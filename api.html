<!DOCTYPE html>
<head> 
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name='generator' value='Ronn/v0.4.1'> 
	<title>node(1) -- evented I/O for V8 JavaScript</title> 
	<style type='text/css'> 
		*{
			margin: 0;padding: 0;
		}
		html,body
		{
			height: 100%;
		}
		body
		{
			font-family:helvetica, arial, sans serif;
			background:#22252a;
			color:#eee;
			font-size:16px;
      line-height:1.3;
			position:relative;
			min-width: 690px;
		}
		a
		{
			color:#CD5;
		}
		a:focus
		{
			outline: none;
			-moz-outline: none;
		}
		pre
		{
			overflow: hidden;
		}
		li
		{
			list-style: inside;
		}
		#man,#man code,#man pre,#man tt,#man kbd,#man samp
		{
			line-height:1.6;
			color:#eee;
			background:#22252a;
		}

		#man
		{
			margin: 0;
			position: absolute;
			top:0;
			bottom:0;
			left: 225px;
			right: 0;
			overflow: auto;
		}
		#man-content
		{
			padding: 0 20px;
			max-width: 650px;
		}
		#man h1,#man h2,#man h3
		{
			color:#DCDDDE;
			clear:left;		
		}

		#man h1
		{
			background:url("http://nodejs.org/logo.png") no-repeat scroll center 0 transparent;
			height:111px;
			margin:15px 0 20px;
			text-align:center;
			text-indent:-2000px;
		}

		#man h2
		{
			font-size:18px;
			background:#000;
			color:#CD5;
			margin:10px 0;
			padding:5px 10px;
		}

		#man h3
		{
			font-size:16px;
			margin:0 0 0 0ex;
		}

		#man p,#man ul,#man ol,#man dl,#man pre
		{
			margin:0 0 18px;
		}

		#man pre
		{
			color:#CCCDCE;
			background:#121314;
			border-left:2ex solid #222;
			margin:0 0 20px;
			padding:5px 7px;
		}

		#man pre + h2,#man pre + h3
		{
			margin-top:22px;
		}

		#man h2 + pre,#man h3 + pre
		{
			margin-top:5px;
		}

		#man > p,#man > ul,#man > ol,#man > dl,#man > pre
		{
			margin-left:5%;
		}

		#man dt
		{
			clear:left;
			margin:0;
		}

		#man dt.flush
		{
			float:left;
			width:8ex;
		}

		#man dd
		{
			margin:0 0 0 9ex;
		}

		#man code,#man strong,#man b
		{
			font-weight:bold;
			color:#ECEDEE;
		}

		#man pre code
		{
			font-weight:normal;
			color:#DCDDDE;
			background:inherit;
		}

		#man em,var,u
		{
			font-style:normal;
			color:#CCCDCE;
			border-bottom:1px solid #999;
		}

		#man ol.man,#man ol.man li
		{
			float:left;
			width:33%;
			list-style-type:none;
			text-transform:uppercase;
			font-size:18px;
			color:#666;
			letter-spacing:1px;
			margin:2px 0 10px;
			padding:0;
		}

		#man ol.man
		{
			width:100%;
		}

		#man ol.man li.tl
		{
			text-align:left;
		}

		#man ol.man li.tc
		{
			text-align:center;
			letter-spacing:4px;
		}

		#man ol.man li.tr
		{
			text-align:right;
		}

		#man ol.man a
		{
			color:#666;
		}

		#man ol.man a:hover
		{
			color:#CCCDCE;
		}

		#toc
		{
			position: absolute;
			top:0;
			bottom:0;
			left: 0;
			padding-left: 30px;
			width: 195px;
			overflow: auto;
			overflow-x: hidden;
			font-size: 15px;
		}
		#toc li
		{
			text-wrap: word-wrap;
		}
		#toc a
		{
			display: inline-block;
			width: 100%;
			color: #fff;
			text-decoration:none;
		}
		#toc > a:hover
		{
			color: rgba(255,255,255,0.7);
		}
		#toc > ul > li
		{
			border-bottom:1px solid #0f1214;
			padding:5px 0 5px 5px;
			list-style: none;
			line-height: 1.3;
		}
		#toc ul ul
		{
			display: none;
		}
		#toc ul ul > li
		{
			border-top:1px solid rgba(0, 0, 0, 0.1);
			color:#FFFFFF;
			font-size:85%;
			line-height:1.3;
			list-style:disc outside none;
			margin-left:25px;
			max-width:165px;
			padding:3px 0 5px 5px;
		}
		#toc li.active > a
		{
			color:#CD5;
		}

		.sh_sourceCode
		{
			font-family: monospace;
			overflow:hidden;
		}

		#toc .toggler
		{
			-moz-user-select:none;
			background:none repeat scroll 0 0 #000000;
			color:#FFFFFF;
			display:inline-block;
			font-weight:bold;
			height:31px;
			line-height:32px;
			margin:-5px 8px -18px -33px;
			outline:medium none;
			padding:0;
			text-align:center;
			width:25px;
		}
		.current-section
		{
			position: fixed;
			top: 0;
			margin: 0 !important;
		}
		#toctitle
		{
			background:none repeat scroll 0 0 #000000;
			color:#CCDD55;
			font-size:18px;
			margin: 0 0 10px -30px;
			padding: 10px;
		}
	</style>
<link rel="stylesheet" href="./sh_vim-dark.css" type="text/css" />
</head>
<body>

<div id="toc">
	<div id="toctitle">Node v0.2.0</div>
	<noscript>JavaScript must be enabled in your browser to display the table of contents.</noscript>
</div>
<div id='man'>
<div id="man-content">
<div id="copyright" style="font-size: 12px; color: #CCCCCC; bottom: 0pt; z-index: 255; background-color: #12151a; position: fixed; padding: 10px; margin: 0px; display: block; opacity: 0.95;">
  このページは <a href="http://nodejs.org/">nodejs.org</a> を
  <a href="http://groups.google.co.jp/group/nodejs_jp/">Node.js日本ユーザグループ</a>の
  <a href="http://groups.google.co.jp/group/nodejs_jp/web/signup"/>有志</a>が日本語訳したものです。
  画像、デザイン及びオリジナル文書(英文)の著作権は、オリジナルの作者に帰属します。
  訳文の著作権は、<a href="http://github.com/nodejsjp/nodejs.org_ja/commits/master"/>それぞれの訳者</a>に帰属します。
</div>

<ol class='head man'>
  <li class='tl'>node(1)</li>

  <li class='tc'></li>
  <li class='tr'>node(1)</li>
</ol>
<h1>node(1) -- V8 JavaScript によるイベント化された I/O</h1>
<!--
<h1>node(1) -- evented I/O for V8 JavaScript</h1>
-->

<h2 id="Synopsis">概要</h2>
<!--
<h2 id="Synopsis">Synopsis</h2>
-->

<p>'Hello World' と返答する Node で書かれたWebサーバの例:</p>
<!--
<p>An example of a web server written with Node which responds with 'Hello
World':</p>
-->

<pre><code>var http = require('http');

http.createServer(function (request, response) {
  response.writeHead(200, {'Content-Type': 'text/plain'});
  response.end('Hello World\n');
}).listen(8124);

console.log('Server running at http://127.0.0.1:8124/');</code></pre>

<p>このサーバを実行するには、コードを <code>example.js</code> というファイルに保存し、
node コマンドで実行してください。</p>
<!--
<p>To run the server, put the code into a file called <code>example.js</code> and execute
it with the node program</p>
-->

<pre><code>&gt; node example.js
Server running at http://127.0.0.1:8124/</code></pre>

<p>このドキュメントの全てのサンプルは同じように実行することができます。</p>
<!--
<p>All of the examples in the documentation can be run similarly.</p>
-->

<h2 id="Standard Modules">標準モジュール</h2>
<!--
<h2 id="Standard Modules">Standard Modules</h2>
-->

<p>Node にはプロセス内でコンパイルされるいくつかのモジュールが含まれていて、
そのほとんどは以下に文書化されています。これらのモジュールを使用するもっとも一般的な方法は、
<code>require('name')</code> の戻り値を、モジュールと同じ名前のローカル変数に割り当てることです。</p>
<!--
<p>Node comes with a number of modules that are compiled in to the process,
most of which are documented below.  The most common way to use these modules
is with <code>require('name')</code> and then assigning the return value to a local
variable with the same name as the module.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>var sys = require('sys');</code></pre>

<p>その他のモジュールで node を拡張することも可能です。「モジュール」を参照してください。</p>
<!--
<p>It is possible to extend node with other modules.  See <code>'Modules'</code></p>
-->

<h2 id="Buffers">バッファ</h2>
<!--
<h2 id="Buffers">Buffers</h2>
-->

<p>純粋な JavaScript は Unicode と相性がいいものの、バイナリデータの扱いはうまくありません。
TCP ストリームやファイルシステムを扱う場合は、オクテットストリームを処理する必要があります。
Node にはオクテットストリームを操作、作成、消費するためにいくつかの戦略があります。</p>
<!--
<p>Pure Javascript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it's necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.</p>
-->

<p>生のデータは <code>Buffer</code> クラスのインスタンスに保存されます。
<code>Buffer</code> は整数の配列と似ていますが、
V8 ヒープの外部に割り当てられた生のメモリに対応します。
<code>Buffer</code> のサイズを変更することはできません。</p>
<!--
<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.</p>
-->

<p><code>Buffer</code> オブジェクトはグローバルです。</p>
<!--
<p>The <code>Buffer</code> object is global.</p>
-->

<p>バッファを JavaScript 文字列オブジェクトとの間で変換するにはエンコーディング方式を明示する必要があります。
いくつかのエンコーディング方式があります。</p>
<!--
<p>Converting between Buffers and JavaScript string objects requires an explicit encoding
method.  Here are the different string encodings;</p>
-->

<ul>
<li><p><code>'ascii'</code> - 7bit の ASCII データ専用です。
  このエンコーディング方式はとても高速で、もし上位ビットがセットされていれば取り除かれます。</p></li>
<li><p><code>'utf8'</code> - Unicode文字。
  多くのWebページやその他のドキュメントは UTF-8 を使っています。</p></li>
<li><p><code>'base64'</code> - Base64 文字列エンコーディング.</p></li>
<li><p><code>'binary'</code> - 生のバイナリデータを各文字の最初の 8bit として使用するエンコーディング方式。
このエンコーディング方式はもはや価値がなく、<code>Buffer</code> オブジェクトでは可能な限り使用すべきではありません。
このエンコーディングは、Node の将来のバージョンで削除される予定です。</p></li></ul>
<!--
<ul><li><p><code>'ascii'</code> - for 7 bit ASCII data only.  This encoding method is very fast, and will
strip the high bit if set.</p></li><li><p><code>'utf8'</code> - Unicode characters.  Many web pages and other document formats use UTF-8.</p></li><li><p><code>'base64'</code> - Base64 string encoding.</p></li><li><p><code>'binary'</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is depreciated and
should be avoided in favor of <code>Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p></li></ul>
-->

<h3>new Buffer(size)</h3>

<p><code>size</code> オクテットの新しいバッファを割り当てます。</p>
<!--
<p>Allocates a new buffer of <code>size</code> octets.</p>
-->

<h3>new Buffer(array)</h3>

<p>オクテットの <code>array</code> を使用する新しいバッファを割り当てます。</p>
<!--
<p>Allocates a new buffer using an <code>array</code> of octets.</p>
-->

<h3>new Buffer(str, encoding='utf8')</h3>

<p>与えられた <code>str</code> を内容とする新しいバッファを割り当てます。</p>
<!--
<p>Allocates a new buffer containing the given <code>str</code>.</p>
-->

<h3>buffer.write(string, offset=0, encoding='utf8')</h3>

<p>与えられたエンコーディングを使用して，<code>string</code> をバッファの <code>offset</code> から書き込みます。
書き込まれたオクテット数を返します。
もし <code>buffer</code> が文字列全体を挿入するのに十分なスペースを含んでいなければ、文字列の一部だけを書き込みます。
<code>'utf8'</code> エンコーディングの場合、このメソッドは文字の一部だけを書き込むことはありません。</p>
<!--
<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding. Returns
number of octets written.  If <code>buffer</code> did not contain enough space to fit
the entire string it will write a partial amount of the string. In the case
of <code>'utf8'</code> encoding, the method will not write partial characters.</p>
-->

<p>例: utf8 の文字列をバッファに書き込み、それをプリントします</p>
<!--
<p>Example: write a utf8 string into a buffer, then print it</p>
-->

<pre><code>buf = new Buffer(256);
len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(len + " bytes: " + buf.toString('utf8', 0, len));

// 12 bytes: ? + ? = ?</code></pre>

<h3>buffer.toString(encoding, start=0, end=buffer.length)</h3>

<p><code>encoding</code> でエンコードされたバッファデータの <code>start</code> から
<code>end</code> までをデコードした文字列を返します。</p>
<!--
<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>
beginning at <code>start</code> and ending at <code>end</code>.</p>
-->

<p>上の <code>buffer.write()</code> の例を参照してください。</p>
<!--
<p>See <code>buffer.write()</code> example, above.</p>
-->

<h3>buffer[index]</h3>

<p><code>index</code> の位置のオクテットを取得および設定します。
その値は個々のバイトを参照するので、妥当な範囲は 16 進の <code>0x00</code> から <code>0xFF</code>
または <code>0</code> から<code>255</code>までの間です。</p>
<!--
<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>
-->

<p>例: ASCII 文字列を 1 バイトずつバッファにコピーします</p>
<!--
<p>Example: copy an ASCII string into a buffer, one byte at a time:</p>
-->

<pre><code>str = "node.js";
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>

<h3>Buffer.byteLength(string, encoding='utf8')</h3>

<p>文字列の実際のバイト数を返します。これは文字列の<em>文字</em>数を返す
<code>String.prototype.length</code> と同じではありません。</p>
<!--
<p>Gives the actual byte length of a string.  This is not the same as 
<code>String.prototype.length</code> since that returns the number of <em>characters</em> in a
string.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>str = '\u00bd + \u00bc = \u00be';

console.log(str + ": " + str.length + " characters, " +
  Buffer.byteLength(str, 'utf8') + " bytes");

// ? + ? = ?: 9 characters, 12 bytes</code></pre>

<h3>buffer.length</h3>

<p>バイト数によるバッファのサイズ。これは実際の内容のサイズではないことに注意してください。
<code>length</code> はバッファオブジェクトに割り当てられたメモリ全体を参照します。</p>
<!--
<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the 
buffer object.  It does not change when the contents of the buffer are changed.</p>
-->

<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write("some string", "ascii", 0);
console.log(buf.length);

// 1234
// 1234</code></pre>

<h3>buffer.copy(targetBuffer, targetStart, sourceStart, sourceEnd=buffer.length)</h3>

<p>バッファ間で memcpy() をします。</p>
<!--
<p>Does a memcpy() between buffers.</p>
-->

<p>例: バッファを2個作成し、<code>buf1</code> の 16 バイト目から 19 バイト目を、
<code>buf2</code> の 8 バイト目から始まる位置へコピーします。</p>
<!--
<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>
-->

<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>

<h3>buffer.slice(start, end)</h3>

<p>元のバッファと同じメモリを参照しますが、<code>start</code> と <code>end</code>
で示されるオフセットで始まり短くされた新しいバッファを返します。</p>
<!--
<p>Returns a new buffer which references the
same memory as the old, but offset and cropped by the <code>start</code> and <code>end</code>
indexes.</p>
-->

<p><strong>新しいバッファスライスの変更は、オリジナルバッファのメモリを変更することになります！</strong></p>
<!--
<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong></p>
-->

<p>例: ASCII のアルファベットでバッファを構築してスライスし、元のバッファで 1 バイトを変更します。</p>
<!--
<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one byte
from the original Buffer.</p>
-->

<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString('ascii', 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString('ascii', 0, buf2.length));

// abc
// !bc</code></pre>

<h2 id="EventEmitter">イベント生成</h2>

<p>Node のオブジェクトの多くはイベントを生成します: TCP サーバはストリームがあるとそのたびにイベントを生成します。
子プロセスは終了する際にイベントを生成します。
イベントを生成する全てのオブジェクトは <code>events.EventEmitter</code> のインスタンスです。</p>
<!--
<p>Many objects in Node emit events: a TCP server emits an event each time
there is a stream, a child process emits an event when it exits. All
objects which emit events are instances of <code>events.EventEmitter</code>.</p>
-->

<p>イベントはキャメル記法による文字列で表現されます。
いくつかの例: <code>'stream'</code>、<code>'data'</code>、<code>'messageBegin'</code></p>
<!--
<p>Events are represented by a camel-cased string. Here are some examples:
<code>'stream'</code>, <code>'data'</code>, <code>'messageBegin'</code>.</p>
-->

<p>関数をオブジェクトにアタッチすることができ、それはイベントが生成された時に実行されます。
これらの関数は<em>リスナー</em>と呼ばれます。</p>
<!--
<p>Functions can be then be attached to objects, to be executed when an event
is emitted. These functions are called <em>listeners</em>.</p>
-->

<p><code>require('events').EventEmitter</code> で <code>EventEmitter</code> クラスにアクセスします。</p>
<!--
<p><code>require('events').EventEmitter</code> to access the <code>EventEmitter</code> class.</p>
-->

<p>全ての EventEmitter は、新しいリスナーが加えられるとイベント <code>'newListener'</code> を生成します。</p>
<!--
<p>All EventEmitters emit the event <code>'newListener'</code> when new listeners are
added.</p>
-->

<p><code>EventEmitter</code> がエラーに遭遇した時、典型的な動作は <code>'error'</code> イベントを生成することです。
エラーイベントは特別です － もしそのハンドラがなければ、スタックトレースが出力されてプログラムは終了します。</p>
<!--
<p>When an <code>EventEmitter</code> experiences an error, the typical action is to emit an
<code>'error'</code> event.  Error events are special--if there is no handler for them
they will print a stack trace and exit the program.</p>
-->

<h3>イベント: 'newListener'</h3>
<!--
<h3>Event: 'newListener'</h3>
-->

<p><code>function (event, listener) { }</code></p>

<p>このイベントは誰かが新しいリスナーを追加するといつでも生成されます。</p>
<!--
<p>This event is emitted any time someone adds a new listener.</p>
-->

<h3>イベント: 'error'</h3>
<!--
<h3>Event: 'error'</h3>
-->

<p><code>function (exception) { }</code></p>

<p>エラーに遭遇すると、このイベントが生成されます。
このイベントは特別です － エラーを受け取るリスナーが存在しない場合、
Node は実行を終了して例外のスタックトレースを表示します。</p>
<!--
<p>If an error was encountered, then this event is emitted. This event is
special - when there are no listeners to receive the error Node will
terminate execution and display the exception's stack trace.</p>
-->

<h3>emitter.on(event, listener)</h3>

<p>指定されたイベントに対するリスナー配列の最後にリスナーを追加します。</p>
<!--
<p>Adds a listener to the end of the listeners array for the specified event.</p>
-->

<pre><code>server.on('stream', function (stream) {
  console.log('someone connected!');
});</code></pre>

<h3>emitter.removeListener(event, listener)</h3>

<p>指定されたイベントに対するリスナー配列からリスナーを削除します。</p>
<!--
<p>Remove a listener from the listener array for the specified event.
<strong>Caution</strong>: changes array indices in the listener array behind the listener.</p>
-->

<pre><code>var callback = function(stream) {
  console.log('someone connected!');
};
server.on('stream', callback);
// ...
server.removeListener('stream', callback);</code></pre>

<h3>emitter.removeAllListeners(event)</h3>

<p>指定されたイベントに対するリスナー配列から全てのリスナーを削除します。</p>
<!--
<p>Removes all listeners from the listener array for the specified event.</p>
-->

<h3>emitter.listeners(event)</h3>

<p>指定されたイベントに対するリスナー配列を返します。
この配列は変更することができます、例えばリスナーを削除するなど。</p>
<!--
<p>Returns an array of listeners for the specified event. This array can be
manipulated, e.g. to remove listeners.</p>
-->

<pre><code>server.on('stream', function (stream) {
  console.log('someone connected!');
});
console.log(sys.inspect(server.listeners('stream'));
// [ [Function] ]</code></pre>

<h3>emitter.emit(event, [arg1], [arg2], [...])</h3>

<p>それぞれのリスナーを引数で渡された順に実行します。</p>
<!--
<p>Execute each of the listeners in order with the supplied arguments.</p>
-->

<h2 id="Streams">ストリーム</h2>
<!--
<h2 id="Streams">Streams</h2>
-->

<p>ストリームは Node の様々なオブジェクトで実装される抽象的なインタフェースです。
例えば HTTP サーバへのリクエストは標準出力と同様にストリームです。
ストリームは読み込み可能、書き込み可能、またはその両方です。
全てのストリームは <code>EventEmitter</code> のインスタンスです。
</p>
<!--
<p>A stream is an abstract interface implemented by various objects in Node.
For example a request to an HTTP server is a stream, as is stdout. Streams
are readable, writable, or both. All streams are instances of <code>EventEmitter</code>.</p>
-->

<h2 id="Readable Stream">読み込み可能なストリーム</h2>
<!--
<h2 id="Readable Stream">Readable Stream</h2>
-->

<p><code>Readable Stream</code> には以下のメソッド、メンバー、そしてイベントがあります。</p>
<!--
<p>A <code>Readable Stream</code> has the following methods, members, and events.</p>
-->

<h3>イベント: 'data'</h3>
<!--
<h3>Event: 'data'</h3>
-->

<p><code>function (data) { }</code></p>

<p><code>'data'</code> イベントは <code>Buffer</code> (デフォルト) または、
<code>setEncoding()</code> された場合は文字列のどちらかを生成します</p>
<!--
<p>The <code>'data'</code> event emits either a <code>Buffer</code> (by default) or a string if
<code>setEncoding()</code> was used.</p>
-->

<h3>イベント: 'end'</h3>
<!--
<h3>Event: 'end'</h3>
-->

<p><code>function () { }</code></p>

<p>ストリームが EOF (TCP 用語では FIN) を受信した時に生成されます。
<code>'data'</code> イベントがもう発生しないことを示します。
ストリームがもし書き込み可能でもあるなら、書き込みを続けることは可能かもしれません。</p>
<!--
<p>Emitted when the stream has received an EOF (FIN in TCP terminology).
Indicates that no more <code>'data'</code> events will happen. If the stream is also
writable, it may be possible to continue writing.</p>
-->

<h3>イベント: 'error'</h3>
<!--
<h3>Event: 'error'</h3>
-->

<p><code>function (exception) { }</code></p>

<p>データ受信でエラーがあると生成されます。</p>
<!--
<p>Emitted if there was an error receiving data.</p>
-->

<h3>イベント: 'close'</h3>
<!--
<h3>Event: 'close'</h3>
-->

<p><code>function () { }</code></p>

<p>背後でファイル記述子がクローズされた時に生成されます。
全てのストリームがこのイベントを発生するわけではありません。
(例えば、インカミングの HTTP リクエストは <code>'close'</code> イベントを生成しません。)</p>
<!--
<p>Emitted when the underlying file descriptor has be closed. Not all streams
will emit this.  (For example, an incoming HTTP request will not emit
<code>'close'</code>.)</p>
-->

<h3>イベント: 'fd'</h3>
<!--
<h3>Event: 'fd'</h3>
-->

<p><code>function (fd) { }</code></p>

<p>ストリームに関するファイル記述子を受け取った時に生成されます。
UNIX ストリームだけがこの機能をサポートしています;
その他の全てのストリームはこのイベントを生成しません。</p>
<!--
<p>Emitted when a file descriptor is received on the stream. Only UNIX streams
support this functionality; all others will simply never emit this event.</p>
-->

<h3>stream.readable</h3>

<p>デフォルトでは <code>true</code> ですが、<code>'error'</code> が発生した後、
ストリームが <code>'end'</code> に達した後、または <code>destroy()</code> が呼ばれた後で、
<code>false</code> に設定される boolean です。</p>
<!--
<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>
occured, the stream came to an <code>'end'</code>, or <code>destroy()</code> was called.</p>
-->

<h3>stream.setEncoding(encoding)</h3>

<p>data イベントが <code>Buffer</code> ではなく文字列を生成するようにします。
<code>encoding</code> には <code>'utf8'</code>、<code>'ascii'</code>、
または <code>'base64'</code> を指定することができます。</p>
<!--
<p>Makes the data event emit a string instead of a <code>Buffer</code>. <code>encoding</code> can be
<code>'utf8'</code>, <code>'ascii'</code>, or <code>'base64'</code>.</p>
-->

<h3>stream.pause()</h3>

<p><code>'data'</code> イベントの到着を中断します。</p>
<!--
<p>Pauses the incoming <code>'data'</code> events.</p>
-->

<h3>stream.resume()</h3>

<p><code>pause()</code> の後で <code>'data'</code> イベントの到着を再開します。</p>
<!--
<p>Resumes the incoming <code>'data'</code> events after a <code>pause()</code>.</p>
-->

<h3>stream.destroy()</h3>

<p>背後のファイル記述子をクローズします。ストリームはそれ以上イベントを生成しなくなります。</p>
<!--
<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>
-->

<h2 id="Writable Stream">書き込み可能なストリーム</h2>
<!--
<h2 id="Writable Stream">Writable Stream</h2>
-->

<p><code>Writable Stream</code> には以下のメソッド、メンバー、そしてイベントがあります。</p>
<!--
<p>A <code>Writable Stream</code> has the following methods, members, and events.</p>
-->

<h3>イベント: 'drain'</h3>
<!--
<h3>Event: 'drain'</h3>
-->

<p><code>function () { }</code></p>

<p>呼び出された <code>write()</code> メソッドが <code>false</code> で戻った後に生成され、
再び安全に書き込むことができるようになったことを示します。</p>
<!--
<p>Emitted after a <code>write()</code> method was called that returned <code>false</code> to
indicate that it is safe to write again.</p>
-->

<h3>イベント: 'error'</h3>
<!--
<h3>Event: 'error'</h3>
-->

<p><code>function (exception) { }</code></p>

<p><code>exception</code>例外によるエラーについて生成されます。</p>
<!--
<p>Emitted on error with the exception <code>exception</code>.</p>
-->

<h3>イベント: 'close'</h3>
<!--
<h3>Event: 'close'</h3>
-->

<p><code>function () { }</code></p>

<p>背後でファイル記述子がクローズされた時に生成されます。</p>
<!--
<p>Emitted when the underlying file descriptor has been closed.</p>
-->

<h3>stream.writeable</h3>

<p>デフォルトでは <code>true</code> ですが、<code>'error'</code> が発生した後、
<code>end()</code> / <code>destroy()</code> が呼ばれた後で <code>false</code> に設定される boolean です。</p>
<!--
<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>
occurred or <code>end()</code> / <code>destroy()</code> was called.</p>
-->

<h3>stream.write(string, encoding='utf8', [fd])</h3>

<p>与えられた <code>encoding</code> で <code>string</code> を書き込みます。
文字列がカーネルバッファにフラッシュされた場合は <code>true</code> が返ります。
カーネルバッファがいっぱいの場合は、データが将来カーネルバッファに送られることを示すために、
<code>false</code> が返ります。
<code>'drain'</code> イベントがカーネルバッファが再び空いたことを示します。
<code>encoding</code> のデフォルトは <code>'utf8'</code> です。</p>
<!--
<p>Writes <code>string</code> with the given <code>encoding</code> to the stream.  Returns <code>true</code> if
the string has been flushed to the kernel buffer.  Returns <code>false</code> to
indicate that the kernel buffer is full, and the data will be sent out in
the future. The <code>'drain'</code> event will indicate when the kernel buffer is
empty again. The <code>encoding</code> defaults to <code>'utf8'</code>.</p>
-->

<p>オプションの <code>fd</code> 引数が指定されると、
ストリームに送信するための基礎となるファイル記述子として解釈されます。
これは UNIX ストリームでのみサポートされており、その他では黙って無視されます。
このようにファイル記述子に書き込む場合、ストリームが流れきる前にファイル記述子をクローズすると、
データが不正な (クローズされた) ファイル記述子に送られるリスクがあります。</p>
<!--
<p>If the optional <code>fd</code> parameter is specified, it is interpreted as an integral
file descriptor to be sent over the stream. This is only supported for UNIX
streams, and is silently ignored otherwise. When writing a file descriptor in
this manner, closing the descriptor before the stream drains risks sending an
invalid (closed) FD.</p>
-->

<h3>stream.write(buffer)</h3>

<p>生のバッファを使うこと以外は上記と同じです。</p>
<!--
<p>Same as the above except with a raw buffer.</p>
-->

<h3>stream.end()</h3>

<p>ストリームを EOF または FIN で終了します。</p>
<!--
<p>Terminates the stream with EOF or FIN.</p>
-->

<h3>stream.end(string, encoding)</h3>

<p>与えられた <code>encoding</code> で <code>string</code> を送信してからEOFまたはFINでストリームを終了します。
これは送信するパケットの数を減らすために便利です。</p>
<!--
<p>Sends <code>string</code> with the given <code>encoding</code> and terminates the stream with EOF
or FIN. This is useful to reduce the number of packets sent.</p>
-->

<h3>stream.end(buffer)</h3>

<p><code>buffer</code> であること以外は上記と同じです。</p>
<!--
<p>Same as above but with a <code>buffer</code>.</p>
-->

<h3>stream.destroy()</h3>

<p>背後のファイル記述子をクローズします。ストリームはそれ以上イベントを生成しなくなります。</p>
<!--
<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>
-->

<h2 id="Global Objects">グローバルオブジェクト</h2>
<!--
<h2 id="Global Objects">Global Objects</h2>
-->

<p>これらのオブジェクトはグローバルなスコープで有効であり、どこからでもアクセスすることができます。</p>
<!--
<p>These object are available in the global scope and can be accessed from anywhere.</p>
-->

<h3>global</h3>

<p>グローバルなネームスペースのオブジェクトです。</p>
<!--
<p>The global namespace object.</p>
-->

<h3>process</h3>

<p>プロセスオブジェクトです。<code>'process object'</code> の節を参照してください。</p>
<!--
<p>The process object. See the <code>'process object'</code> section.</p>
-->

<h3>require()</h3>

<p>要求されたモジュールを指します。<code>'Modules'</code> の節を参照してください。</p>
<!--
<p>To require modules. See the <code>'Modules'</code> section.</p>
-->

<h3>require.paths</h3>

<p><code>require()</code> のためのサーチパスの配列です。
この配列はカスタムパスを追加するために変更することができます。</p>
<!--
<p>An array of search paths for <code>require()</code>.  This array can be modified to add custom paths.</p>
-->

<p>例: サーチリストの先頭に新しいパスを追加する</p>
<!--
<p>Example: add a new path to the beginning of the search list</p>
-->

<pre><code>require.paths.unshift('/usr/local/node');
console.log(require.paths);
// /usr/local/node,/Users/mjr/.node_libraries</code></pre>

<h3>__filename</h3>

<p>実行されているスクリプトのファイル名です。これは絶対パスであり、
必ずしもコマンドライン引数で渡されたファイル名と同じというわけではありません。</p>
<!--
<p>The filename of the script being executed.  This is the absolute path, and not necessarily
the same filename passed in as a command line argument.</p>
-->

<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する</p>
<!--
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>
-->

<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>

<h3>__dirname</h3>

<p>スクリプトが実行されているディレクトリ名です。</p>
<!--
<p>The dirname of the script being executed.</p>
-->

<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する</p>
<!--
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>
-->

<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>

<h3>module</h3>

<p>現在の (<code>process.Module</code> 型である) モジュールへの参照です。
特に <code>module.exports</code> は <code>exports</code> オブジェクトと同じです。
より詳しくは <code>src/process.js</code> を参照してください。</p>
<!--
<p>A reference to the current module (of type <code>process.Module</code>). In particular
<code>module.exports</code> is the same as the <code>exports</code> object. See <code>src/process.js</code>
for more information.</p>
-->

<h2 id="process">process</h2>

<p><code>process</code> はグローバルオブジェクトで、どこからでもアクセスすることができます。
それは <code>EventEmitter</code> のインスタンスです。</p>
<!--
<p>The <code>process</code> object is a global object and can be accessed from anywhere.
It is an instance of <code>EventEmitter</code>.</p>
-->

<h3>イベント: 'exit'</h3>
<!--
<h3>Event: 'exit'</h3>
-->

<p><code>function () {}</code></p>

<p>プロセスが終了しようとしている時に生成されます。
これは (ユニットテストのように) モジュールの状態を一定の時間でチェックするのに適したフックとなります。
メインのイベントループは 'exit' コールバックが終了するともはや動作しないので、
タイマーはスケジュールされないかもしれません。</p>
<!--
<p>Emitted when the process is about to exit.  This is a good hook to perform
constant time checks of the module's state (like for unit tests).  The main
event loop will no longer be run after the 'exit' callback finishes, so
timers may not be scheduled.</p>
-->

<p><code>exit</code> を監視する例:</p>
<!--
<p>Example of listening for <code>exit</code>:</p>
-->

<pre><code>process.on('exit', function () {
  process.nextTick(function () {
   console.log('This will not run');
  });
  console.log('About to exit.');
});</code></pre>

<h3>イベント: 'uncaughtException'</h3>
<!--
<h3>Event: 'uncaughtException'</h3>
-->

<p><code>function (err) { }</code></p>

<p>発生した例外がイベントループまでたどり着いた場合に生成されます。
もしこの例外に対するリスナーが加えられていれば、
デフォルトの動作 (それはスタックトレースをプリントして終了します) は起こりません。</p>
<!--
<p>Emitted when an exception bubbles all the way back to the event loop. If a
listener is added for this exception, the default action (which is to print
a stack trace and exit) will not occur.</p>
-->

<p><code>uncaughtException</code> を監視する例:</p>
<!--
<p>Example of listening for <code>uncaughtException</code>:</p>
-->

<pre><code>process.on('uncaughtException', function (err) {
  console.log('Caught exception: ' + err);
});

setTimeout(function () {
  console.log('This will still run.');
}, 500);

// Intentionally cause an exception, but don't catch it.
nonexistentFunc();
console.log('This will not run.');</code></pre>

<p><code>uncaughtException</code> は例外を扱うとても荒削りなメカニズムであることに注意してください。
プログラムの中で try / catch を使えばもっとプログラムの流れをうまく制御できるでしょう。
特にサーバプログラムはいつまでも実行し続けるように設計されるので、
<code>uncaughtException</code> は有益で安全なメカニズムになり得ます。</p>
<!--
<p>Note that <code>uncaughtException</code> is a very crude mechanism for exception
handling.  Using try / catch in your program will give you more control over
your program's flow.  Especially for server programs that are designed to
stay running forever, <code>uncaughtException</code> can be a useful safety mechanism.</p>
-->

<h3>シグナルイベント</h3>
<!--
<h3>Signal Events</h3>
-->

<p><code>function () {}</code></p>

<p>プロセスがシグナルを受信た場合に生成されます。
SIGINT、SIGUSR1、その他の POSIX 標準シグナル名の一覧について はsigaction(2) を参照してください。</p>
<!--
<p>Emitted when the processes receives a signal. See sigaction(2) for a list of
standard POSIX signal names such as SIGINT, SIGUSR1, etc.</p>
-->

<p><code>SIGINT</code>を監視する例:</p>
<!--
<p>Example of listening for <code>SIGINT</code>:</p>
-->

<pre><code>var stdin = process.openStdin();

process.on('SIGINT', function () {
  console.log('Got SIGINT.  Press Control-D to exit.');
});</code></pre>

<p>多くの端末プログラムで簡単に <code>SIGINT</code> を送る方法は <code>Control-C</code> を押すことです。</p>
<!--
<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal
programs.</p>
-->

<h3>process.stdout</h3>

<p><code>stdout</code> に対する <code>Writable Stream</code> です。</p>
<!--
<p>A <code>Writable Stream</code> to <code>stdout</code>.</p>
-->

<p>例: <code>console.log</code> の定義</p>
<!--
<p>Example: the definition of <code>console.log</code></p>
-->

<pre><code>console.log = function (d) {
  process.stdout.write(d + '\n');
};</code></pre>

<h3>process.openStdin()</h3>

<p>標準入力ストリームをオープンし、<code>Readable Stream</code> を返します。</p>
<!--
<p>Opens the standard input stream, returns a <code>Readable Stream</code>.</p>
-->

<p>標準入力をオープンして二つのイベントを監視する例:</p>
<!--
<p>Example of opening standard input and listening for both events:</p>
-->

<pre><code>var stdin = process.openStdin();

stdin.setEncoding('utf8');

stdin.on('data', function (chunk) {
  process.stdout.write('data: ' + chunk);
});

stdin.on('end', function () {
  process.stdout.write('end');
});</code></pre>

<h3>process.argv</h3>

<p>コマンドライン引数を含む配列です。
最初の要素は 'node'、2 番目の要素は JavaScript ファイルの名前になります。
その後の要素はコマンドラインの追加の引数になります。</p>
<!--
<p>An array containing the command line arguments.  The first element will be
'node', the second element will be the name of the JavaScript file.  The
next elements will be any additional command line arguments.</p>
-->

<pre><code>// print process.argv
process.argv.forEach(function (val, index, array) {
  console.log(index + ': ' + val);
});</code></pre>

<p>このように出力されます:</p>
<!--
<p>This will generate:</p>
-->

<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four</code></pre>

<h3>process.execPath</h3>

<p>プロセスによって開始された実行可能ファイルの絶対パスです。</p>
<!--
<p>This is the absolute pathname of the executable that started the process.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>/usr/local/bin/node</code></pre>

<h3>process.chdir(directory)</h3>

<p>プロセスのカレントワーキングディレクトリを変更します。
もし失敗した場合は例外をスローします。</p>
<!--
<p>Changes the current working directory of the process or throws an exception if that fails.</p>
-->

<pre><code>console.log('Starting directory: ' + process.cwd());
try {
  process.chdir('/tmp');
  console.log('New directory: ' + process.cwd());
}
catch (err) {
  console.log('chdir: ' + err);
}</code></pre>

<h3>process.compile(code, filename)</h3>

<p><code>eval</code> と似ていますが、よりよいエラー報告のために <code>filename</code> を指定することができ、
<code>code</code> はローカルスコープから不可視です。
<code>filename</code> の値は、もしコンパイルされたコードによってスタックトレースが生成されると、
ファイル名として使われます。</p>
<!--
<p>Similar to <code>eval</code> except that you can specify a <code>filename</code> for better
error reporting and the <code>code</code> cannot see the local scope.  The value of <code>filename</code>
will be used as a filename if a stack trace is generated by the compiled code.</p>
-->

<p><code>process.compile</code> と <code>eval</code> で同じコードを使った例:</p>
<!--
<p>Example of using <code>process.compile</code> and <code>eval</code> to run the same code:</p>
-->

<pre><code>var localVar = 123,
    compiled, evaled;

compiled = process.compile('localVar = 1;', 'myfile.js');
console.log('localVar: ' + localVar + ', compiled: ' + compiled);
evaled = eval('localVar = 1;');
console.log('localVar: ' + localVar + ', evaled: ' + evaled);

// localVar: 123, compiled: 1
// localVar: 1, evaled: 1</code></pre>

<p><code>process.compile</code> はローカルスコープにアクセスしないので、<code>localVar</code> は変更されません。
<code>eval</code> はローカルスコープにアクセスするので、<code>localVar</code> は変更されます。</p>
<!--
<p><code>process.compile</code> does not have access to the local scope, so <code>localVar</code> is unchanged.
<code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.</p>
-->

<p><code>code</code> が文法エラーとなるケースでは、<code>process.compile</code> は node を終了します。</p>
<!--
<p>In case of syntax error in <code>code</code>, <code>process.compile</code> exits node.</p>
-->

<p>関連項目: <code>Script</code></p>
<!--
<p>See also: <code>Script</code></p>
-->

<h3>process.cwd()</h3>

<p>プロセスのカレントワーキングディレクトリを返します。</p>
<!--
<p>Returns the current working directory of the process.</p>
-->

<pre><code>console.log('Current directory: ' + process.cwd());</code></pre>

<h3>process.env</h3>

<p>ユーザの環境を含むオブジェクトです。environ(7) を参照してください。</p>
<!--
<p>An object containing the user environment. See environ(7).</p>
-->

<h3>process.exit(code=0)</h3>

<p>指定の <code>code</code> でプロセスを終了します。
もし省略されると、「成功」を示すコード <code>0</code> を使って終了します。</p>
<!--
<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the 
'success' code <code>0</code>.</p>
-->

<p>「失敗」を示すコードで終了する例:</p>
<!--
<p>To exit with a 'failure' code:</p>
-->

<pre><code>process.exit(1);</code></pre>

<p>node を実行したシェルで終了コードが 1 であることを見ることができるでしょう。</p>
<!--
<p>The shell that executed node should see the exit code as 1.</p>
-->

<h3>process.getgid()</h3>

<p>プロセスのグループ識別子を取得します (getgid(2) 参照)。
これは数値によるグループ ID で、グループ名ではありません。</p>
<!--
<p>Gets the group identity of the process. (See getgid(2).)  This is the numerical group id, not the group name.</p>
-->

<pre><code>console.log('Current gid: ' + process.getgid());</code></pre>

<h3>process.setgid(id)</h3>

<p>プロセスのグループ識別子を設定します (setgid(2) 参照)。
これは数値による ID もグループ名の文字列のどちらも受け入れます。
もしグループ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。</p>
<!--
<p>Sets the group identity of the process. (See setgid(2).)  This accepts either a numerical ID or a groupname string.  If a groupname is specified, this method blocks while resolving it to a numerical ID.</p>
-->

<pre><code>console.log('Current gid: ' + process.getgid());
try {
  process.setgid(501);
  console.log('New gid: ' + process.getgid());
}
catch (err) {
  console.log('Failed to set gid: ' + err);
}</code></pre>

<h3>process.getuid()</h3>

<p>プロセスのユーザ識別子を取得します (getuid(2) 参照)。
これは数値によるユーザ ID で、ユーザ名ではありません。</p>
<!--
<p>Gets the user identity of the process. (See getuid(2).)  This is the numerical userid, not the username.</p>
-->

<pre><code>console.log('Current uid: ' + process.getuid());</code></pre>

<h3>process.setuid(id)</h3>

<p>プロセスのユーザ識別子を設定します (setuid(2) 参照)。
これは数値による ID もユーザ名の文字列のどちらも受け入れます。
もしユーザ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。</p>
<!--
<p>Sets the user identity of the process. (See setuid(2).)  This accepts either a numerical ID or a username string.  If a username is specified, this method blocks while resolving it to a numerical ID.</p>
-->

<pre><code>console.log('Current uid: ' + process.getuid());
try {
  process.setuid(501);
  console.log('New uid: ' + process.getuid());
}
catch (err) {
  console.log('Failed to set uid: ' + err);
}</code></pre>

<h3>process.version</h3>

<p><code>NODE_VERSION</code> を提示するコンパイル済みプロパティです。</p>
<!--
<p>A compiled-in property that exposes <code>NODE_VERSION</code>.</p>
-->

<pre><code>console.log('Version: ' + process.version);</code></pre>

<h3>process.installPrefix</h3>

<p><code>NODE_PREFIX</code> を提示するコンパイル済みプロパティです。</p>
<!--
<p>A compiled-in property that exposes <code>NODE_PREFIX</code>.</p>
-->

<pre><code>console.log('Prefix: ' + process.installPrefix);</code></pre>

<h3>process.kill(pid, signal='SIGINT')</h3>

<p>プロセスにシグナルを送ります。
<code>pid</code> はプロセス ID で <code>signal</code> は送信されるシグナルを文字列で記述したものです。
シグナルの名前は 'SIGINT' や 'SIGUSR1' のような文字列です。
省略すると、シグナルは 'SIGINT' となります。
詳細は kill(2) を参照してください。</p>
<!--
<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the
string describing the signal to send.  Signal names are strings like
'SIGINT' or 'SIGUSR1'.  If omitted, the signal will be 'SIGINT'.
See kill(2) for more information.</p>
-->

<p>この関数の名前が <code>process.kill</code> であるとおり、
これは <code>kill</code> システムコールのように本当にシグナルを送信することに注意してください。
対象のプロセスを殺すだけでなく、他のシグナルも送信されます。</p>
<!--
<p>Note that just because the name of this function is <code>process.kill</code>, it is
really just a signal sender, like the <code>kill</code> system call.  The signal sent
may do something other than kill the target process.</p>
-->

<p>自身にシグナルを送信する例:</p>
<!--
<p>Example of sending a signal to yourself:</p>
-->

<pre><code>process.on('SIGHUP', function () {
  console.log('Got SIGHUP signal.');
});

setTimeout(function () {
  console.log('Exiting.');
  process.exit(0);
}, 100);

process.kill(process.pid, 'SIGHUP');</code></pre>

<h3>process.pid</h3>

<p>プロセスの PID です。</p>
<!--
<p>The PID of the process.</p>
-->

<pre><code>console.log('This process is pid ' + process.pid);</code></pre>

<h3>process.title</h3>

<p>'ps' でどのよう表示されるかを設定するための getter/setter です。</p>
<!--
<p>Getter/setter to set what is displayed in 'ps'.</p>
-->

<h3>process.platform</h3>

<p>どのプラットフォームで動いているかです。<code>'linux2'</code>、<code>'darwin'</code>、など。</p>
<!--
<p>What platform you're running on. <code>'linux2'</code>, <code>'darwin'</code>, etc.</p>
-->

<pre><code>console.log('This platform is ' + process.platform);</code></pre>

<h3>process.memoryUsage()</h3>

<p>Node プロセスのメモリ使用状況を記述したオブジェクトを返します。<p>
<!--
<p>Returns an object describing the memory usage of the Node process.</p>
-->

<pre><code>var sys = require('sys');

console.log(sys.inspect(process.memoryUsage()));</code></pre>

<p>このように生成されます:</p>
<!--
<p>This will generate:</p>
-->

<pre><code>{ rss: 4935680
, vsize: 41893888
, heapTotal: 1826816
, heapUsed: 650472
}</code></pre>

<p><code>heapTotal</code> と <code>heapUsed</code> は V8 のメモリ使用状況を参照します。</p>
<!--
<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8's memory usage.</p>
-->

<h3>process.nextTick(callback)</h3>

<p>イベントループの次以降のループでコールバックを呼び出します。
これは <code>setTimeout(fn, 0)</code> の単純なエイリアス<em>ではなく</em>、
はるかに効率的です。</p>
<!--
<p>On the next loop around the event loop call this callback.
This is <em>not</em> a simple alias to <code>setTimeout(fn, 0)</code>, it's much more
efficient.</p>
-->

<pre><code>process.nextTick(function () {
  console.log('nextTick callback');
});</code></pre>

<h3>process.umask([mask])</h3>

<p>プロセスのファイルモード作成マスクを設定または読み込みます。
子プロセスは親プロセスからマスクを継承します。
<code>mask</code> 引数が与えられると元のマスクが返され、そうでなければ現在のマスクが返されます。</p>
<!--
<p>Sets or reads the process's file mode creation mask. Child processes inherit
the mask from the parent process. Returns the old mask if <code>mask</code> argument is
given, otherwise returns the current mask.</p>
-->

<pre><code>var oldmask, newmask = 0644;

oldmask = process.umask(newmask);
console.log('Changed umask from: ' + oldmask.toString(8) +
            ' to ' + newmask.toString(8));</code></pre>

<h2 id="sys">sys</h2>

<p>これらの関数はモジュール <code>'sys'</code> 内にあります。
<code>require('sys')</code> を使うことでこれらにアクセスします。</p>
<!--
<p>These functions are in the module <code>'sys'</code>. Use <code>require('sys')</code> to access
them.</p>
-->

<h3>sys.print(string)</h3>

<p><code>console.log()</code> と似ていますが、後に改行を続けません。</p>
<!--
<p>Like <code>console.log()</code> but without the trailing newline.</p>
-->

<pre><code>require('sys').print('String with no newline');</code></pre>

<h3>sys.debug(string)</h3>

<p>同期的な出力関数です。プロセスをブロックして即座に <code>string</code> を <code>stderr</code> に出力します。</p>
<!--
<p>A synchronous output function. Will block the process and
output <code>string</code> immediately to <code>stderr</code>.</p>
-->

<pre><code>require('sys').debug('message on stderr');</code></pre>

<h3>sys.log(string)</h3>

<p>タイムスタンプとともに <code>stdout</code> へ出力します。</p>
<!--
<p>Output with timestamp on <code>stdout</code>.</p>
-->

<pre><code>require('sys').log('Timestmaped message.');</code></pre>

<h3>sys.inspect(object, showHidden=false, depth=2)</h3>

<p>デバッグで有用な、<code>object</code> の文字列表現を返します。</p>
<!--
<p>Return a string representation of <code>object</code>, which is useful for debugging.</p>
-->

<p><code>showHidden</code> が <code>true</code> の場合、
オブジェクトの Enumerable でないプロパティも表示されます。</p>
<!--
<p>If <code>showHidden</code> is <code>true</code>, then the object's non-enumerable properties will be
shown too.</p>
-->

<p><code>depth</code> が与えられた場合、
オブジェクトをフォーマットするために何回再帰するかを <code>inspect</code> に伝えます。
これは巨大で複雑なオブジェクトを調査する場合に便利です。</p>
<!--
<p>If <code>depth</code> is provided, it tells <code>inspect</code> how many times to recurse while
formatting the object. This is useful for inspecting large complicated objects.</p>
-->

<p>デフォルトでは 2 回だけ再帰します。
無限に再帰するには、<code>depth</code> に <code>null</code> を渡します。</p>
<!--
<p>The default is to only recurse twice.  To make it recurse indefinitely, pass
in <code>null</code> for <code>depth</code>.</p>
-->

<p><code>sys</code> オブジェクトの全てのプロパティを調査する例:</p>
<!--
<p>Example of inspecting all properties of the <code>sys</code> object:</p>
-->

<pre><code>var sys = require('sys');

console.log(sys.inspect(sys, true, null));</code></pre>

<h3>sys.pump(readableStream, writeableStream, [callback])</h3>

<p>実験的</p>
<!--
<p>Experimental</p>
-->

<p><code>readableStream</code> からデータを読み、それ を<code>writableStream</code> に送ります。
<code>writeableStream.write(data)</code> が <code>false</code> を返す場合、
<code>writableStream</code> が <code>drain</code> イベントを生成するまで、
<code>readableStream</code> は中断します。
<code>writableStream</code> がクローズされると <code>callback</code> が呼び出されます。
</p>
<!--
<p>Read the data from <code>readableStream</code> and send it to the <code>writableStream</code>.
When <code>writeableStream.write(data)</code> returns <code>false</code> <code>readableStream</code> will be
paused until the <code>drain</code> event occurs on the <code>writableStream</code>. <code>callback</code> is
called when <code>writableStream</code> is closed.</p>
-->

<h2 id="Timers">Timers</h2>

<h3>setTimeout(callback, delay, [arg], [...])</h3>

<p><code>delay</code> ミリ秒が経過した後で <code>callback</code> が実行されるようにスケジュールします。
<code>clearTimeout()</code> で使うことができる <code>timeoutId</code> を返します。
オプションとして、コールバックへの引数を渡すこともできます。</p>
<!--
<p>To schedule execution of <code>callback</code> after <code>delay</code> milliseconds. Returns a
<code>timeoutId</code> for possible use with <code>clearTimeout()</code>. Optionally, you can
also pass arguments to the callback.</p>
-->

<h3>clearTimeout(timeoutId)</h3>

<p>タイムアウトがトリガーされるのを止めます。</p>
<!--
<p>Prevents a timeout from triggering.</p>
-->

<h3>setInterval(callback, delay, [arg], [...])</h3>

<p><code>delay</code> ミリ秒が経過するごとに繰り返し <code>callback</code> が実行されるようにスケジュールします。
<code>clearInterval()</code> で使うことができる <code>intervalId</code> を返します。
オプションとして、コールバックへの引数を渡すこともできます。</p>
<!--
<p>To schedule the repeated execution of <code>callback</code> every <code>delay</code> milliseconds.
Returns a <code>intervalId</code> for possible use with <code>clearInterval()</code>. Optionally,
you can also pass arguments to the callback.</p>
-->

<h3>clearInterval(intervalId)</h3>

<p>インターバルがトリガーされるのを止めます。</p>
<!--
<p>Stops a interval from triggering.</p>
-->

<h2 id="Child Processes">子プロセス</h2>
<!--
<h2 id="Child Processes">Child Processes</h2>
-->

<p>Nodeは <code>ChildProcess</code> クラスを通じて 3 方向の <code>popen(3)</code> 機能を提供します。</p>
<!--
<p>Node provides a tri-directional <code>popen(3)</code> facility through the <code>ChildProcess</code>
class.</p>
-->

<p>それは完全にノンブロッキングな方法で子プロセスの <code>stdin</code>、<code>stdout</code>、
そして <code>stderr</code> を通じてデータを流すことを可能にします。</p>
<!--
<p>It is possible to stream data through the child's <code>stdin</code>, <code>stdout</code>, and
<code>stderr</code> in a fully non-blocking way.</p>
-->

<p>子プロセスの生成は <code>require('child_process').spawn()</code> を使います。</p>
<!--
<p>To create a child process use <code>require('child_process').spawn()</code>.</p>
-->

<p>子プロセスは常に 3 本のストリームと関連づけられています。
<code>child.stdin</code>、<code>child.stdout</code>、そして <code>child.stderr</code> です。
</p>
<!--
<p>Child processes always have three streams associated with them. <code>child.stdin</code>,
<code>child.stdout</code>, and <code>child.stderr</code>.</p>
-->

<p><code>ChildProcess</code> は <code>EventEmitter</code> です。</p>
<!--
<p><code>ChildProcess</code> is an <code>EventEmitter</code>.</p>
-->

<h3>イベント:  'exit'</h3>
<!--
<h3>Event:  'exit'</h3>
-->

<p><code>function (code, signal) {}</code></p>

<p>このイベントは子プロセスが終了した後で生成されます。
プロセスが普通に終了した場合、<code>code</code> はプロセスの終了コードです。
それ以外の場合は <code>null</code> です。
プロセスがシグナルを受け取って終了した場合、<code>signal</code> は文字列によるシグナルの名前です。
それ以外の場合は <code>null</code> です。</p>
<!--
<p>This event is emitted after the child process ends. If the process terminated
normally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If
the process terminated due to receipt of a signal, <code>signal</code> is the string name
of the signal, otherwise <code>null</code>.</p>
-->

<p>このイベントが生成された後は、<code>'output'</code> および <code>'error'</code> コールバックはもう呼ばれなくなります。</p>
<!--
<p>After this event is emitted, the <code>'output'</code> and <code>'error'</code> callbacks will no
longer be made.</p>
-->

<p><code>waitpid(2)</code> を参照してください。</p>
<!--
<p>See <code>waitpid(2)</code>.</p>
-->

<h3>child.stdin</h3>

<p>子プロセスの <code>stdin</code> を表現する <code>Writable Stream</code> です。
多くの場合、<code>end()</code> を通じてこのストリームを閉じると子プロセスが終了する原因となります。</p>
<!--
<p>A <code>Writable Stream</code> that represents the child process's <code>stdin</code>.
Closing this stream via <code>end()</code> often causes the child process to terminate.</p>
-->

<h3>child.stdout</h3>

<p>子プロセスの <code>stdout</code> を表現する <code>Readable Stream</code> です。</p>
<!--
<p>A <code>Readable Stream</code> that represents the child process's <code>stdout</code>.</p>
-->

<h3>child.stderr</h3>

<p>子プロセスの <code>stderr</code> を表現する <code>Readable Stream</code> です。</p>
<!--
<p>A <code>Readable Stream</code> that represents the child process's <code>stderr</code>.</p>
-->

<h3>child.pid</h3>

<p>子プロセスの PID です。</p>
<!--
<p>The PID of the child process.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

console.log('Spawned child pid: ' + grep.pid);
grep.stdin.end();</code></pre>

<h3>child_process.spawn(command, args=[], [options])</h3>

<p><code>args</code> をコマンドライン引数として、与えられた <code>command</code> で新しいプロセスを起動します。
<code>args</code> が省略された場合、空の配列がデフォルトです。</p>
<!--
<p>Launches a new process with the given <code>command</code>, with  command line arguments in <code>args</code>.
If omitted, <code>args</code> defaults to an empty Array.</p>
-->

<p>第 3 引数は追加のオプションを指定するために使われ、そのデフォルトは:</p>
<!--
<p>The third argument is used to specify additional options, which defaults to:</p>
-->

<pre><code>{ cwd: undefined
, env: process.env,
, customFds: [-1, -1, -1]
}</code></pre>

<p><code>cwd</code> で起動されたプロセスのワーキングディレクトリを指定することができます。
<code>env</code> は新しいプロセスに見える環境変数を指定するために使います。
<code>customFds</code> は新しいプロセスの [stdin, stout, stderr] を既存のストリームに接続することを可能にします;
<code>-1</code> は新しいストリームが作られなければならないことを意味します。</p>
<!--
<p><code>cwd</code> allows you to specify the working directory from which the process is spawned.
Use <code>env</code> to specify environment variables that will be visible to the new process.
With <code>customFds</code> it is possible to hook up the new process' [stdin, stout, stderr] to
existing streams; <code>-1</code> means that a new stream should be created.</p>
-->

<p><code>ls -lh /usr</code> を実行して <code>stdout</code>、<code>stderr</code>、および終了コードを取得する例:</p>
<!--
<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:</p>
-->

<pre><code>var sys   = require('sys'),
    spawn = require('child_process').spawn,
    ls    = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', function (data) {
  sys.print('stdout: ' + data);
});

ls.stderr.on('data', function (data) {
  sys.print('stderr: ' + data);
});

ls.on('exit', function (code) {
  console.log('child process exited with code ' + code);
});</code></pre>

<p>とても手の込んだ方法で実行する 'ps ax | grep ssh' の例:</p>
<!--
<p>Example: A very elaborate way to run 'ps ax | grep ssh'</p>
-->

<pre><code>var sys   = require('sys'),
    spawn = require('child_process').spawn,
    ps    = spawn('ps', ['ax']),
    grep  = spawn('grep', ['ssh']);

ps.stdout.on('data', function (data) {
  grep.stdin.write(data);
});

ps.stderr.on('data', function (data) {
  sys.print('ps stderr: ' + data);
});

ps.on('exit', function (code) {
  if (code !== 0) {
    console.log('ps process exited with code ' + code);
  }
  grep.stdin.end();
});

grep.stdout.on('data', function (data) {
  sys.print(data);
});

grep.stderr.on('data', function (data) {
  sys.print('grep stderr: ' + data);
});

grep.on('exit', function (code) {
  if (code !== 0) {
    console.log('grep process exited with code ' + code);
  }
});</code></pre>

<p>exec の失敗をチェックする例:</p>
<!--
<p>Example of checking for failed exec:</p>
-->

<pre><code>var spawn = require('child_process').spawn,
    child = spawn('bad_command');

child.stderr.on('data', function (data) {
  if (/^execvp\(\)/.test(data.asciiSlice(0,data.length))) {
    console.log('Failed to start child process.');
  }
});</code></pre>

<p>関連項目: <code>child_process.exec()</code></p>
<!--
<p>See also: <code>child_process.exec()</code></p>
-->

<h3>child_process.exec(command, [options], callback)</h3>

<p>コマンドを子プロセスとして実行し、その出力を蓄えて、その全てをコールバックに渡す高水準の方法です。</p>
<!--
<p>High-level way to execute a command as a child process, buffer the
output, and return it all in a callback.</p>
-->

<pre><code>var sys   = require('sys'),
    exec  = require('child_process').exec,
    child;

child = exec('cat *.js bad_file | wc -l', 
  function (error, stdout, stderr) {
    sys.print('stdout: ' + stdout);
    sys.print('stderr: ' + stderr);
    if (error !== null) {
      console.log('exec error: ' + error);
    }
});</code></pre>

<p>コールバックは引数 <code>(error, stdout, stderr)</code> を得ます。
成功すると、<code>error</code> は <code>null</code> になります。
エラーだと、<code>error</code> は <code>Error</code> のインスタンスとなり、
<code>err.code</code> は子プロセスの終了コード、
<code>err.signal</code> はプロセスを終了させたシグナルとなります。</p>
<!--
<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>
will be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>err.code</code>
will be the exit code of the child process, and <code>err.signal</code> will be set to the
signal that terminated the process.</p>
-->

<p>任意の第 2 引数でいくつかのオプションを指定することができます。
オプションのデフォルトは</p>
<!--
<p>There is a second optional argument to specify several options. The default options are</p>
-->

<pre><code>{ encoding: 'utf8'
, timeout: 0
, maxBuffer: 200*1024
, killSignal: 'SIGKILL'
, cwd: null
, env: null
}</code></pre>

<p>もし <code>timeout</code> が 0 より大きいと、
子プロセスは実行時間が <code>timeout</code> ミリ秒よりも長くなると kill されます。
子プロセスは <code>killSignal</code> で kill されます (デフォルト: <code>'SIGKILL'</code>)。
<code>maxBuffer</code> は標準出力と標準エラーの最大のデータ量を指定します － この値を超えると子プロセスは kill されます。</p>
<!--
<p>If <code>timeout</code> is greater than 0, then it will kill the child process
if it runs longer than <code>timeout</code> milliseconds. The child process is killed with
<code>killSignal</code> (default: <code>'SIGKILL'</code>). <code>maxBuffer</code> specifies the largest
amount of data allowed on stdout or stderr - if this value is exceeded then
the child process is killed.</p>
-->

<h3>child.kill(signal='SIGTERM')</h3>

<p>子プロセスにシグナルを送ります。
引数が与えられない場合、子プロセスには <code>'SIGTERM'</code> が送られます。
利用可能なシグナルの一覧は <code>signal(7)</code> を参照してください。</p>
<!--
<p>Send a signal to the child process. If no argument is given, the process will
be sent <code>'SIGTERM'</code>. See <code>signal(7)</code> for a list of available signals.</p>
-->

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

grep.on('exit', function (code, signal) {
  console.log('child process terminated due to receipt of signal '+signal);
});

// send SIGHUP to process
grep.kill('SIGHUP');</code></pre>

<p>この関数は <code>kill</code> と呼ばれるものの、
子プロセスに届けられるシグナルが実際には子プロセスを殺さないかもしれないことに注意してください。
<code>kill</code> はただプロセスにシグナルを送るだけです。</p>
<!--
<p>Note that while the function is called <code>kill</code>, the signal delivered to the child
process may not actually kill it.  <code>kill</code> really just sends a signal to a process.</p>
-->

<p><code>kill(2)</code> を参照してください。</p>
<!--
<p>See <code>kill(2)</code></p>
-->

<h2 id="Script">Script</h2>

<p><code>Script</code> は JavaScript コードをコンパイルおよび実行するクラスです。
このクラスには次のようにアクセスできます:</p>
<!--
<p><code>Script</code> class compiles and runs JavaScript code. You can access this class with:</p>
-->

<pre><code>var Script = process.binding('evals').Script;</code></pre>

<p>新しい JavaScript コードは、コンパイルされてすぐに実行されるか、コンパイルおよび保存されて後から実行されます。</p>
<!--
<p>New JavaScript code can be compiled and run immediately or compiled, saved, and run later.</p>
-->

<h3>Script.runInThisContext(code, [filename])</h3>

<p><code>process.compile</code> と同様です。
<code>Script.runInThisContext</code> は <code>code</code> を
<code>filename</code> からロードされたかのようにコンパイルし、
それを実行して結果を返します。実行されるコードはローカルスコープにアクセスしません。
<code>filename</code> はオプションです。</p>
<!--
<p>Similar to <code>process.compile</code>.  <code>Script.runInThisContext</code> compiles <code>code</code> as if it were loaded from <code>filename</code>,
runs it and returns the result. Running code does not have access to local scope. <code>filename</code> is optional.</p>
-->

<p><code>Script.runInThisContext</code> と <code>eval</code> で同じコードを実行する例:</p>
<!--
<p>Example of using <code>Script.runInThisContext</code> and <code>eval</code> to run the same code:</p>
-->

<pre><code>var localVar = 123,
    usingscript, evaled,
    Script = process.binding('evals').Script;

usingscript = Script.runInThisContext('localVar = 1;',
  'myfile.js');
console.log('localVar: ' + localVar + ', usingscript: ' +
  usingscript);
evaled = eval('localVar = 1;');
console.log('localVar: ' + localVar + ', evaled: ' +
  evaled);

// localVar: 123, usingscript: 1
// localVar: 1, evaled: 1</code></pre>

<p><code>Script.runInThisContext</code> はローカルスコープにアクセスしないので、
<code>localVar</code> は変更されません。
<code>eval</code> はローカルスコープにアクセスするので、
<code>localVar</code> は変更されます。</p>
<!--
<p><code>Script.runInThisContext</code> does not have access to the local scope, so <code>localVar</code> is unchanged.
<code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.</p>
-->

<p><code>code</code> が文法エラーとなるケースでは、
<code>Script.runInThisContext</code> は標準エラーに文法エラーを出力し、例外をスローします。</p>
<!--
<p>In case of syntax error in <code>code</code>, <code>Script.runInThisContext</code> emits the syntax error to stderr
and throws.an exception.</p>
-->

<h3>Script.runInNewContext(code, [sandbox], [filename])</h3>

<p><code>Script.runInNewContext</code> は <code>code</code> を
<code>filename</code> からロードされたかのようにコンパイルし、
それを <code>sandbox</code> の中で実行して結果を返します。
実行されるコードはローカルスコープにアクセスせず、
<code>sandbox</code> が <code>code</code> にとってのグローバルオブジェクトとして使われます。
<code>sandbox</code> および <code>filename</code> はオプションです。</p>
<!--
<p><code>Script.runInNewContext</code> compiles <code>code</code> to run in <code>sandbox</code> as if it were loaded from <code>filename</code>,
then runs it and returns the result. Running code does not have access to local scope and
the object <code>sandbox</code> will be used as the global object for <code>code</code>.
<code>sandbox</code> and <code>filename</code> are optional.</p>
-->

<p>例: グローバル変数をインクリメントして新しい値をセットするコードをコンパイルおよび実行します。</p>
<!--
<p>Example: compile and execute code that increments a global variable and sets a new one.
These globals are contained in the sandbox.</p>
-->

<pre><code>var sys = require('sys'),
    Script = process.binding('evals').Script,
    sandbox = {
      animal: 'cat',
      count: 2
    };

Script.runInNewContext(
  'count += 1; name = "kitty"', sandbox, 'myfile.js');
console.log(sys.inspect(sandbox));

// { animal: 'cat', count: 3, name: 'kitty' }</code></pre>

<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。
偶然グローバル変数が漏れてしまうことを防ぐために、<code>Script.runInNewContext</code> はとても役立ちますが、
信頼できないコードを安全に実行するために別のプロセスを要求します。</p>
<!--
<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>Script.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.</p>
-->

<p><code>code</code> が文法エラーとなるケースでは、
<code>Script.runInNewContext</code> は標準エラーに文法エラーを出力し、例外をスローします。</p>
<!--
<p>In case of syntax error in <code>code</code>, <code>Script.runInThisContext</code> emits the syntax error to stderr
and throws an exception.</p>
-->

<h3>new Script(code, [filename])</h3>

<p><code>new Script</code> は <code>code</code> を
<code>filename</code> からロードされたかのようにコンパイルしますが、実行はしません。
代わりに、コンパイルされたコードを表現する <code>Script</code> オブジェクトを返します。
このスクリプトは後述のメソッドを使って後から何度でも実行することができます。
返されるスクリプトはどのグローバルオブジェクトとも結びつけられていません。
それぞれの実行前に結びつけることで、そのとおりに実行されます。
<code>filename</code> はオプションです。</p>
<!--
<p><code>new Script</code> compiles <code>code</code> as if it were loaded from <code>filename</code>,
but does not run it. Instead, it returns a <code>Script</code> object representing this compiled code.
This script can be run later many times using methods below.
The returned script is not bound to any global object.
It is bound before each run, just for that run. <code>filename</code> is optional.</p>
-->

<p><code>code</code> が文法エラーとなるケースでは、
<code>new Script</code> は標準エラーに文法エラーを出力し、例外をスローします。</p>
<!--
<p>In case of syntax error in <code>code</code>, <code>new Script</code> emits the syntax error to stderr
and throws an exception.</p>
-->

<h3>script.runInThisContext()</h3>

<p><code>Script.runInThisContext</code> (大文字の'S'に注意) と同様ですが、
こちらはコンパイル済みのスクリプトオブジェクトのメソッドです。
<code>script.runInThisContext</code> は <code>script</code> のコードを実行してその結果を返します。
実行されるコードはローカルスコープにアクセスしませんが、
<code>global</code> オブジェクト (v8: 実際のコンテキスト) にはアクセスします。</p>
<!--
<p>Similar to <code>Script.runInThisContext</code> (note capital 'S'), but now being a method of a precompiled Script object.
<code>script.runInThisContext</code> runs the code of <code>script</code> and returns the result.
Running code does not have access to local scope, but does have access to the <code>global</code> object
(v8: in actual context).</p>
-->

<p><code>script.runInThisContext</code> を使ってコードを一度だけコンパイルし、複数回実行する例:</p>
<!--
<p>Example of using <code>script.runInThisContext</code> to compile code once and run it multiple times:</p>
-->

<pre><code>var Script = process.binding('evals').Script,
    scriptObj, i;

globalVar = 0;

scriptObj = new Script('globalVar += 1', 'myfile.js');

for (i = 0; i &lt; 1000 ; i += 1) {
  scriptObj.runInThisContext();
}

console.log(globalVar);

// 1000</code></pre>

<h3>script.runInNewContext([sandbox])</h3>

<p><code>Script.runInNewContext</code> (大文字の'S'に注意) と同様ですが、
こちらはコンパイル済みのスクリプトオブジェクトのメソッドです。
<code>script.runInNewContext</code> は <code>sandbox</code> がグローバルオブジェクトであるかのように
<code>script</code> のコードを実行してその結果を返します。
実行されるコードはローカルスコープにアクセスしません．
<code>sandbox</code> はオプションです。
<!--
<p>Similar to <code>Script.runInNewContext</code> (note capital 'S'), but now being a method of a precompiled Script object.
<code>script.runInNewContext</code> runs the code of <code>script</code> with <code>sandbox</code> as the global object and returns the result.
Running code does not have access to local scope. <code>sandbox</code> is optional.</p>
-->

<p>例: グローバル変数をインクリメントしてセットするコードをコンパイルして、このコードを複数回実行します。
これらのグローバル変数はサンドボックスに含まれます。</p>
<!--
<p>Example: compile code that increments a global variable and sets one, then execute this code multiple times.
These globals are contained in the sandbox.</p>
-->

<pre><code>var sys = require('sys'),
    Script = process.binding('evals').Script,
    scriptObj, i,
    sandbox = {
      animal: 'cat',
      count: 2
    };

scriptObj = new Script(
    'count += 1; name = "kitty"', 'myfile.js');

for (i = 0; i &lt; 10 ; i += 1) {
  scriptObj.runInNewContext(sandbox);
}

console.log(sys.inspect(sandbox));

// { animal: 'cat', count: 12, name: 'kitty' }</code></pre>

<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。
偶然グローバル変数が漏れてしまうことを防ぐために、<code>script.runInNewContext</code> はとても役立ちますが、
信頼できないコードを安全に実行するために別のプロセスを要求します。</p>
<!--
<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>script.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.</p>
-->

<h2 id="File System">ファイルシステム</h2>

<p>File I/O は POSIX 標準の関数に対する単純なラッパーとして提供されます。
このモジュールを使用するには <code>require('fs')</code> してください。
全てのメソッドは非同期と同期の形式があります。</p>
<!--
<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code>require('fs')</code>. All the methods have asynchronous and
synchronous forms. </p>
-->

<p>非同期の形式は常に最後の引数として完了コールバックを受け取ります。
引数として渡される完了コールバックはメソッドに依存しますが、
最初の引数は常に例外のために予約されています。
操作が成功で完了すると最初の引数は <code>null</code> または <code>undefined</code> となります</p>
<!--
<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.</p>
-->

<p>非同期バージョンの例です:</p>
<!--
<p>Here is an example of the asynchronous version:</p>
-->

<pre><code>var fs = require('fs');

fs.unlink('/tmp/hello', function (err) {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});</code></pre>

<p>同期バージョンです:</p>
<!--
<p>Here is the synchronous version:</p>
-->

<pre><code>var fs = require('fs');

fs.unlinkSync('/tmp/hello')
console.log('successfully deleted /tmp/hello');</code></pre>

<p>非同期メソッドでは順序の保証はありません。
以下のような傾向のエラーがあります。</p>
<!--
<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:</p>
-->

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  console.log('renamed complete');
});
fs.stat('/tmp/world', function (err, stats) {
  if (err) throw err;
  console.log('stats: ' + JSON.stringify(stats));
});</code></pre>

<p><code>fs.stat</code> は <code>fs.rename</code> より先に実行される可能性がありrます。
正しい方法はコールバックをチェーンすることです。</p>
<!--
<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.
The correct way to do this is to chain the callbacks.</p>
-->

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  fs.stat('/tmp/world', function (err, stats) {
    if (err) throw err;
    console.log('stats: ' + JSON.stringify(stats));
  });
});</code></pre>

<p>忙しいプロセスでは、プログラマはこれらの非同期バージョンを使うことが<em>強く推奨</em>されます。
同期バージョンはそれが完了するまでプロセス全体をブロックします － 全ての接続を停止します。</p>
<!--
<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.</p>
-->

<h3>fs.rename(path1, path2, [callback])</h3>

<p>非同期の rename(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous rename(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.renameSync(path1, path2)</h3>

<p>同期の rename(2)。</p>
<!--
<p>Synchronous rename(2).</p>
-->

<h3>fs.truncate(fd, len, [callback])</h3>

<p>非同期の ftruncate(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.truncateSync(fd, len)</h3>

<p>同期の ftruncate(2)。</p>
<!--
<p>Synchronous ftruncate(2).</p>
-->

<h3>fs.chmod(path, mode, [callback])</h3>

<p>非同期の chmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous chmod(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.chmodSync(path, mode)</h3>

<p>同期の chmod(2)。</p>
<!--
<p>Synchronous chmod(2).</p>
-->

<h3>fs.stat(path, [callback])</h3>

<p>非同期の stat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。</p>
<!--
<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where <code>stats</code> is a <code>fs.Stats</code> object. It looks like this:</p>
-->

<pre><code>{ dev: 2049
, ino: 305352
, mode: 16877
, nlink: 12
, uid: 1000
, gid: 1000
, rdev: 0
, size: 4096
, blksize: 4096
, blocks: 8
, atime: '2009-06-29T11:11:55Z'
, mtime: '2009-06-29T11:11:40Z'
, ctime: '2009-06-29T11:11:40Z' 
}</code></pre>

<p>より詳しくは後述の <code>fs.Stats</code> の節を参照してください。</p>
<!--
<p>See the <code>fs.Stats</code> section below for more information.</p>
-->

<h3>fs.lstat(path, [callback])</h3>

<p>非同期の lstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。</p>
<!--
<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where <code>stats</code> is a <code>fs.Stats</code> object.</p>
-->

<h3>fs.fstat(fd, [callback])</h3>

<p>非同期の fstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code> で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。</p>
<!--
<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where <code>stats</code> is a <code>fs.Stats</code> object.</p>
-->

<h3>fs.statSync(path)</h3>

<p>同期の stat(2)。<code>fs.Stats</code> のインスタンスを返します。</p>
<!--
<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.</p>
-->

<h3>fs.lstatSync(path)</h3>

<p>同期の lstat(2)。<code>fs.Stats</code> のインスタンスを返します。</p>
<!--
<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.</p>
-->

<h3>fs.fstatSync(fd)</h3>

<p>同期の fstat(2)。<code>fs.Stats</code> のインスタンスを返します。</p>
<!--
<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.</p>
-->

<h3>fs.link(srcpath, dstpath, [callback])</h3>

<p>非同期の link(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous link(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.linkSync(dstpath, srcpath)</h3>

<p>同期の link(2)。</p>
<!--
<p>Synchronous link(2).</p>
-->

<h3>fs.symlink(linkdata, path, [callback])</h3>

<p>非同期の symlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous symlink(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.symlinkSync(linkdata, path)</h3>

<p>同期の symlink(2)。</p>
<!--
<p>Synchronous symlink(2).</p>
-->

<h3>fs.readlink(path, [callback])</h3>

<p>非同期の readlink(2)。コールバックは 2 つの引数を受け取る <code>(err, resolvedPath)</code>です。</p>
<!--
<p>Asynchronous readlink(2). The callback gets two arguments <code>(err, resolvedPath)</code>. </p>
-->

<h3>fs.readlinkSync(path)</h3>

<p>同期の readlink(2)。解決されたパスを返します。</p>
<!--
<p>Synchronous readlink(2). Returns the resolved path.</p>
-->

<h3>fs.realpath(path, [callback])</h3>

<p>非同期の realpath(2)。コールバックは 2 つの引数を受け取る <code>(err, resolvedPath)</code>です。</p>
<!--
<p>Asynchronous realpath(2).  The callback gets two arguments <code>(err, resolvedPath)</code>.</p>
-->

<h3>fs.realpathSync(path)</h3>

<p>同期の realpath(2)。解決されたパスを返します。</p>
<!--
<p>Synchronous realpath(2). Returns the resolved path.</p>
-->

<h3>fs.unlink(path, [callback])</h3>

<p>非同期の unlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous unlink(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.unlinkSync(path)</h3>

<p>同期の unlink(2)。</p>
<!--
<p>Synchronous unlink(2).</p>
-->

<h3>fs.rmdir(path, [callback])</h3>

<p>非同期の rmdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.rmdirSync(path)</h3>

<p>同期の rmdir(2)。</p>
<!--
<p>Synchronous rmdir(2).</p>
-->

<h3>fs.mkdir(path, mode, [callback])</h3>

<p>非同期の mkdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.mkdirSync(path, mode)</h3>

<p>同期の mkdir(2)。</p>
<!--
<p>Synchronous mkdir(2).</p>
-->

<h3>fs.readdir(path, [callback])</h3>

<p>非同期の readdir(3)。ディレクトリの内容を読み込みます。
コールバックは 2 つの引数を受け取る <code>(err, files)</code>で、
<code>files</code> は <code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列です。</p>
<!--
<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>'.'</code> and <code>'..'</code>.</p>
-->

<h3>fs.readdirSync(path)</h3>

<p>同期の readdir(3)。<code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列を返します。</p>
<!--
<p>Synchronous readdir(3). Returns an array of filenames excluding <code>'.'</code> and
<code>'..'</code>.</p>
-->

<h3>fs.close(fd, [callback])</h3>

<p>非同期の close(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>
<!--
<p>Asynchronous close(2).  No arguments other than a possible exception are given to the completion callback.</p>
-->

<h3>fs.closeSync(fd)</h3>

<p>同期の close(2)。</p>
<!--
<p>Synchronous close(2).</p>
-->

<h3>fs.open(path, flags, mode=0666, [callback])</h3>

<p>非同期のファイルオープン。open(2) を参照してください。
フラグは 'r'、'r+'、'w'、'w+'、'a'、あるいは 'a+' です。
コールバックは 2 つの引数を受け取る <code>(err, fd)</code>です。</p>
<!--
<p>Asynchronous file open. See open(2). Flags can be 'r', 'r+', 'w', 'w+', 'a',
or 'a+'. The callback gets two arguments <code>(err, fd)</code>. </p>
-->

<h3>fs.openSync(path, flags, mode=0666)</h3>

<p>同期の open(2)。</p>
<!--
<p>Synchronous open(2). </p>
-->

<h3>fs.write(fd, buffer, offset, length, position, [callback])</h3>

<p><code>fd</code> で指定されたファイルに <code>buffer</code> を書き込みます。</p>
<!--
<p>Write <code>buffer</code> to the file specified by <code>fd</code>.</p>
-->

<p><code>offset</code> と <code>length</code> でバッファのどの部分が書き込まれるかが決まります。</p>
<!--
<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.</p>
-->

<p><code>position</code> はデータが書き込まれる位置をファイルの先頭からのオフセットで示します。
<code>position</code> が <code>null</code> の場合、データは現在の位置から書き込まれます。
pwrite(2) を参照してください。</p>
<!--
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>position</code> is <code>null</code>, the data will be written at the
current position.
See pwrite(2).</p>
-->

<p>コールバックは 2 つの引数が与えられる <code>(err, written)</code> で、
<code>written</code> は書き込まれた<em>バイト数</em>を示します。</p>
<!--
<p>The callback will be given two arguments <code>(err, written)</code> where <code>written</code>
specifies how many <em>bytes</em> were written.</p>
-->

<h3>fs.write(fd, str, position, encoding='utf8', [callback])</h3>

<p><code>fd</code> で指定されたファイルに与えられた
<code>encoding</code> を使って文字列 <code>str</code> 全体を書き込みます。</p>
<!--
<p>Write the entire string <code>str</code> using the given <code>encoding</code> to the file specified
by <code>fd</code>.</p>
-->

<p><code>position</code> はデータが書き込まれる位置をファイルの先頭からのオフセットで示します。
<code>position</code> が <code>null</code> の場合、データは現在の位置から書き込まれます。
pwrite(2) を参照してください。</p>
<!--
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>position</code> is <code>null</code>, the data will be written at the
current position.
See pwrite(2).</p>
-->

<p>コールバックは 2 つの引数が与えられる <code>(err, written)</code> で、
<code>written</code> は書き込まれた<em>バイト数</em>を示します。</p>
<!--
<p>The callback will be given two arguments <code>(err, written)</code> where <code>written</code>
specifies how many <em>bytes</em> were written.</p>
-->

<h3>fs.writeSync(fd, buffer, offset, length, position)</h3>

<p>同期版のバッファベース <code>fs.write()</code>。書き込まれたバイト数を返します。</p>
<!--
<p>Synchronous version of buffer-based <code>fs.write()</code>. Returns the number of bytes written.</p>
-->

<h3>fs.writeSync(fd, str, position, encoding='utf8')</h3>

<p>同期版の文字列ベース <code>fs.write()</code>。書き込まれたバイト数を返します。</p>
<!--
<p>Synchronous version of string-based <code>fs.write()</code>. Returns the number of bytes written.</p>
-->

<h3>fs.read(fd, buffer, offset, length, position, [callback])</h3>

<p><code>fd</code> で指定されたファイルからデータを読み込みます。</p>
<!--
<p>Read data from the file specified by <code>fd</code>.</p>
-->

<p><code>buffer</code> はデータが書き込まれるバッファです。</p>
<!--
<p><code>buffer</code> is the buffer that the data will be written to.</p>
-->

<p><code>offset</code> は書き込みを開始するバッファ内のオフセットです。</p>
<!--
<p><code>offset</code> is offset within the buffer where writing will start.</p>
-->

<p><code>length</code> は読み込むバイト数を指定する整数です。</p>
<!--
<p><code>length</code> is an integer specifying the number of bytes to read.</p>
-->

<p><code>position</code> はファイルの読み込みを開始する位置を指定する整数です。
<code>position</code> が <code>null</code> の場合、データは現在の位置から読み込まれます。</p>
<!--
<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.</p>
-->

<p>コールバックは2つの引数が与えられる <code>(err, bytesRead)</code> です。</p>
<!--
<p>The callback is given the two arguments, <code>(err, bytesRead)</code>.</p>
-->

<h3>fs.read(fd, length, position, encoding, [callback])</h3>

<p><code>fd</code> で指定されたファイルからデータを読み込みます。</p>
<!--
<p>Read data from the file specified by <code>fd</code>.</p>
-->

<p><code>length</code> は読み込むバイト数を指定する整数です。</p>
<!--
<p><code>length</code> is an integer specifying the number of bytes to read.</p>
-->

<p><code>position</code> はファイルの読み込みを開始する位置を指定する整数です。
<code>position</code> が <code>null</code> の場合、データは現在の位置から読み込まれます。</p>
<!--
<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.</p>
-->

<p><code>encoding</code> は <code>fd</code> から読み込まれるデータを文字列にするためのエンコーディングです。</p>
<!--
<p><code>encoding</code> is the desired encoding of the string of data read in from <code>fd</code>.</p>
-->

<p>コールバックは 3 つの引数が与えられる <code>(err, str, bytesRead)</code> です。</p>
<!--
<p>The callback is given the three arguments, <code>(err, str, bytesRead)</code>.</p>
-->

<h3>fs.readSync(fd, buffer, offset, length, position)</h3>

<p>同期版のバッファベース <code>fs.read</code>。<code>bytesRead</code> の数を返します。</p>
<!--
<p>Synchronous version of buffer-based <code>fs.read</code>. Returns the number of <code>bytesRead</code>.</p>
-->

<h3>fs.readSync(fd, length, position, encoding)</h3>

<p>同期版の文字列ベース <code>fs.read</code>。<code>bytesRead</code> の数を返します。</p>
<!--
<p>Synchronous version of string-based <code>fs.read</code>. Returns the number of <code>bytesRead</code>.</p>
-->

<h3>fs.readFile(filename, [encoding], [callback])</h3>

<p>ファイル全体の内容を非同期に読み込みます。例:</p>
<!--
<p>Asynchronously reads the entire contents of a file. Example:</p>
-->

<pre><code>fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>

<p>コールバックは 2 つの引数が渡される <code>(err, data)</code> で、<code>data</code> はファイルの内容です。</p>
<!--
<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.</p>
-->

<p>エンコーディングが指定されなければ、生のバッファが渡されます。</p>
<!--
<p>If no encoding is specified, then the raw buffer is returned.</p>
-->

<h3>fs.readFileSync(filename, [encoding])</h3>

<p>同期版の <code>fs.readFile</code>。<code>filename</code> の内容を返します。</p>
<!--
<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.</p>
-->

<p><code>encoding</code> が指定されるとこの関数は文字列を返します。
そうでなければバッファを返します。</p>
<!--
<p>If <code>encoding</code> is specified then this function returns a string. Otherwise it
returns a buffer.</p>
-->

<h3>fs.writeFile(filename, data, encoding='utf8', [callback])</h3>

<p>非同期にデータをファイルに書き込みます。<code>data</code> は文字列またはバッファです。</p>
<!--
<p>Asynchronously writes data to a file. <code>data</code> can be a string or a buffer.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {
  if (err) throw err;
  console.log('It\'s saved!');
});</code></pre>

<h3>fs.writeFileSync(filename, data, encoding='utf8')</h3>

<p>同期版の <code>fs.writeFile</code>。</p>
<!--
<p>The synchronous version of <code>fs.writeFile</code>.</p>
-->

<h3>fs.watchFile(filename, [options], listener)</h3>

<p><code>filename</code> の変更を監視します。コールバックの <code>listener</code> はファイルが変更される度に呼び出されます。</p>
<!--
<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each
time the file changes.</p>
-->

<p>2 番目の引数はオプションです。<code>options</code> が与えられるなら、
オブジェクトは boolean の 2 つのメンバ、<code>persistent</code> と <code>interval</code>
(ポーリング間隔のミリ秒) を持つべきです。
デフォルトは <code>{persistent: true, interval: 0}</code> です。</p>
<!--
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing two members a boolean, <code>persistent</code>, and <code>interval</code>, a polling
value in milliseconds. The default is <code>{persistent: true, interval: 0}</code>.</p>
-->

<p><code>listener</code> は現在の状態オブジェクトと前の状態オブジェクトの 2 つの引数を受け取ります:</p>
<!--
<p>The <code>listener</code> gets two arguments the current stat object and the previous
stat object:</p>
-->

<pre><code>fs.watchFile(f, function (curr, prev) {
  console.log('the current mtime is: ' + curr.mtime);
  console.log('the previous mtime was: ' + prev.mtime);
});</code></pre>

<p>これらの状態オブジェクトは <code>fs.Stat</code> のインスタンスです。</p>
<!--
<p>These stat objects are instances of <code>fs.Stat</code>. </p>
-->

<h3>fs.unwatchFile(filename)</h3>

<p><code>filename</code> の変更に対する監視を終了します。</p>
<!--
<p>Stop watching for changes on <code>filename</code>.</p>
-->

<h2 id="fs.Stats">fs.Stats</h2>

<p><code>fs.stat()</code> と <code>fs.lstat()</code> から返されるオブジェクトはこの型です。</p>
<!--
<p>Objects returned from <code>fs.stat()</code> and <code>fs.lstat()</code> are of this type.</p>
-->

<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (<code>fs.lstat()</code>でのみ有効)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<!--
<ul><li><code>stats.isFile()</code></li><li><code>stats.isDirectory()</code></li><li><code>stats.isBlockDevice()</code></li><li><code>stats.isCharacterDevice()</code></li><li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li><li><code>stats.isFIFO()</code></li><li><code>stats.isSocket()</code></li></ul>
-->

<h2 id="fs.ReadStream">fs.ReadStream</h2>

<p><code>ReadStream</code> は <code>Readable Stream</code> です。</p>
<!--
<p><code>ReadStream</code> is a <code>Readable Stream</code>.</p>
-->

<h3>fs.createReadStream(path, [options])</h3>

<p>新しい ReadStream オブジェクトを返します (<code>Readable Stream</code> を参照してください)。</p>
<!--
<p>Returns a new ReadStream object (See <code>Readable Stream</code>).</p>
-->

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:</p>
<!--
<p><code>options</code> is an object with the following defaults:</p>
-->

<pre><code>{ 'flags': 'r'
, 'encoding': null
, 'mode': 0666
, 'bufferSize': 4 * 1024
}</code></pre>

<p>ファイル全体を読み込む代わりに一部の範囲を読み込むため、
<code>options</code> に <code>start</code> および <code>end</code> を含めることができます。
<code>start</code> と <code>end</code> はどちらも包含的で0から始まります。
使う際にはいつでも、両方を同時に指定しなければなりません。
</p>
<!--
<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and
start at 0.  When used, both the limits must be specified always.</p>
-->

<p>100 バイトの長さを持つファイルの最後の 10 バイトを読み込む例:</p>
<!--
<p>An example to read the last 10 bytes of a file which is 100 bytes long:</p>
-->

<pre><code>fs.createReadStream('sample.txt', {start: 90, end: 99});</code></pre>

<h2 id="fs.WriteStream">fs.WriteStream</h2>

<p><code>WriteStream</code> は <code>Writable Stream</code> です。</p>
<!--
<p><code>WriteStream</code> is a <code>Writable Stream</code>.</p>
-->

<h3>fs.createWriteStream(path, [options])</h3>

<p>新しい WriteStream オブジェクトを返します (<code>Writable Stream</code> を参照してください)。</p>
<!--
<p>Returns a new WriteStream object (See <code>Writable Stream</code>).</p>
-->

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:</p>
<!--
<p><code>options</code> is an object with the following defaults:</p>
-->

<pre><code>{ 'flags': 'w'
, 'encoding': null
, 'mode': 0666
}</code></pre>

<h2 id="HTTP">HTTP</h2>

<p>HTTP サーバおよびクライアントを使用するにはいずれも <code>require('http')</code> が必要です。</p>
<!--
<p>To use the HTTP server and client one must <code>require('http')</code>.</p>
-->

<p>Node の HTTP インタフェースは、
伝統的に扱いが難しかったプロトコルの多くの機能をサポートするように設計されています。
とりわけ大きくて、場合によってはチャンク化されたメッセージです。
インタフェースは決してリクエストまたはレスポンス全体をバッファリングしないように気をつけています
－ 利用者はストリームデータを使うことができます。
</p>
<!--
<p>The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.</p>
-->

<p>HTTP メッセージヘッダはこのようなオブジェクトとして表現されます:</p>
<!--
<p>HTTP message headers are represented by an object like this:</p>
-->

<pre><code>{ 'content-length': '123'
, 'content-type': 'text/plain'
, 'stream': 'keep-alive'
, 'accept': '*/*'
}</code></pre>

<p>キーは小文字化されます。値は変更されません。</p>
<!--
<p>Keys are lowercased. Values are not modified.</p>
-->

<p>考えられる HTTP アプリケーションを完全にサポートするために、
Node の HTTP API はとても低水準です。それはストリームのハンドリングとメッセージの解析だけに対処します。
解析はメッセージをヘッダとボディに分けますが、実際のヘッダとボディは解析しません。</p>
<!--
<p>In order to support the full spectrum of possible HTTP applications, Node's
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.</p>
-->

<p>プラットフォームで OpenSSL が利用可能であれば HTTPS がサポートされます。</p>
<!--
<p>HTTPS is supported if OpenSSL is available on the underlying platform.</p>
-->

<h2 id="http.Server">http.Server</h2>

<p>これは以下のイベントを持つ <code>EventEmitter</code> です:</p>
<!--
<p>This is an <code>EventEmitter</code> with the following events:</p>
-->

<h3>イベント: 'request'</h3>
<!--
<h3>Event: 'request'</h3>
-->

<p><code>function (request, response) { }</code></p>

<p><code>request</code> は <code>http.ServerRequest</code> のインスタンス、
<code>response</code> は <code>http.ServerResponse</code> のインスタンスです。</p>
<!--
<p> <code>request</code> is an instance of <code>http.ServerRequest</code> and <code>response</code> is
 an instance of <code>http.ServerResponse</code></p>
-->

<h3>イベント: 'connection'</h3>
<!--
<h3>Event: 'connection'</h3>
-->

<p><code>function (stream) { }</code></p>

<p>新しい TCP ストリームが確立した時。
<code>stream</code> は <code>net.Stream</code> 型のオブジェクトです。
通常の利用者がこのイベントにアクセスしたくなることはないでしょう。
<code>stream</code> は <code>request.connection</code> からアクセスすることもできます。</p>
<!--
<p> When a new TCP stream is established. <code>stream</code> is an object of type
 <code>net.Stream</code>. Usually users will not want to access this event. The
 <code>stream</code> can also be accessed at <code>request.connection</code>.</p>
-->

<h3>イベント: 'close'</h3>
<!--
<h3>Event: 'close'</h3>
-->

<p><code>function (errno) { }</code></p>

<p>サーバがクローズした時に生成されます。</p>
<!--
<p> Emitted when the server closes. </p>
-->

<h3>イベント: 'request'</h3>
<!--
<h3>Event: 'request'</h3>
-->

<p><code>function (request, response) {}</code></p>

<p>リクエストの度に生成されます。コネクションごとに複数のリクエストがあることに注意してください
(Keep Alive なコネクションの場合)。</p>
<!--
<p>Emitted each time there is request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).</p>
-->

<h3>イベント: 'upgrade'</h3>
<!--
<h3>Event: 'upgrade'</h3>
-->

<p><code>function (request, socket, head)</code></p>

<p>クライアントが HTTP のアップグレードを要求する度に生成されます。
このイベントが監視されない場合、アップグレードを要求したクライアントのコネクションはクローズされます。</p>
<!--
<p>Emitted each time a client requests a http upgrade. If this event isn't
listened for, then clients requesting an upgrade will have their connections
closed.</p>
-->

<ul>
<li><code>request</code> はリクエストイベントと同様に HTTP リクエストへの引数です。</li>
<li><code>socket</code> はサーバとクライアントの間のネットワークソケットです。</li>
<li><code>head</code> はアップグレードストリームの最初のパケットを持つ Buffer のインスタンスです。
空の場合もあります。</li>
</ul>
<!--
<ul><li><code>request</code> is the arguments for the http request, as it is in the request event.</li><li><code>socket</code> is the network socket between the server and client.</li><li><code>head</code> is an instance of Buffer, the first packet of the upgraded stream, this may be empty.</li></ul>
-->

<p>このイベントが生成された後、リクエスト元のソケットはもう <code>data</code> イベントリスナーを持ちません。
このソケットでサーバへ送られたデータを扱うためにそれをバインドしなければならないことを意味します。</p>
<!--
<p>After this event is emitted, the request's socket will not have a <code>data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.</p>
-->

<h3>イベント: 'clientError'</h3>
<!--
<h3>Event: 'clientError'</h3>
-->

<p><code>function (exception) {}</code></p>

<p>クライアントコネクションが 'error' イベントを発した場合 － ここに転送されます。</p>
<!--
<p>If a client connection emits an 'error' event - it will forwarded here.</p>
-->

<h3>http.createServer(requestListener)</h3>

<p>新しい Web サーバオブジェクトを返します。</p>
<!--
<p>Returns a new web server object.</p>
-->

<p><code>requestListener</code> は自動的に <code>'request'</code> イベントに加えられる関数です。</p>
<!--
<p>The <code>requestListener</code> is a function which is automatically
added to the <code>'request'</code> event.</p>
-->

<h3>server.listen(port, [hostname], [callback])</h3>

<p>指定されたポートとホスト名でコネクションの受け入れを開始します。
ホスト名が省略されると、サーバはどんな IPv4 アドレスへの接続も受け入れます (<code>INADDR_ANY</code>)。</p>
<!--
<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>
-->

<p>UNIX ドメインソケットを待ち受ける場合、ポートとホスト名ではなくファイル名を提供します。</p>
<!--
<p>To listen to a unix socket, supply a filename instead of port and hostname.</p>
-->

<p>この関数は非同期です。最後の引数の <code>callback</code> はサーバがポートをバインドすると呼び出されます。</p>
<!--
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound to the port.</p>
-->

<h3>server.listen(path, [callback])</h3>

<p><code>path</code> で与えられたコネクションを待ち受ける UNIX ドメインソケットのサーバを開始します。</p>
<!--
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>
-->

<p>この関数は非同期です。最後の引数の <code>callback</code> はサーバがバインドすると呼び出されます。</p>
<!--
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>
-->

<h3>server.setSecure(credentials)</h3>

<p>秘密鍵とサーバ証明書を指定した暗号モジュールの認証情報で、サーバに対して HTTPS サポートを有効にします。
オプションで認証局で証明されたクライアント認証を使うこともできます。</p>
<!--
<p>Enables HTTPS support for the server, with the crypto module credentials specifying the private key and certificate of the server, and optionally the CA certificates for use in client authentication.</p>
-->

<p>認証情報が一つ以上の認証局の証明書を持っている場合、
サーバは HTTPS コネクションにおけるハンドシェークの一部としてクライアント証明書を送るようクライアントに要求します。
その有効性と内容は、サーバの <code>resuest.connection</code> から
<code>verifyPeer()</code> と <code>getPeerCertificate()</code> を通じてアクセスできます。</p>
<!--
<p>If the credentials hold one or more CA certificates, then the server will request for the client to submit a client certificate as part of the HTTPS connection handshake. The validity and content of this can be accessed via verifyPeer() and getPeerCertificate() from the server's request.connection.</p>
-->

<h3>server.close()</h3>

<p>サーバが新しいコネクションを受け付けるのを終了します。</p>
<!--
<p>Stops the server from accepting new connections.</p>
-->

<h2 id="http.ServerRequest">http.ServerRequest</h2>

<p>このオブジェクトは HTTP サーバ内部 － ユーザではなく － で作成され、
<code>'request'</code> リスナーの第1引数として渡されます。</p>
<!--
<p>This object is created internally by a HTTP server--not by
the user--and passed as the first argument to a <code>'request'</code> listener.</p>
-->

<p>これは以下のイベントを持つ <code>EventEmitter</code> です:</p>
<!--
<p>This is an <code>EventEmitter</code> with the following events:</p>
-->

<h3>イベント: 'data'</h3>
<!--
<h3>Event: 'data'</h3>
-->

<p><code>function (chunk) { }</code></p>

<p>メッセージボディの断片を受信した場合に生成されます。<p>
<!--
<p>Emitted when a piece of the message body is received.</p>
-->

<p>例: 一つの引数としてボディのチャンクが与えられます。
転送エンコーディングでデコードされます。
ボディのチャンクは文字列です。
ボディのエンコーディングは <code>request.setBodyEncoding()</code> で設定されます。</p>
<!--
<p>Example: A chunk of the body is given as the single
argument. The transfer-encoding has been decoded.  The
body chunk is a string.  The body encoding is set with
<code>request.setBodyEncoding()</code>.</p>
-->

<h3>イベント: 'end'</h3>
<!--
<h3>Event: 'end'</h3>
-->

<p><code>function () { }</code></p>

<p>メッセージごとに厳密に一回生成されます。引数はありません。
このイベントが生成された後、このリクエストで生成されるイベントはありません。</p>
<!--
<p>Emitted exactly once for each message. No arguments.  After
emitted no other events will be emitted on the request.</p>
-->

<h3>request.method</h3>

<p>リクエストメソッドを表す文字列です。参照のみ可能です。
例: <code>'GET'</code>、<code>'DELETE'</code></p>
<!--
<p>The request method as a string. Read only. Example:
<code>'GET'</code>, <code>'DELETE'</code>.</p>
-->

<h3>request.url</h3>

<p>リクエスト URL を表す文字列です。
これは実際の HTTP リクエストに存在する URL だけを含みます。</p>
<!--
<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:</p>
-->

<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>

<p>この場合の <code>request.url</code> はこうなります:</p>
<!--
<p>Then <code>request.url</code> will be:</p>
-->

<pre><code>'/status?name=ryan'</code></pre>

<p>URL の要素を解析したい場合は、
<code>require('url').parse(request.url)</code> を参照してください。例:</p>
<!--
<p>If you would like to parse the URL into its parts, you can use
<code>require('url').parse(request.url)</code>.  Example:</p>
-->

<pre><code>node&gt; require('url').parse('/status?name=ryan')
{ href: '/status?name=ryan'
, search: '?name=ryan'
, query: 'name=ryan'
, pathname: '/status'
}</code></pre>

<p>問い合わせ文字列からパラメータを取り出したい場合は、
<code>require('querystring').parse</code> 関数を参照するか、
<code>require('url').parse</code>の第 2 引数に <code>true</code> を渡してください。例:</p>
<!--
<p>If you would like to extract the params from the query string,
you can use the <code>require('querystring').parse</code> function, or pass
<code>true</code> as the second argument to <code>require('url').parse</code>.  Example:</p>
-->

<pre><code>node&gt; require('url').parse('/status?name=ryan', true)
{ href: '/status?name=ryan'
, search: '?name=ryan'
, query: { name: 'ryan' }
, pathname: '/status'
}</code></pre>

<h3>request.headers</h3>

<p>参照のみ可能です。</p>
<!--
<p>Read only.</p>
-->

<h3>request.httpVersion</h3>

<p>HTTP プロトコルのバージョンを表す文字列です。参照のみ可能です。例:
<code>'1.1'</code>、<code>'1.0'</code>。
同様に <code>request.httpVersionMajor</code> は最初の整数、
<code>request.httpVersionMinor</code> は 2 番目の整数です。</p>
<!--
<p>The HTTP protocol version as a string. Read only. Examples:
<code>'1.1'</code>, <code>'1.0'</code>.
Also <code>request.httpVersionMajor</code> is the first integer and
<code>request.httpVersionMinor</code> is the second.</p>
-->

<h3>request.setEncoding(encoding=null)</h3>

<p>リクエストボディのエンコーディングを設定します。
<code>'utf8'</code> または <code>'binary'</code> のいずれかです。
デフォルトは <code>null</code> で、<code>'data'</code> イベントが
<code>Buffer</code> を生成することを意味します。</p>
<!--
<p>Set the encoding for the request body. Either <code>'utf8'</code> or <code>'binary'</code>. Defaults
to <code>null</code>, which means that the <code>'data'</code> event will emit a <code>Buffer</code> object..</p>
-->

<h3>request.pause()</h3>

<p>リクエストによるイベントの生成を中断します。アップロード速度を落とすのに便利です。</p>
<!--
<p>Pauses request from emitting events.  Useful to throttle back an upload.</p>
-->

<h3>request.resume()</h3>

<p>中断されたリクエストを再開します。</p>
<!--
<p>Resumes a paused request.</p>
-->

<h3>request.connection</h3>

<p>コネクションに関連づけられた <code>net.Stream</code> オブジェクトです。</p>
<!--
<p>The <code>net.Stream</code> object associated with the connection.</p>
-->

<p>HTTPS では <code>request.connection.verifyPeer()</code> と
<code>request.connection.getPeerCertificate()</code> で
クライアントの認証の詳細を取得できます。</p>
<!--
<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client's
authentication details.</p>
-->

<h2 id="http.ServerResponse">http.ServerResponse</h2>

<p>このオブジェクトは HTTP サーバ内部 － ユーザではなく － で作成されます。
<code>'request'</code> リスナーの第 2 引数として渡されます。
これは <code>Writable Stream</code> です。</p>
<!--
<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code>'request'</code> event. It is a <code>Writable Stream</code>.</p>
-->

<h3>response.writeHead(statusCode, [reasonPhrase], [headers])</h3>

<p>レスポンスヘッダを送信します。
ステータスコードは <code>404</code> のような 3 桁の数字による HTTP ステータスコードです。
最後の引数 <code>headers</code> は、レスポンスヘッダです。
オプションとして人に読める形式の <code>reasonPhrase</code> を第 2 引数で与えることができます。</p>
<!--
<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
Optionally one can give a human-readable <code>reasonPhrase</code> as the second
argument.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>var body = 'hello world';
response.writeHead(200, {
  'Content-Length': body.length,
  'Content-Type': 'text/plain'
});</code></pre>

<p>このメソッドはメッセージごとに 1 回だけ呼び出されなくてはならず、
<code>response.end()</code> の前に呼び出されなければなりません。</p>
<!--
<p>This method must only be called once on a message and it must
be called before <code>response.end()</code> is called.</p>
-->

<h3>response.write(chunk, encoding='ascii')</h3>

<p>このメソッドは <code>writeHead</code> の後に呼び出されなければなりません。
これはレスポンスボディのチャンクを送信します。
このメソッドはボディの連続した部分を提供するために複数回呼び出されるかもしれません。
</p>
<!--
<p>This method must be called after <code>writeHead</code> was
called. It sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.</p>
-->

<p><code>chunk</code> は文字列またはバッファにすることができます。
<code>chunk</code> が文字列の場合、どのエンコードでバイトストリームにするかを第 2 引数で指定します。
デフォルトの <code>encoding</code> は <code>'ascii'</code> です。</p>
<!--
<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>'ascii'</code>.</p>
-->

<p><strong>注意</strong>: これは生の HTTP ボディで、
高水準のマルチパートボディエンコーディングで使われるものとは無関係です。</p>
<!--
<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.</p>
-->

<p>初めて <code>response.write()</code> が呼び出されると、
バッファリングされていたヘッダ情報と最初のボディがクライアントに送信されます。
2 回目に <code>response.write()</code> が呼ばれると、
Node はストリーミングデータを分割して送信しようとしていると仮定します。
すなわち、レスポンスはボディの最初のチャンクまでバッファリングされます。</p>
<!--
<p>The first time <code>response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code>response.write()</code> is called, Node assumes you're going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.</p>
-->

<h3>response.end([data], [encoding])</h3>

<p>このメソッドはレスポンスの全てのヘッダとボディを送信したことをサーバに伝えます;
サーバはメッセージが終了したと考えるべきです。
この <code>response.end()</code> メソッドは各レスポンスごとに呼び出さなければ<em>なりません</em>。</p>
<!--
<p>This method signals to the server that all of the response headers and body
has been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each
response.</p>
-->

<p><code>data</code> が指定された場合、
<code>response.write(data, encoding)</code> に続けて <code>response.end()</code> を呼び出すのと等価です。</p>
<!--
<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
followed by <code>response.end()</code>.</p>
-->

<h2 id="http.Client">http.Client</h2>

<p>HTTP クライアントは引数として渡されるサーバアドレスによって構築され、
戻り値のハンドルは一つまたはそれ以上のリクエストを発行するのに使われます。
接続されたサーバに応じて、クライアントはパイプライン化されたリクエストまたは、
それぞれのストリームの後でストリームを再確立するかもしれません。
<em>現在の実装はリクエストをパイプライン化しません。</em></p>
<!--
<p>An HTTP client is constructed with a server address as its
argument, the returned handle is then used to issue one or more
requests.  Depending on the server connected to, the client might
pipeline the requests or reestablish the stream after each
stream. <em>Currently the implementation does not pipeline requests.</em></p>
-->

<p><code>google.com</code> に接続する例:</p>
<!--
<p>Example of connecting to <code>google.com</code>:</p>
-->

<pre><code>var http = require('http');
var google = http.createClient(80, 'www.google.com');
var request = google.request('GET', '/',
  {'host': 'www.google.com'});
request.end();
request.on('response', function (response) {
  console.log('STATUS: ' + response.statusCode);
  console.log('HEADERS: ' + JSON.stringify(response.headers));
  response.setEncoding('utf8');
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});</code></pre>

<p>少数の特別なヘッダがあることに注意してください。</p>
<!--
<p>There are a few special headers that should be noted.</p>
-->

<ul>
<li><p>'Host' ヘッダは Node によって加えられませんが、通常の Web サイトに必要とされます。</p></li>
<li><p>'Connection: keep-alive' を送信することで、サーバへの接続を次のリクエストまで維持することを Node に通知します。</p></li>
<li><p>'Content-length' ヘッダを送信することで、デフォルトのチャンクエンコーディングが無効になります。</p></li>
</ul>
<!--
<ul><li><p>The 'Host' header is not added by Node, and is usually required by
website.</p></li><li><p>Sending a 'Connection: keep-alive' will notify Node that the connection to
the server should be persisted until the next request.</p></li><li><p>Sending a 'Content-length' header will disable the default chunked encoding.</p></li></ul>
-->

<h3>イベント: 'upgrade'</h3>
<!--
<h3>Event: 'upgrade'</h3>
-->

<p><code>function (request, socket, head)</code></p>

<p>サーバがアップグレード要求に応答する度に生成されます。
このイベントが監視されていない場合、クライアントがアップグレードヘッダを受信するとそのコネクションはクローズされます。</p>
<!--
<p>Emitted each time a server responds to a request with an upgrade. If this event
isn't being listened for, clients receiving an upgrade header will have their
connections closed.</p>
-->

<p>より詳しくは <code>http.Server</code> の <code>upgrade</code> イベントの説明を参照してください。</p>
<!--
<p>See the description of the <code>upgrade</code> event for <code>http.Server</code> for further details.</p>
-->

<h3>http.createClient(port, host='localhost', secure=false, [credentials])</h3>

<p>新しい HTTP クライアントを構築します。
<code>port</code> と <code>host</code> は接続先となるサーバを参照します。
リクエストが発行されるまでストリームは確立されません。</p>
<!--
<p>Constructs a new HTTP client. <code>port</code> and
<code>host</code> refer to the server to be connected to. A
stream is not established until a request is issued.</p>
-->

<p><code>secure</code> はオプションの boolean フラグで HTTPS サポートを有効にし、
<code>credentials</code> はオプションで、
暗号モジュールの認証情報でクライアントの秘密鍵、証明書、そして信頼できる認証局の証明書を含むことができます。</p>
<!--
<p><code>secure</code> is an optional boolean flag to enable https support and <code>credentials</code> is an optional credentials object from the crypto module, which may hold the client's private key, certificate, and a list of trusted CA certificates.</p>
-->

<p>コネクションがセキュアな場合、証明情報で認証局の証明書が明示的に渡されないと、
node.js はデフォルトの信頼できる認証局のリストとして
http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt を与えます。</p>
<!--
<p>If the connection is secure, but no explicit CA certificates are passed in the credentials, then node.js will default to the publicly trusted list of CA certificates, as given in http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</p>
-->

<h3>client.request(method='GET', path, [request_headers])</h3>

<p>リクエストを発行します; 必要であればストリームを確立します。
<code>http.ClientRequest</code> のインスタンスを返します。</p>
<!--
<p>Issues a request; if necessary establishes stream. Returns a <code>http.ClientRequest</code> instance.</p>
-->

<p><code>method</code> はオプションで、省略された場合のデフォルトは 'GET'です。</p>
<!--
<p><code>method</code> is optional and defaults to 'GET' if omitted.</p>
-->

<p><code>request_headers</code> はオプションです。
Node 内部で付加的なリクエストヘッダが加えられることがあります。
<code>ClientRequest</code> オブジェクトを返します。</p>
<!--
<p><code>request_headers</code> is optional.
Additional request headers might be added internally
by Node. Returns a <code>ClientRequest</code> object.</p>
-->

<p>ボディを送信しようとしている場合は、<code>Content-Length</code> ヘッダを含めることを忘れないでください。
ボディをストリーム化する場合は、おそらく <code>Transfer-Encoding: chunked</code> をセットしてください。</p>
<!--
<p>Do remember to include the <code>Content-Length</code> header if you
plan on sending a body. If you plan on streaming the body, perhaps
set <code>Transfer-Encoding: chunked</code>.</p>
-->

<p><em>注意</em>: リクエストは完了していません。このメソッドはリクエストのヘッダを送信するだけです。
リクエストを完了してレスポンスを読み出すには <code>request.end()</code> を呼ぶ必要があります。
(複雑に感じるかもしれませんが、
これは <code>request.write()</code> でボディをストリーム化するチャンスをユーザに提供します))。</p>
<!--
<p><em>NOTE</em>: the request is not complete. This method only sends the header of
the request. One needs to call <code>request.end()</code> to finalize the request and
retrieve the response.  (This sounds convoluted but it provides a chance for
the user to stream a body to the server with <code>request.write()</code>.)</p>
-->

<h3>client.verifyPeer()</h3>

<p>指定された、あるいはデフォルトの信頼された認証局の証明書において、
サーバの証明書の妥当性に応じて true または false を返します。</p>
<!--
<p>Returns true or false depending on the validity of the server's certificate in the context of the defined or default list of trusted CA certificates.</p>
-->

<h3>client.getPeerCertificate()</h3>

<p>サーバ証明書の詳細を、'subject'、'issuer'、'valid_from' そして
'valid_to' をキーとする証明書の辞書を含む JSON 形式で返します。</p>
<!--
<p>Returns a JSON structure detailing the server's certificate, containing a dictionary with keys for the certificate 'subject', 'issuer', 'valid_from' and 'valid_to'</p>
-->

<h2 id="http.ClientRequest">http.ClientRequest</h2>

<p>このオブジェクトは HTTP サーバ内部で作成され、<code>http.Client</code> の
<code>request()</code> メソッドから返されます。
それはヘッダが送信された<em>進行中</em>のリクエストを表現します。</p>
<!--
<p>This object is created internally and returned from the <code>request()</code> method
of a <code>http.Client</code>. It represents an <em>in-progress</em> request whose header has
already been sent.</p>
-->

<p>レスポンスを取得するには、<code>'response'</code> 用のリスナーをリクエストオブジェクトに加えます。
<code>'response'</code> イベントはレスポンスヘッダを受信するとリクエストオブジェクトによって生成されます。
<code>'response'</code> イベントは <code>http.ClientResponse</code> のインスタンスを唯一の引数として実行されます。</p>
<!--
<p>To get the response, add a listener for <code>'response'</code> to the request object.
<code>'response'</code> will be emitted from the request object when the response
headers have been received.  The <code>'response'</code> event is executed with one
argument which is an instance of <code>http.ClientResponse</code>.</p>
-->

<p><code>'response'</code> イベントの間、レスポンスオブジェクトにリスナーを加えることができます;
とりわけ <code>'data'</code> イベントのリスナーです。
<code>'response'</code> イベントはレスポンスボディのどの部分を受信するよりも前に呼び出されることに注意してください。
そのため、ボディの最初の部分の受信と競合することを心配する必要はありません。
<code>'response'</code> イベントの間に <code>'data'</code> イベントのリスナーが加えられる限り、
ボディ全体を受信することができます。</p>
<!--
<p>During the <code>'response'</code> event, one can add listeners to the
response object; particularly to listen for the <code>'data'</code> event. Note that
the <code>'response'</code> event is called before any part of the response body is received,
so there is no need to worry about racing to catch the first part of the
body. As long as a listener for <code>'data'</code> is added during the <code>'response'</code>
event, the entire body will be caught.</p>
-->

<pre><code>// Good
request.on('response', function (response) {
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// Bad - misses all or part of the body
request.on('response', function (response) {
  setTimeout(function () {
    response.on('data', function (chunk) {
      console.log('BODY: ' + chunk);
    });
  }, 10);
});</code></pre>

<p>これは <code>Writable Stream</code> です。</p>
<!--
<p>This is a <code>Writable Stream</code>.</p>
-->

<p>これは以下のイベントを持つ <code>EventEmitter</code> です。</p>
<!--
<p>This is an <code>EventEmitter</code> with the following events:</p>
-->

<h3>イベント 'response'</h3>
<!--
<h3>Event 'response'</h3>
-->

<p><code>function (response) { }</code></p>

<p>このリクエストに対するレスポンスを受信した時に生成されます。
このイベントは一回だけ生成されます。
<code>response</code> 引数は <code>http.ClientResponse</code> のインスタンスです。</p>
<!--
<p>Emitted when a response is received to this request. This event is emitted only once. The
<code>response</code> argument will be an instance of <code>http.ClientResponse</code>.</p>
-->

<h3>request.write(chunk, encoding='ascii')</h3>

<p>ボディのチャンクを送信します。
このメソッドを何回も呼び出すと、サーバへのリクエストボディをストリーム化できます － 
このケースは <code>['Transfer-Encoding', 'chunked']</code> ヘッダでリクエストを生成したことを意味します。</p>
<!--
<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code>['Transfer-Encoding', 'chunked']</code> header line when
creating the request.</p>
-->

<p><code>chunk</code> 引数は整数の配列か文字列になります。</p>
<!--
<p>The <code>chunk</code> argument should be an array of integers
or a string.</p>
-->

<p><code>encoding</code> 引数はオプションで、<code>chunk</code> が文字列の場合だけ適用されます。
エンコーディング引数は <code>'utf8'</code> か <code>'ascii'</code> のどちらかです。
デフォルトはボディにより速い ASCII エンコーディングを使用します。</p>
<!--
<p>The <code>encoding</code> argument is optional and only
applies when <code>chunk</code> is a string. The encoding
argument should be either <code>'utf8'</code> or
<code>'ascii'</code>. By default the body uses ASCII encoding,
as it is faster.</p>
-->

<h3>request.end([data], [encoding])</h3>

<p>リクエストの送信を終了します。
ボディのいくつかの部分がまだ送信されていない場合、それはストリームにフラッシュされます。
リクエストがチャンク化されている場合、これは終端の <code>'0\r\n\r\n'</code> を送信します。</p>
<!--
<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>'0\r\n\r\n'</code>.</p>
-->

<p><code>data</code> が指定された場合は、
<code>request.write(data, encoding)</code> に続けて <code>request.end()</code> を呼び出すのと等価です。</p>
<!--
<p>If <code>data</code> is specified, it is equivalent to calling <code>request.write(data, encoding)</code>
followed by <code>request.end()</code>.</p>
-->

<h2 id="http.ClientResponse">http.ClientResponse</h2>

<p>このオブジェクトは <code>http.Client</code> によってリクエストと一緒に作成されます。
これはリクエストオブジェクトの <code>'response'</code> イベントに渡されます。</p>
<!--
<p>This object is created when making a request with <code>http.Client</code>. It is
passed to the <code>'response'</code> event of the request object.</p>
-->

<p>レスポンスは <code>Readable Stream</code> を実装します。</p>
<!--
<p>The response implements the <code>Readable Stream</code> interface.</p>
-->

<h3>イベント: 'data'</h3>
<!--
<h3>Event: 'data'</h3>
-->

<p><code>function (chunk) {}</code></p>

<p>メッセージボディの断片を受信した場合に生成されます。</p>
<!--
<p>Emitted when a piece of the message body is received.</p>
-->

<p>例: ボディのチャンクは一つの引数として与えられます。
転送エンコーディングでデコードされます。
ボディのチャンクは文字列です。
ボディエンコーディングは <code>response.setBodyEncoding()</code> によって設定されます。</p>
<!--
<pre><code>Example: A chunk of the body is given as the single
argument. The transfer-encoding has been decoded.  The
body chunk a String.  The body encoding is set with
`response.setBodyEncoding()`.</code></pre>
-->

<h3>イベント: 'end'</h3>
<!--
<h3>Event: 'end'</h3>
-->

<p><code>function () {}</code></p>

<p>メッセージごとに厳密に一回だけ生成されます。
このイベントが生成された後、このレスポンスはどんなイベントも生成しません。</p>
<!--
<p>Emitted exactly once for each message. No arguments. After
emitted no other events will be emitted on the response.</p>
-->

<h3>response.statusCode</h3>

<p>3 桁の数字によるレスポンスのステータスコードです。例えば <code>404</code>。</p>
<!--
<p>The 3-digit HTTP response status code. E.G. <code>404</code>.</p>
-->

<h3>response.httpVersion</h3>

<p>接続しているサーバとの HTTP のバージョンです。
おそらく <code>'1.1'</code> または <code>'1.0'</code> のどちらかです。
同様に <code>response.httpVersionMajor</code> は最初の整数、
<code>response.httpVersionMinor</code> は 2 番目の整数です。</p>
<!--
<p>The HTTP version of the connected-to server. Probably either
<code>'1.1'</code> or <code>'1.0'</code>.
Also <code>response.httpVersionMajor</code> is the first integer and
<code>response.httpVersionMinor</code> is the second.</p>
-->

<h3>response.headers</h3>

<p>レスポンスヘッダオブジェクトです。</p>
<!--
<p>The response headers object.</p>
-->

<h3>response.setEncoding(encoding=null)</h3>

<p>レスポンスボディのエンコーディングを設定します。
<code>'utf8'</code>、<code>'ascii'</code>、あるいは <code>'base64'</code> のいずれかです。
デフォルトは <code>null</code> で、
<code>'data'</code> イベントが <code>Buffer</code> を生成することを意味します。</p>
<!--
<p>Set the encoding for the response body. Either <code>'utf8'</code>, <code>'ascii'</code>, or <code>'base64'</code>.
Defaults to <code>null</code>, which means that the <code>'data'</code> event will emit a <code>Buffer</code> object..</p>
-->

<h3>response.pause()</h3>

<p>イベントの生成によるレスポンスを中断します。ダウンロード速度を落とすのに便利です。</p>
<!--
<p>Pauses response from emitting events.  Useful to throttle back a download.</p>
-->

<h3>response.resume()</h3>

<p>中断されていたレスポンスを再開します。</p>
<!--
<p>Resumes a paused response.</p>
-->

<h3>response.client</h3>

<p>このレスポンスを所有する <code>http.Client</code> への参照です。</p>
<!--
<p>A reference to the <code>http.Client</code> that this response belongs to.</p>
-->

<h2 id="net.Server">net.Server</h2>

<p>このクラスは TCP または UNIX ドメインのサーバを作成するために使われます。</p>
<!--
<p>This class is used to create a TCP or UNIX server.</p>
-->

<p>8124 番のポートをリッスンするエコーサーバの例:</p>
<!--
<p>Here is an example of a echo server which listens for connections
on port 8124:</p>
-->

<pre><code>var net = require('net');
var server = net.createServer(function (stream) {
  stream.setEncoding('utf8');
  stream.on('connect', function () {
    stream.write('hello\r\n');
  });
  stream.on('data', function (data) {
    stream.write(data);
  });
  stream.on('end', function () {
    stream.write('goodbye\r\n');
    stream.end();
  });
});
server.listen(8124, 'localhost');</code></pre>

<p><code>'/tmp/echo.sock'</code> へのソケットを待ち受けるには、最後の行をこのように変更します。</p>
<!--
<p>To listen on the socket <code>'/tmp/echo.sock'</code>, the last line would just be
changed to</p>
-->

<pre><code>server.listen('/tmp/echo.sock');</code></pre>

<p>これは以下のイベントを持つ <code>EventEmitter</code> です:</p>
<!--
<p>This is an <code>EventEmitter</code> with the following events:</p>
-->

<h3>イベント: 'connection'</h3>
<!--
<h3>Event: 'connection'</h3>
-->

<p><code>function (stream) {}</code></p>

<p>新しいコネクションが作成されると生成されます。
<code>stream</code> は <code>net.Stream</code> のインスタンスです。</p>
<!--
<p>Emitted when a new connection is made. <code>stream</code> is an instance of
<code>net.Stream</code>.</p>
-->

<h3>イベント: 'close'</h3>
<!--
<h3>Event: 'close'</h3>
-->

<p><code>function () {}</code></p>

<p>サーバがクローズした時に生成されます。</p>
<!--
<p>Emitted when the server closes.</p>
-->

<h3>net.createServer(connectionListener)</h3>

<p>新しい TCP サーバを作成します。
<code>connectionListener</code> 引数は <code>'connection'</code>
イベントに対するリスナーとして自動的に加えられます。</p>
<!--
<p>Creates a new TCP server. The <code>connectionListener</code> argument is
automatically set as a listener for the <code>'connection'</code> event.</p>
-->

<h3>server.listen(port, [host], [callback])</h3>

<p>指定された <code>port</code> と <code>host</code> でコネクションの受け入れを開始します。
<code>host</code> が省略されると、サーバはどんな IPv4 アドレスへの接続も受け入れます
(<code>INADDR_ANY</code>)。</p>
<!--
<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>
-->

<p>この関数は非同期です。最後の引数の <code>callback</code> はサーバがバインドすると呼び出されます。</p>
<!--
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>
-->

<h3>server.listen(path, [callback])</h3>

<p>与えられた <code>path</code> へのコネクションを待ち受けるする UNIX ドメインソケットのサーバを開始します。</p>
<!--
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>
-->

<p>この関数は非同期です。
最後の引数の <code>callback</code> はサーバがバインドすると呼び出されます。</p>
<!--
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>
-->

<h3>server.listenFD(fd)</h3>

<p>与えられたファイル記述子上のコネクションを待ち受けるサーバを開始します。</p>
<!--
<p>Start a server listening for connections on the given file descriptor.</p>
-->

<p>このファイル記述子は既に <code>bind(2)</code> および
<code>listen(2)</code> システムコールが呼び出されていなければなりません。</p>
<!--
<p>This file descriptor must have already had the <code>bind(2)</code> and <code>listen(2)</code> system
calls invoked on it.</p>
-->

<h3>server.close()</h3>

<p>サーバが新しいコネクションを受け付けるのを終了します。
この関数は非同期で、サーバは最終的に <code>'close'</code> イベントを生成した時にクローズされます。</p>
<!--
<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>'close'</code>
event.</p>
-->

<h3>server.maxConnections</h3>

<p>サーバの接続数が大きくなった時に接続を拒否するためにこのプロパティを設定します。</p>
<!--
<p>Set this property to reject connections when the server's connection count gets high.</p>
-->

<h3>server.connections</h3>

<p>このサーバ上の並行コネクションの数です。</p>
<!--
<p>The number of concurrent connections on the server.</p>
-->

<h2 id="net.Stream">net.Stream</h2>

<p>このオブジェクトは TCP または UNIX ドメインのソケットを抽象化したものです。
<code>net.Stream</code> のインスタンスは双方向のストリームインタフェースを実装します。
それらはユーザによって作成されて (<code>connect()</code> によって) クライアントとして使われるか、
Node によって作成されてサーバの <code>'connection'</code> イベントを通じてユーザに渡されます。</p>
<!--
<p>This object is an abstraction of of a TCP or UNIX socket.  <code>net.Stream</code>
instance implement a duplex stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Node
and passed to the user through the <code>'connection'</code> event of a server.</p>
-->

<p><code>net.Stream</code> のインスタンスは以下のイベントを持つ EventEmitter です:</p>
<!--
<p><code>net.Stream</code> instances are EventEmitters with the following events:</p>
-->

<h3>イベント: 'connect'</h3>
<!--
<h3>Event: 'connect'</h3>
-->

<p><code>function () { }</code></p>

<p>ストリームコネクションの確立が成功した場合に生成されます。
<code>connect()</code> を参照してください。</p>
<!--
<p>Emitted when a stream connection successfully is established.
See <code>connect()</code>.</p>
-->

<h3>イベント: 'secure'</h3>
<!--
<h3>Event: 'secure'</h3>
-->

<p><code>function () { }</code></p>

<p>ストリームコネクションにおいて、接続相手との HTTPS ハンドシェークの確立が成功した場合に生成されます。</p>
<!--
<p>Emitted when a stream connection successfully establishes a HTTPS handshake with its peer.</p>
-->

<h3>イベント: 'data'</h3>
<!--
<h3>Event: 'data'</h3>
-->

<p><code>function (data) { }</code></p>

<p>データを受信した場合に生成されます。
<code>data</code> 引数は <code>Buffer</code> または <code>String</code> です。
データのエンコーディングは <code>stream.setEncoding()</code> で設定されます。
(より詳しい情報は <code>Readable Stream</code> を参照してください)。</p>
<!--
<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or
<code>String</code>.  Encoding of data is set by <code>stream.setEncoding()</code>.
(See the section on <code>Readable Stream</code> for more information.)</p>
-->

<h3>イベント: 'end'</h3>
<!--
<h3>Event: 'end'</h3>
-->

<p><code>function () { }</code></p>

<p>ストリームの相手側が FIN パケットを送信した場合に生成されます。
このイベントが生成された後、<code>readyState</code> は <code>'writeOnly'</code> になります。
このイベントが生成されると、おそらく <code>stream.end()</code> を呼ばなければならないでしょう。</p>
<!--
<p>Emitted when the other end of the stream sends a FIN packet. After this is
emitted the <code>readyState</code> will be <code>'writeOnly'</code>. One should probably just
call <code>stream.end()</code> when this event is emitted.</p>
-->

<h3>イベント: 'timeout'</h3>
<!--
<h3>Event: 'timeout'</h3>
-->

<p><code>function () { }</code></p>

<p>ストリームがタイムアウトして非アクティブになった場合に生成されます。
これはストリームがアイドルになったことを通知するだけです。
利用者は手動でコネクションをクローズする必要があります。</p>
<!--
<p>Emitted if the stream times out from inactivity. This is only to notify that
the stream has been idle. The user must manually close the connection.</p>
-->

<p>関連情報: <code>stream.setTimeout()</code></p>
<!--
<p>See also: <code>stream.setTimeout()</code></p>
-->

<h3>イベント: 'drain'</h3>
<!--
<h3>Event: 'drain'</h3>
-->

<p><code>function () { }</code></p>

<p>書き込みバッファが空になった場合に生成されます。アップロード速度を落とすために使うことができます。</p>
<!--
<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.</p>
-->

<h3>イベント: 'error'</h3>
<!--
<h3>Event: 'error'</h3>
-->

<p><code>function (exception) { }</code></p>

<p>エラーが発生した場合に生成されます。<code>'close'</code> イベントはこのイベントの後に直接呼び出されます。</p>
<!--
<p>Emitted when an error occurs.  The <code>'close'</code> event will be called directly
following this event.</p>
-->

<h3>イベント: 'close'</h3>
<!--
<h3>Event: 'close'</h3>
-->

<p><code>function (had_error) { }</code></p>

<p>ストリームが完全にクローズした場合に生成されます。
引数 <code>had_error</code> は boolean で、ストリームが転送エラーでクローズされたのかどうかを示します。</p>
<!--
<p>Emitted once the stream is fully closed. The argument <code>had_error</code> is a boolean which says if
the stream was closed due to a transmission
error.</p>
-->

<h3>net.createConnection(port, host='127.0.0.1')</h3>

<p>新しいストリームオブジェクトを構築し、
指定の <code>port</code> と <code>host</code> へのストリームをオープンします。
第 2 引数が省略されると、ローカルホストが仮定されます。</p>
<!--
<p>Construct a new stream object and opens a stream to the specified <code>port</code>
and <code>host</code>. If the second parameter is omitted, localhost is assumed.</p>
-->

<p>ストリームが確立されると、<code>'connect'</code> イベントが生成されます。</p>
<!--
<p>When the stream is established the <code>'connect'</code> event will be emitted.</p>
-->

<h3>stream.connect(port, host='127.0.0.1')</h3>

<p>指定の <code>port</code> と <code>host</code> でストリームをオープンします。
<code>createConnection()</code> もまたストリームをオープンします: 通常このメソッドは必要とされません。
これを使うのは、ストリームがクローズされた後にオブジェクトを再利用して別のサーバに接続する場合だけです。</p>
<!--
<p>Opens a stream to the specified <code>port</code> and <code>host</code>. <code>createConnection()</code>
also opens a stream; normally this method is not needed. Use this only if
a stream is closed and you want to reuse the object to connect to another
server.</p>
-->

<p>この関数は非同期です。ストリームが確立されると <code>'connect'</code> イベントが生成されます。
接続で問題があった場合は <code>'connect'</code> イベントは生成されず、
例外とともに <code>'error'</code> イベントが生成されます。</p>
<!--
<p>This function is asynchronous. When the <code>'connect'</code> event is emitted the
stream is established. If there is a problem connecting, the <code>'connect'</code>
event will not be emitted, the <code>'error'</code> event will be emitted with 
the exception.</p>
-->

<h3>stream.remoteAddress</h3>

<p>リモートの IP アドレスを表現する文字列です。
例えば、<code>'74.125.127.100'</code> あるいは <code>'2001:4860:a005::68'</code>。</p>
<!--
<p>The string representation of the remote IP address. For example,
<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>
-->

<p>このメンバはサーバサイドのコネクションでのみ与えられます。</p>
<!--
<p>This member is only present in server-side connections.</p>
-->

<h3>stream.readyState</h3>

<p><code>'closed'</code>、<code>'open'</code>、<code>'opening'</code>、<code>'readOnly'</code>、
あるいは <code>'writeOnly'</code> のいずれかです。</p>
<!--
<p>Either <code>'closed'</code>, <code>'open'</code>, <code>'opening'</code>, <code>'readOnly'</code>, or <code>'writeOnly'</code>.</p>
-->

<h3>stream.setEncoding(encoding=null)</h3>

<p>受信したデータのエンコーディングを設定します (<code>'ascii'</code>、<code>'utf8'</code>，
あるいは <code>'base64'</code> のいずれかです)。</p>
<!--
<p>Sets the encoding (either <code>'ascii'</code>, <code>'utf8'</code>, or <code>'base64'</code>) for data that is
received.</p>
-->

<h3>stream.setSecure([credentials])</h3>

<p>秘密鍵とサーバ証明書を指定した暗号モジュールの認証情報で、
ストリームに対して HTTPS サポートを有効にします。
オプションで認証局で証明された相手側の認証を使うこともできます。</p>
<!--
<p>Enables HTTPS support for the stream, with the crypto module credentials specifying the private key and certificate of the stream, and optionally the CA certificates for use in peer authentication.</p>
-->

<p>認証情報が一つ以上の認証局の証明書を持っている場合、
ストリームは HTTPS コネクションにおけるハンドシェークの一部としてクライアント証明書を送るよう相手に要求します。
その有効性と内容は、<code>verifyPeer()</code> と <code>getPeerCertificate()</code> を通じてアクセスできます。</p>
<!--
<p>If the credentials hold one ore more CA certificates, then the stream will request for the peer to submit a client certificate as part of the HTTPS connection handshake. The validity and content of this can be accessed via verifyPeer() and getPeerCertificate().</p>
-->

<h3>stream.verifyPeer()</h3>

<p>指定された、あるいはデフォルトの信頼された認証局の証明書において、
相手の証明書の妥当性に応じて true または false を返します。</p>
<!--
<p>Returns true or false depending on the validity of the peers's certificate in the context of the defined or default list of trusted CA certificates.</p>
-->

<h3>stream.getPeerCertificate()</h3>

<p>相手の証明書の詳細を、'subject'、'issuer'、'valid_from'
そして 'valid_to' をキーとする証明書の辞書を含む JSON 形式で返します。</p>
<!--
<p>Returns a JSON structure detailing the peer's certificate, containing a dictionary with keys for the certificate 'subject', 'issuer', 'valid_from' and 'valid_to'</p>
-->

<h3>stream.write(data, encoding='ascii')</h3>

<p>ストリームにデータを送信します。
文字列の場合、第 2 引数はエンコーディングを指定します － UTF8 はより遅いため、デフォルトは ASCII です。</p>
<!--
<p>Sends data on the stream. The second parameter specifies the encoding in
the case of a string--it defaults to ASCII because encoding to UTF8 is rather
slow.</p>
-->

<p>データ全体のカーネルバッファへのフラッシュが成功すると <code>true</code> を返します。
データ全体または一部がユーザメモリ内のキューに入れられた場合は <code>false</code> を返します。
再びバッファが空いた場合は <code>'drain'</code> イベントが生成されます。</p>
<!--
<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>'drain'</code> will be emitted when the buffer is again free.</p>
-->

<h3>stream.end([data], [encoding])</h3>

<p>ストリームをハーフクローズします。例えば FIN パケットを送信します。
サーバがデータを送り続けてくることがあり得ます。
このメソッドを呼び出した後の <code>readyState</code> は <code>'readOnly'</code> になります。</p>
<!--
<p>Half-closes the stream. I.E., it sends a FIN packet. It is possible the
server will still send some data. After calling this <code>readyState</code> will be
<code>'readOnly'</code>.</p>
-->

<p><code>data</code> が指定された場合は、
<code>stream.write(data, encoding)</code> に続けて <code>stream.end()</code> を呼び出すのと等価です。</p>
<!--
<p>If <code>data</code> is specified, it is equivalent to calling <code>stream.write(data, encoding)</code>
followed by <code>stream.end()</code>.</p>
-->

<h3>stream.destroy()</h3>

<p>このストリーム上でどんな I/O も起こらないことを保証します。
(パースエラーなどの) エラーの場合にだけ必要です。</p>
<!--
<p>Ensures that no more I/O activity happens on this stream. Only necessary in
case of errors (parse error or so).</p>
-->

<h3>stream.pause()</h3>

<p>データの読み込みを中断します。つまり、<code>'data'</code> イベントは生成されません。
アップロード速度を落とすために便利です。</p>
<!--
<p>Pauses the reading of data. That is, <code>'data'</code> events will not be emitted.
Useful to throttle back an upload.</p>
-->

<h3>stream.resume()</h3>

<p><code>pause()</code> を呼び出した後で読み込みを再開します。</p>
<!--
<p>Resumes reading after a call to <code>pause()</code>.</p>
-->

<h3>stream.setTimeout(timeout)</h3>

<p>非アクティブなストリームが <code>timeout</code> ミリ秒後にタイムアウトするようにストリームを設定します。
デフォルトでは <code>net.Stream</code> はタイムアウトしません。</p>
<!--
<p>Sets the stream to timeout after <code>timeout</code> milliseconds of inactivity on
the stream. By default <code>net.Stream</code> do not have a timeout.</p>
-->

<p>アイドルタイムアウトが引き起こされると、ストリームは <code>'timeout'</code> イベントを受信しますが、
コネクションは切断されません。
ユーザは手動で <code>end()</code> または <code>destroy()</code> を呼び出す必要があります。</p>
<!--
<p>When an idle timeout is triggered the stream will receive a <code>'timeout'</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the stream.</p>
-->

<p><code>timeout</code> が 0 の場合、アイドルタイムアウトは無効にされます。</p>
<!--
<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>
-->

<h3>stream.setNoDelay(noDelay=true)</h3>

<p>Nagle アルゴリズムを無効にします。
デフォルトでは TCP コネクションは Nagle アルゴリズムを使用し、データを送信する前にバッファリングします。
<code>noDelay</code> に設定すると、データは <code>stream.write()</code> を呼び出す度に即座に送信されます。</p>
<!--
<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>noDelay</code> will
immediately fire off data each time <code>stream.write()</code> is called.</p>
-->

<h3>stream.setKeepAlive(enable=false, [initialDelay])</h3>

<p>キープアライブ機能を有効/無効にします。
オプションでキープアライブの最初の調査がアイドルストリームに送信されるまでの初期遅延を設定します。
<code>initialDelay</code> (ミリ秒) が設定されると、
最後にデータパケットを受信してから最初のキープアライブ調査までの遅延が設定されます。
初期遅延に 0 が設定されると、デフォルト設定から値を変更されないようにします。</p>
<!--
<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle stream.
Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting.</p>
-->

<h2 id="Crypto">暗号化</h2>
<!--
<h2 id="Crypto">Crypto</h2>
-->

<p>このモジュールにアクセスするには <code>require('crypto')</code> を使用します。</p>
<!--
<p>Use <code>require('crypto')</code> to access this module.</p>
-->

<p>暗号化モジュールは下層のプラットフォームで OpenSSL が有効であることを必要とします。
それは安全な HTTPS ネットワークや http コネクションの一部として使われる、
安全な認証情報をカプセル化する方法を提供します。</p>
<!--
<p>The crypto module requires OpenSSL to be available on the underlying platform. It offers a way of encapsulating secure credentials to be used as part of a secure HTTPS net or http connection.</p>
-->

<p>同時に OpenSSL のハッシュ、HMAC、暗号、復号、署名、そして検証へのラッパーを一式提供します。</p>
<!--
<p>It also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.</p>
-->

<h3>crypto.createCredentials(details)</h3>

<p>認証情報オブジェクトを作成します。オプションの <code>details</code> は以下のキーを持つ辞書です:</p>
<!--
<p>Creates a credentials object, with the optional details being a dictionary with keys:</p>
-->

<p><code>key</code> : PEM でエンコードされた秘密鍵を保持する文字列</p>
<!--
<p><code>key</code> : a string holding the PEM encoded private key</p>
-->

<p><code>cert</code> : PEM でエンコードされた証明書を保持する文字列</p>
<!--
<p><code>cert</code> : a string holding the PEM encoded certificate</p>
-->

<p><code>ca</code> : 信頼できる認証局の証明書が PEM でエンコードされた文字列または文字列の配列</p>
<!--
<p><code>ca</code> : either a string or list of strings of PEM encoded CA certificates to trust.</p>
-->

<p>'ca' の詳細が与えられなかった場合、node.js はデフォルトとして
http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt
で与えられる、信頼できる認証局の公開されたリストを使用します。</p>
<!--
<p>If no 'ca' details are given, then node.js will use the default publicly trusted list of CAs as given in 
http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</p>
-->

<h3>crypto.createHash(algorithm)</h3>

<p>ハッシュオブジェクトを生成して返します。
与えられたアルゴリズムによる暗号ハッシュ関数はダイジェストの生成に使われます。</p>
<!--
<p>Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests.</p>
-->

<p><code>algorithm</code> は、
プラットフォーム上の OpenSSL のバージョンでサポートされている利用可能なアルゴリズムに依存します。
例えば sha1、md5、sha256、sha512、などです。
最近のリリースでは、<code>openssl list-message-digest-algorithms</code>
で利用可能なダイジェストアルゴリズムが表示されます。</p>
<!--
<p><code>algorithm</code> is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are sha1, md5, sha256, sha512, etc. On recent releases, <code>openssl list-message-digest-algorithms</code> will display the available digest algorithms.</p>
-->

<h3>hash.update(data)</h3>

<p>与えられた <code>data</code> でハッシュの内容を更新します。
これは新しいデータがストリームに流される際に何度も呼び出されます。</p>
<!--
<p>Updates the hash content with the given <code>data</code>. This can be called many times with new data as it is streamed.</p>
-->

<h3>hash.digest(encoding='binary')</h3>

<p>渡された全てのデータがハッシュ化されたダイジェストを計算します。
<code>encoding</code> は 'hex'、'binary'、または 'base64' のいずれかです。</p>
<!--
<p>Calculates the digest of all of the passed data to be hashed. The <code>encoding</code> can be 'hex', 'binary' or 'base64'.</p>
-->

<h3>crypto.createHmac(algorithm, key)</h3>

<p>与えられたアルゴリズムとキーで HMAC を計算する、HMAC オブジェクトを作成して返します。</p>
<!--
<p>Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key.</p>
-->

<p><code>algorithm</code> は OpenSSL でサポートされているアルゴリズムに依存します － 
前述の <code>createHash</code> を参照してください。</p>
<!--
<p><code>algorithm</code> is dependent on the available algorithms supported by OpenSSL - see createHash above.
<code>key</code> is the hmac key to be used.</p>
-->

<h3>hmac.update(data)</h3>

<p>与えられた <code>data</code> で HMAC の内容を更新します。
これは新しいデータがストリームに流される際に何度も呼び出されます。</p>
<!--
<p>Update the hmac content with the given <code>data</code>. This can be called many times with new data as it is streamed.</p>
-->

<h3>hmac.digest(encoding='binary')</h3>

<p>渡された全てのデータが HMAC 化されたダイジェストを計算します。
<code>encoding</code> は 'hex'、'binary'、または 'base64' のいずれかです。</p>
<!--
<p>Calculates the digest of all of the passed data to the hmac. The <code>encoding</code> can be 'hex', 'binary' or 'base64'.</p>
-->

<h3>crypto.createCipher(algorithm, key)</h3>

<p>与えられたアルゴリズムとキーを使用する暗号オブジェクトを作成して返します。</p>
<!--
<p>Creates and returns a cipher object, with the given algorithm and key.</p>
-->

<p><code>algorithm</code> は、OpenSSL に依存します。例えば aes192 などです。
最近のリリースでは、<code>openssl list-cipher-algorithms</code>
で利用可能な暗号アルゴリズムが表示されます。</p>
<!--
<p><code>algorithm</code> is dependent on OpenSSL, examples are aes192, etc. On recent releases, <code>openssl list-cipher-algorithms</code> will display the available cipher algorithms.</p>
-->

<h3>cipher.update(data, input_encoding='binary', output_encoding='binary')</h3>

<p><code>data</code> で暗号を更新します。
<code>input_encoding</code> で与えられるエンコーディングは 'utf8'、'ascii'、'binary' のいずれかです。
<code>output_encoding</code> は暗号化されたデータの出力フォーマットを指定するもので、
'binary'、'base64' または 'hex' のいずれかです。</p>
<!--
<p>Updates the cipher with <code>data</code>, the encoding of which is given in <code>input_encoding</code> and can be 'utf8', 'ascii' or 'binary'. The <code>output_encoding</code> specifies the output format of the enciphered data, and can be 'binary', 'base64'  or 'hex'.</p>
-->

<p>暗号化されたコンテンツが返されます。これは新しいデータがストリームに流される際に何度も呼び出されます。</p>
</p>
<!--
<p>Returns the enciphered contents, and can be called many times with new data as it is streamed.</p>
-->

<h3>cipher.final(output_encoding='binary')</h3>

<p>暗号化されたコンテンツの残りを返します。
<code>output_encoding</code> は次のいずれかです: 'binary'、'base64' または 'hex'</p>
<!--
<p>Returns any remaining enciphered contents, with <code>output_encoding</code> being one of: 'binary', 'ascii' or 'utf8'.</p>
-->

<h3>crypto.createDecipher(algorithm, key)</h3>

<p>与えられたアルゴリズムとキーを使用する復号オブジェクトを作成して返します。
これは前述の暗号オブジェクトの鏡写しです。</p>
<!--
<p>Creates and returns a decipher object, with the given algorithm and key. This is the mirror of the cipher object above.</p>
-->

<h3>decipher.update(data, input_encoding='binary', output_encoding='binary')</h3>

<p>'binary'、'base64' または 'hex' のいずれかでエンコードされた復号を <code>data</code> で更新します。
<code>output_decoding</code> は復号化されたプレーンテキストのフォーマットを指定するもので、
'binary'、'ascii' あるいは 'utf8' のいずれかです。</p>
<!--
<p>Updates the decipher with <code>data</code>, which is encoded in 'binary', 'base64' or 'hex'. The <code>output_decoding</code> specifies in what format to return the deciphered plaintext - either 'binary', 'ascii' or 'utf8'.</p>
-->

<h3>decipher.final(output_encoding='binary')</h3>

<p>復号化されたプレーンテキストの残りを返します。
<code>output_decoding</code> は 'binary'、'ascii' あるいは 'utf8' のいずれかです。</p>
<!--
<p>Returns any remaining plaintext which is deciphered, with `output_encoding' being one of: 'binary', 'ascii' or 'utf8'.</p>
-->

<h3>crypto.createSign(algorithm)</h3>

<p>与えられたアルゴリズムで署名オブジェクトを作成して返します。
最近のOpenSSLのリリースでは、<code>openssl list-public-key-algorithms</code>
で利用可能な署名アルゴリズムの一覧が表示されます。例えば 'RSA-SHA256'。</p>
<!--
<p>Creates and returns a signing object, with the given algorithm. On recent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will display the available signing algorithms. Examples are 'RSA-SHA256'.</p>
-->

<h3>signer.update(data)</h3>

<p>署名オブジェクトをデータで更新します。
これは新しいデータがストリームに流される際に何度も呼び出されます。</p>
<!--
<p>Updates the signer object with data. This can be called many times with new data as it is streamed.</p>
-->

<h3>signer.sign(private_key, output_format='binary')</h3>

<p>署名オブジェクトに渡された全ての更新データで署名を計算します。
<code>private_key</code> は PEM でエンコードされた秘密鍵を内容とする文字列です。</p>
<!--
<p>Calculates the signature on all the updated data passed through the signer. <code>private_key</code> is a string containing the PEM encoded private key for signing.</p>
-->

<p>'binary'、'hex'、あるいは 'base64' のいずれかを指定した <code>output_format</code> による署名を返します。</p>
<!--
<p>Returns the signature in <code>output_format</code> which can be 'binary', 'hex' or 'base64'</p>
-->

<h3>crypto.createVerify(algorithm)</h3>

<p>与えられたアルゴリズムで検証オブジェクトを作成して返します。これは前述の署名オブジェクトと鏡写しです。</p>
<!--
<p>Creates and returns a verification object, with the given algorithm. This is the mirror of the signing object above.</p>
-->

<h3>verifier.update(data)</h3>

<p>検証オブジェクトをデータで更新します。
これは新しいデータがストリームに流される際に何度も呼び出されます。</p>
<!--
<p>Updates the verifyer object with data. This can be called many times with new data as it is streamed.</p>
-->

<h3>verifier.verify(public_key, signature, signature_format='binary')</h3>

<p>署名されたデータを <code>public_key</code> と <code>signature</code> で検証します。
<code>public_key</code> は PEM でエンコードされた公開鍵を含む文字列です。
<code>signature</code> は先に計算したデータの署名で、
その <code>signature_format</code> は 'binary'、'hex'、または 'base64' のいずれかです。</p>
<!--
<p>Verifies the signed data by using the <code>public_key</code> which is a string containing the PEM encoded public key, and <code>signature</code>, which is the previously calculates signature for the data, in the <code>signature_format</code> which can be 'binary', 'hex' or 'base64'.</p>
-->

<p>署名されたデータと公開鍵による検証の結果によって true または false を返します。</p>
<!--
<p>Returns true or false depending on the validity of the signature for the data and public key.</p>
-->

<h2 id="DNS">DNS</h2>

<p>このモジュールにアクセスするには <code>require('dns')</code> を使用します。</p>
<!--
<p>Use <code>require('dns')</code> to access this module.</p>
-->

<p>これは <code>'www.google.com'</code> を解決して、返された IP アドレスを逆引きで解決する例です。</p>
<!--
<p>Here is an example which resolves <code>'www.google.com'</code> then reverse
resolves the IP addresses which are returned.</p>
-->

<pre><code>var dns = require('dns');

dns.resolve4('www.google.com', function (err, addresses) {
  if (err) throw err;

  console.log('addresses: ' + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, domains) {
      if (err) {
        console.log('reverse for ' + a + ' failed: ' +
          err.message);
      } else {
        console.log('reverse for ' + a + ': ' +
          JSON.stringify(domains));
      }
    });
  });
});</code></pre>

<h3>dns.lookup(domain, family=null, callback)</h3>

<p>ドメイン (例 <code>'google.com'</code>) を解決して最初に見つかった
A (IPv4) または AAAA (IPv6) レコードにします。</p>
<!--
<p>Resolves a domain (e.g. <code>'google.com'</code>) into the first found A (IPv4) or
AAAA (IPv6) record.</p>
-->

<p>コールバックは引数 <code>(err, address, family)</code> を持ちます。
<code>address</code> 引数は IP v4 または v6 アドレスを表現する文字列です。
<code>family</code> 引数は 4 または 6 の整数で，<code>address</code> のファミリーを意味します
(この値は必ずしも最初に <code>lookup</code> に渡す必要はありません)。</p>
<!--
<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument
is a string representation of a IP v4 or v6 address. The <code>family</code> argument
is either the integer 4 or 6 and denotes the family of <code>address</code> (not
neccessarily the value initially passed to <code>lookup</code>).</p>
-->

<h3>dns.resolve(domain, rrtype='A', callback)</h3>

<p>ドメイン (例 <code>'google.com'</code>) を解決して <code>rrtype</code> で指定されたレコードタイプの配列にします。
妥当な <code>rrtype</code> は <code>A</code> (IPV4アドレス)、<code>AAAA</code> (IPV6アドレス)、
<code>MX</code> (mail exchangeレコード), <code>TXT</code> (テキストレコード)、<code>SRV</code> (SRVレコード)、
<code>PTR</code> (IP を逆引きでルックアップするために使われる) です。</p>
<!--
<p>Resolves a domain (e.g. <code>'google.com'</code>) into an array of the record types
specified by rrtype. Valid rrtypes are <code>A</code> (IPV4 addresses), <code>AAAA</code> (IPV6
addresses), <code>MX</code> (mail exchange records), <code>TXT</code> (text records), <code>SRV</code> (SRV
records), and <code>PTR</code> (used for reverse IP lookups).</p>
-->

<p>コールバックは引数 <code>(err, addresses)</code> を持ちます。
<code>addresses</code> の各要素の種類はレコードの種類によって決まり、
対応する後述のルックアップメソッドで記述されます。</p>
<!--
<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item
in <code>addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.</p>
-->

<p>エラー発生時、<code>err</code> は <code>Error</code> オブジェクトのインスタンスであり、
<code>err.errno</code> は後述するエラーコードのいずれか、
<code>err.message</code> はエラーを英語で説明する文字列となります。</p>
<!--
<p>On error, <code>err</code> would be an instanceof <code>Error</code> object, where <code>err.errno</code> is
one of the error codes listed below and <code>err.message</code> is a string describing
the error in English.</p>
-->

<h3>dns.resolve4(domain, callback)</h3>

<p><code>dns.resolve()</code> と同じですが、IPv4 アドレス (<code>A</code> レコード) だけを問い合わせます。
<code>addresses</code> は IPv4 アドレスの配列です (例<br />
<code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>)</p>
<!--
<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records). 
<code>addresses</code> is an array of IPv4 addresses (e.g.<br /><code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>).</p>
-->

<h3>dns.resolve6(domain, callback)</h3>

<p>IPv6 (<code>AAAA</code> レコード) を問い合わせることを除いて <code>dns.resolve4()</code> と同じです。</p>
<!--
<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).</p>
-->

<h3>dns.resolveMx(domain, callback)</h3>

<p><code>dns.resolve()</code> と同じですが、mail exchange (<code>MX</code> レコード) だけを問い合わせます。</p>
<!--
<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).</p>
-->

<p><code>addresses</code>は MX レコードの配列で、それぞれは priority と exchange の属性を持ちます
(例 <code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>)。</p>
<!--
<p><code>addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>).</p>
-->

<h3>dns.resolveTxt(domain, callback)</h3>

<p><code>dns.resolve()</code> と同じですが、テキスト (<code>TXT</code> レコード) だけを問い合わせます。
<code>addresses</code> は利用可能な <code>domain</code> のテキストレコードの配列です。
(例、<code>['v=spf1 ip4:0.0.0.0 ~all']</code>)</p>
<!--
<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).
<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,
<code>['v=spf1 ip4:0.0.0.0 ~all']</code>).</p>
-->

<h3>dns.resolveSrv(domain, callback)</h3>

<p><code>dns.resolve()</code> と同じですが、サービスレコード (<code>SRV</code> レコード) だけを問い合わせます。
<code>addresses</code> は利用可能な <code>domain</code> の SRV レコードの配列です。
SRV レコードのプロパティは priority、weight、port、そして name です
(例 <code>[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>)。</p>
<!--
<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).
<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties
of SRV records are priority, weight, port, and name (e.g., 
<code>[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>).</p>
-->

<h3>dns.reverse(ip, callback)</h3>

<p>IP アドレスからドメイン名の配列へ逆引きで解決します。</p>
<!--
<p>Reverse resolves an ip address to an array of domain names.</p>
-->

<p>コールバックは引数 <code>(err, domains)</code> を持ちます。</p>
<!--
<p>The callback has arguments <code>(err, domains)</code>. </p>
-->

<p>エラーがあった場合、<code>err</code> は非 null で Error オブジェクトのインスタンスとなります。</p>
<!--
<p>If there an an error, <code>err</code> will be non-null and an instanceof the Error
object.</p>
-->

<p>どの DNS 問い合わせもエラーコードを返せます。</p>
<!--
<p>Each DNS query can return an error code.</p>
-->

<ul>
<li><code>dns.TEMPFAIL</code>: タイムアウト、SERVFAIL あるいは同様のもの。</li>
<li><code>dns.PROTOCOL</code>: 応答が不正。</li>
<li><code>dns.NXDOMAIN</code>: ドメインが存在しない。</li>
<li><code>dns.NODATA</code>: ドメインは存在するが、要求された種類のデータがない。</li>
<li><code>dns.NOMEM</code>: 処理中にメモリが不足。</li>
<li><code>dns.BADQUERY</code>: 問い合わせが不正な形式。</li></ul>
<!--
<ul><li><code>dns.TEMPFAIL</code>: timeout, SERVFAIL or similar.</li><li><code>dns.PROTOCOL</code>: got garbled reply.</li><li><code>dns.NXDOMAIN</code>: domain does not exists.</li><li><code>dns.NODATA</code>: domain exists but no data of reqd type.</li><li><code>dns.NOMEM</code>: out of memory while processing.</li><li><code>dns.BADQUERY</code>: the query is malformed.</li></ul>
-->

<h2 id="dgram">データグラム</h2>
<!--
<h2 id="dgram">dgram</h2>
-->

<p>データグラムソケットは <code>require('dgram')</code> で利用可能になります。
データグラムはほとんどの場合 IP/UDP メッセージで扱われますが、UNIX ドメインソケットでも使用することができます。</p>
<!--
<p>Datagram sockets are available through <code>require('dgram')</code>.  Datagrams are most commonly 
handled as IP/UDP messages, but they can also be used over Unix domain sockets.</p>
-->

<h3>イベント: 'message'</h3>
<!--
<h3>Event: 'message'</h3>
-->

<p><code>function (msg, rinfo) { }</code></p>

<p>ソケット上で新しいデータグラムが到着した時に生成されます。
<code>msg</code> は <code>Buffer</code> で、
<code>rinfo</code >は送信者のアドレス情報とデータグラムのバイト数を持ったオブジェクトです。</p>
<!--
<p>Emitted when a new datagram is available on a socket.  <code>msg</code> is a <code>Buffer</code> and <code>rinfo</code> is
an object with the sender's address information and the number of bytes in the datagram.</p>
-->

<h3>イベント: 'listening'</h3>
<!--
<h3>Event: 'listening'</h3>
-->

<p><code>function () { }</code></p>

<p>ソケットでデータグラムの待ち受けを開始すると生成されます。
これは UDP ソケットが作成されるとすぐに発生します。
UNIX ドメインソケットでは <code>bind()</code> を呼び出すまで待ち受けを開始しません。</p>
<!--
<p>Emitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets
are created.  Unix domain sockets do not start listening until calling <code>bind()</code> on them.</p>
-->

<h3>イベント: 'close'</h3>
<!--
<h3>Event: 'close'</h3>
-->

<p><code>function () { }</code></p>

<p><code>close()</code> によってソケットがクローズすると生成されます。
このソケットでは新しい <code>message</code> イベントは生成されなくなります。</p>
<!--
<p>Emitted when a socket is closed with <code>close()</code>.  No new <code>message</code> events will be emitted
on this socket.</p>
-->

<h3>dgram.createSocket(type, [callback])</h3>

<p>指定された種類のデータグラムソケットを作成します。
妥当な種類は: <code>udp4</code>、<code>udp6</code>、そして<code>unix_dgram</code> です。</p>
<!--
<p>Creates a datagram socket of the specified types.  Valid types are:
<code>udp4</code>, <code>udp6</code>, and <code>unix_dgram</code>.  </p>
-->

<p>オプションのコールバックは <code>message</code> イベントのリスナーとして加えられます。</p>
<!--
<p>Takes an optional callback which is added as a listener for <code>message</code> events.</p>
-->

<h3>dgram.send(buf, offset, length, path, [callback])</h3>

<p>UNIX ドメインのデータグラムソケット用です。相手先のアドレスはファイルシステムのパス名です。
オプションのコールバックはOSによって<code>sendto</code>の呼び出しが完了した後に起動されるために提供されるかもしれません。
コールバックが呼び出されるまで <code>buf</code> の再利用は安全ではありません。
<code>bind()</code> によってソケットがパスネームにバインドされていない限り、
このソケットでメッセージを受信することはないことに注意してください。</p>
<!--
<p>For Unix domain datagram sockets, the destination address is a pathname in the filesystem.
An optional callback may be supplied that is invoked after the <code>sendto</code> call is completed
by the OS.  It is not safe to re-use <code>buf</code> until the callback is invoked.  Note that 
unless the socket is bound to a pathname with <code>bind()</code> there is no way to receive messages
on this socket.</p>
-->

<p>UNIXドメインソケット <code>/var/run/syslog</code> を通じて OSX 上の syslog にメッセージを送信する例:</p>
<!--
<p>Example of sending a message to syslogd on OSX via Unix domain socket <code>/var/run/syslog</code>:</p>
-->

<pre><code>var dgram = require('dgram');
var message = new Buffer("A message to log.");
var client = dgram.createSocket("unix_dgram");
client.send(message, 0, message.length, "/var/run/syslog",
  function (err, bytes) {
    if (err) {
      throw err;
    }
    console.log("Wrote " + bytes + " bytes to socket.");
});</code></pre>

<h3>dgram.send(buf, offset, length, port, address, [callback])</h3>

<p>UDP ソケット用です。相手先のポートと IP アドレスは必ず指定しなければなりません。
<code>address</code> パラメータに文字列を提供すると、それは DNS によって解決されます。
DNS エラーと <code>buf</code> が再利用可能になった時のためにオプションのコールバックを指定することができます。
DNS ルックアップは送信を少なくとも次の機会まで遅らせることに注意してください。
送信が行われたことを確実に知る唯一の手段はコールバックを使うことです。<p>
<!--
<p>For UDP sockets, the destination port and IP address must be specified.  A string
may be supplied for the <code>address</code> parameter, and it will be resolved with DNS.  An 
optional callback may be specified to detect any DNS errors and when <code>buf</code> may be
re-used.  Note that DNS lookups will delay the time that a send takes place, at
least until the next tick.  The only way to know for sure that a send has taken place
is to use the callback.</p>
-->

<p><code>localhost</code> の適当なポートに UDP パケットを送信する例;</p>
<!--
<p>Example of sending a UDP packet to a random port on <code>localhost</code>;</p>
-->

<pre><code>var dgram = require('dgram');
var message = new Buffer("Some bytes");
var client = dgram.createSocket("udp4");
client.send(message, 0, message.length, 41234, "localhost");
client.close();</code></pre>

<h3>dgram.bind(path)</h3>

<p>UNIX ドメインのデータグラムソケット用です。
<code>path</code> で指定されたソケット上でデータグラムの着信待ち受けを開始します。
クライアントは <code>bind()</code> しなくても <code>send()</code> することができますが、
<code>bind()</code> しないでデータグラムを受信することはありません。</p>
<!--
<p>For Unix domain datagram sockets, start listening for incoming datagrams on a
socket specified by <code>path</code>. Note that clients may <code>send()</code> without <code>bind()</code>,
but no datagrams will be received without a <code>bind()</code>.</p>
-->

<p>受信した全てのメッセージをエコーバックする UNIX ドメインのデータグラムソケットサーバの例:</p>
<!--
<p>Example of a Unix domain datagram server that echoes back all messages it receives:</p>
-->

<pre><code>var dgram = require("dgram");
var serverPath = "/tmp/dgram_server_sock";
var server = dgram.createSocket("unix_dgram");

server.on("message", function (msg, rinfo) {
  console.log("got: " + msg + " from " + rinfo.address);
  server.send(msg, 0, msg.length, rinfo.address);
});

server.on("listening", function () {
  console.log("server listening " + server.address().address);
})

server.bind(serverPath);</code></pre>

<p>このサーバと対話する UNIX ドメインのデータグラムクライアントの例:</p>
<!--
<p>Example of a Unix domain datagram client that talks to this server:</p>
-->

<pre><code>var dgram = require("dgram");
var serverPath = "/tmp/dgram_server_sock";
var clientPath = "/tmp/dgram_client_sock";

var message = new Buffer("A message at " + (new Date()));

var client = dgram.createSocket("unix_dgram");

client.on("message", function (msg, rinfo) {
  console.log("got: " + msg + " from " + rinfo.address);
});

client.on("listening", function () {
  console.log("client listening " + client.address().address);
  client.send(message, 0, message.length, serverPath);
});

client.bind(clientPath);</code></pre>

<h3>dgram.bind(port, [address])</h3>

<p>UDP ソケット用です。<code>port</code> とオプションの <code>address</code> でデータグラムを待ち受けます。
<code>address</code> が指定されなければ、OS は全てのアドレスからの待ち受けを試みます。</p>
<!--
<p>For UDP sockets, listen for datagrams on a named <code>port</code> and optional <code>address</code>.  If
<code>address</code> is not specified, the OS will try to listen on all addresses.</p>
-->

<p>41234 番ポートを待ち受ける UDP サーバの例:</p>
<!--
<p>Example of a UDP server listening on port 41234:</p>
-->

<pre><code>var dgram = require("dgram");

var server = dgram.createSocket("udp4");
var messageToSend = new Buffer("A message to send");

server.on("message", function (msg, rinfo) {
  console.log("server got: " + msg + " from " +
    rinfo.address + ":" + rinfo.port);
});

server.on("listening", function () {
  var address = server.address();
  console.log("server listening " +
      address.address + ":" + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>

<h3>dgram.close()</h3>

<p>下層のソケットをクローズし、データの待ち受けを終了します。
<code>bind()</code> が呼び出されていない、自動的にメッセージを待ち受けていた UDP ソケットでも同じです。</p>
<!--
<p>Close the underlying socket and stop listening for data on it.  UDP sockets 
automatically listen for messages, even if they did not call <code>bind()</code>.</p>
-->

<h3>dgram.address()</h3>

<p>オブジェクトが持っているソケットのアドレス情報を返します。
UDP ソケットでは、このオブジェクトは <code>address</code> と <code>port</code> を持っています。
UNIX ドメインソケットでは、<code>address</code> だけを持っています。</p>
<!--
<p>Returns an object containing the address information for a socket.  For UDP sockets, 
this object will contain <code>address</code> and <code>port</code>.  For Unix domain sockets, it will contain
only <code>address</code>.</p>
-->

<h3>dgram.setBroadcast(flag)</h3>

<p>ソケットのオプション <code>SO_BROADCAST</code> を設定またはクリアします。
このオプションが設定されると、UDP パケットはローカルインタフェースのブロードキャスト用アドレスに送信されます。</p>
<!--
<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When this option is set, UDP packets
may be sent to a local interface's broadcast address.</p>
-->

<h3>dgram.setTTL(ttl)</h3>

<p>ソケットオプションの <code>IP_TTL</code> を設定します。
TTL は「生存期間」を表しますが、このコンテキストではパケットが通過を許可される IP のホップ数を指定します。
各ルーターまたはゲートウェイはパケットを送出する際 TTL をデクリメントします。
ルータによって TTL がデクリメントされて 0 になるとそれは送出されません。
TTL 値の変更は通常、ネットワークの調査やマルチキャストで使われます。</p>
<!--
<p>Sets the <code>IP_TTL</code> socket option.  TTL stands for "Time to Live," but in this context it
specifies the number of IP hops that a packet is allowed to go through.  Each router or 
gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a
router, it will not be forwarded.  Changing TTL values is typically done for network 
probes or when multicasting.</p>
-->

<p><code>setTTL()</code> の引数は 1 から 255 のホップ数でです。ほとんどのシステムでデフォルトは 64 です。</p>
<!--
<p>The argument to <code>setTTL()</code> is a number of hops between 1 and 255.  The default on most
systems is 64.</p>
-->

<h2 id="Assert">表明</h2>
<!--
<h2 id="Assert">Assert</h2>
-->

<p>このモジュールはアプリケーションの単体テストを記述するために使用され、
<code>require('assert')</code> でアクセスできます。</p>
<!--
<p>This module is used for writing unit tests for your applications, you can
access it with <code>require('assert')</code>.</p>
-->

<h3>assert.fail(actual, expected, message, operator)</h3>

<p><code>actual</code> が <code>expected</code> と等しいか、提供された演算子を使ってテストします。</p>
<!--
<p>Tests if <code>actual</code> is equal to <code>expected</code> using the operator provided.</p>
-->

<h3>assert.ok(value, [message])</h3>

<p><code>value</code> が <code>true</code> かテストします、
これは <code>assert.equal(true, value, message);</code> と等価です。</p>
<!--
<p>Tests if value is a <code>true</code> value, it is equivalent to <code>assert.equal(true, value, message);</code></p>
-->

<h3>assert.equal(actual, expected, [message])</h3>

<p><code>==</code> 演算子を強制して浅い同値性をテストします。</p>
<!--
<p>Tests shallow, coercive equality with the equal comparison operator ( <code>==</code> ). </p>
-->

<h3>assert.notEqual(actual, expected, [message])</h3>

<p><code>==</code> 演算子を強制して浅い非同値性をテストします。</p>
<!--
<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).</p>
-->

<h3>assert.deepEqual(actual, expected, [message])</h3>

<p>深い同値性をテストします。</p>
<!--
<p>Tests for deep equality.</p>
-->

<h3>assert.notDeepEqual(actual, expected, [message])</h3>

<p>深い非同値性をテストします。</p>
<!--
<p>Tests for any deep inequality. </p>
-->

<h3>assert.strictEqual(actual, expected, [message])</h3>

<p><code>===</code> 演算子で厳密な同値性をテストします。</p>
<!--
<p>Tests strict equality, as determined by the strict equality operator ( <code>===</code> ) </p>
-->

<h3>assert.notStrictEqual(actual, expected, [message])</h3>

<p><code>!==</code> 演算子で厳密な非同値性をテストします。</p>
<!--
<p>Tests strict non-equality, as determined by the strict not equal operator ( <code>!==</code> ) </p>
-->

<h3>assert.throws(block, [error], [message])</h3>

<p><code>block</code> がエラーをスローすることを期待します。</p>
<!--
<p>Expects <code>block</code> to throw an error.</p>
-->

<h3>assert.doesNotThrow(block, [error], [message])</h3>

<p><code>block</code> がエラーをスローしないことを期待します。</p>
<!--
<p>Expects <code>block</code> not to throw an error.</p>
-->

<h3>assert.ifError(value)</h3>

<p><code>value</code> が false でないことをテストし、true だったらそれをスローします。
コールバックの第 1 引数である <code>error</code> をテストするのに便利です。</p>
<!--
<p>Tests if value is not a false value, throws if it is a true value. Useful when testing the first argument, <code>error</code> in callbacks.</p>
-->

<h2 id="Path">パス</h2>
<!--
<h2 id="Path">Path</h2>
-->

<p>このモジュールはファイルパスを扱うユーティリティを含みます。
利用するには<code>require('path')</code>を呼び出してください。このモジュールは以下のメソッドを提供します。</p>

<!--
<p>This module contains utilities for dealing with file paths.  Use
<code>require('path')</code> to use it.  It provides the following methods:</p>
-->

<h3>path.join([path1], [path2], [...])</h3>
<p>全ての引数を一つに結合し、結果として得られるパスを決定します。</p>
<!--
<p>Join all arguments together and resolve the resulting path.</p>
-->
<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>node&gt; require('path').join(
...   '/foo', 'bar', 'baz/asdf', 'quux', '..')
'/foo/bar/baz/asdf'</code></pre>

<h3>path.normalizeArray(arr)</h3>

<p>パスの要素の配列を正規化します。<code>'..'</code> と <code>'.'</code> の要素には注意してください。</p>
<!--
<p>Normalize an array of path parts, taking care of <code>'..'</code> and <code>'.'</code> parts.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>path.normalizeArray(['', 
  'foo', 'bar', 'baz', 'asdf', 'quux', '..'])
// 戻り値
[ '', 'foo', 'bar', 'baz', 'asdf' ]</code></pre>

<h3>path.normalize(p)</h3>

<p>文字列によるパスを正規化します。<code>'..'</code> と <code>'.'</code> の要素には注意してください。</p>
<!--
<p>Normalize a string path, taking care of <code>'..'</code> and <code>'.'</code> parts.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>path.normalize('/foo/bar/baz/asdf/quux/..')
// 戻り値
'/foo/bar/baz/asdf'</code></pre>

<h3>path.dirname(p)</h3>

<p>パスに含まれるディレクトリ名を返します。Unixの <code>dirname</code> コマンドと同様です。</p>
<!--
<p>Return the directory name of a path.  Similar to the Unix <code>dirname</code> command.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>path.dirname('/foo/bar/baz/asdf/quux')
// 戻り値
'/foo/bar/baz/asdf'</code></pre>

<h3>path.basename(p, [ext])</h3>

<p>パスの最後の要素を返します。Unixの <code>basename</code> コマンドと同様です。</p>
<!--
<p>Return the last portion of a path.  Similar to the Unix <code>basename</code> command.</p>
-->

<p>例:</p>
<!--
<p>Example:</p>
-->

<pre><code>path.basename('/foo/bar/baz/asdf/quux.html')
// 戻り値
'quux.html'

path.basename('/foo/bar/baz/asdf/quux.html', '.html')
// 戻り値
'quux'</code></pre>

<h3>path.extname(p)</h3>

<p>パスの拡張子を返します。パスの最後の要素について、最後の'.'から後にある文字列が対象になります。
最後の要素に'.'が含まれていなかった場合、もしくは'.'が最初の文字だった場合は、空の文字列を返します。例:</p>
<!--
<p>Return the extension of the path.  Everything after the last '.' in the last portion
of the path.  If there is no '.' in the last portion of the path or the only '.' is
the first character, then it returns an empty string.  Examples:</p>
-->

<pre><code>path.extname('index.html')
// 戻り値 
'.html'

path.extname('index')
// 戻り値
''</code></pre>

<h3>path.exists(p, [callback])</h3>

<p>与えられたパスが存在するかどうか検査します。そして引数の <code>callback</code> を真か偽か検査の結果とともに呼び出します。例:</p>
<!--
<p>Test whether or not the given path exists.  Then, call the <code>callback</code> argument with either true or false.  Example:</p>
-->

<pre><code>path.exists('/etc/passwd', function (exists) {
  sys.debug(exists ? "it's there" : "no passwd!");
});</code></pre>

<h2 id="URL">URL</h2>

<p>このモジュールはURLの解決や解析の為のユーティリティを持ちます。
利用するには <code>require('url')</code> を呼び出してください。</p>
<!--
<p>This module has utilities for URL resolution and parsing.
Call <code>require('url')</code> to use it.</p>
-->

<p>解析されたURLオブジェクトは、URL文字列の中に存在するかどうかに応じて
次に示すフィールドをいくつかもしくは全てを持ちます。
URL文字列に含まれないフィールドは解析結果のオブジェクトに含まれません。
次のURLで例を示します。</p>
<!--
<p>Parsed URL objects have some or all of the following fields, depending on
whether or not they exist in the URL string. Any parts that are not in the URL
string will not be in the parsed object. Examples are shown for the URL</p>
-->

<p><code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p>

<ul>
<li><p><code>href</code></p>
<p>解析する前の完全URL。 例:<br />
<code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p></li>
<li><p><code>protocol</code></p>
<p>リクエストプロトコル。  例: 
<code>'http:'</code></p></li>
<li><p><code>host</code></p>
<p>URLの完全なホスト情報。認証情報を含みます。 例:<br />
<code>'user:pass@host.com:8080'</code></p></li>
<li><p><code>auth</code></p>
<p>URLの認証情報。  例: 
<code>'user:pass'</code></p></li>
<li><p><code>hostname</code></p>
<p>ホスト情報の中のホスト名。 例: 
<code>'host.com'</code></p></li>
<li><p><code>port</code></p>
<p>ホスト情報の中のポート番号。 例: 
<code>'8080'</code></p></li>
<li><p><code>pathname</code></p>
<p>URLのパス部分。ホスト情報からクエリまでの間に位置し、最初にスラッシュが存在する場合はそれも含みます。例: 
<code>'/p/a/t/h'</code></p></li>
<li><p><code>search</code></p>
<p>URLのクエリ文字列。先頭の?マークも含みます。 例: 
<code>'?query=string'</code></p></li>
<li><p><code>query</code></p>
<p>クエリの変数部分の文字列、もしくはクエリ文字列を解析したオブジェクト。 例:<br />
<code>'query=string'</code> or <code>{'query':'string'}</code></p></li>
<li><p><code>hash</code></p>
<p>URLの#マークを含む部分。 例: <code>'#hash'</code></p></li></ul>

<!--
<ul><li><p><code>href</code></p><p>The full URL that was originally parsed. Example:
<code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p></li><li><p><code>protocol</code></p><p>The request protocol.  Example: <code>'http:'</code></p></li><li><p><code>host</code></p><p>The full host portion of the URL, including port and authentication information. Example:
<code>'user:pass@host.com:8080'</code></p></li><li><p><code>auth</code></p><p>The authentication information portion of a URL.  Example: <code>'user:pass'</code></p></li><li><p><code>hostname</code></p><p>Just the hostname portion of the host.  Example: <code>'host.com'</code></p></li><li><p><code>port</code></p><p>The port number portion of the host.  Example: <code>'8080'</code></p></li><li><p><code>pathname</code></p><p>The path section of the URL, that comes after the host and before the query, including the initial slash if present.  Example: <code>'/p/a/t/h'</code></p></li><li><p><code>search</code></p><p>The 'query string' portion of the URL, including the leading question mark. Example: <code>'?query=string'</code></p></li><li><p><code>query</code></p><p>Either the 'params' portion of the query string, or a querystring-parsed object. Example:
<code>'query=string'</code> or <code>{'query':'string'}</code></p></li><li><p><code>hash</code></p><p>The 'fragment' portion of the URL including the pound-sign. Example: <code>'#hash'</code></p></li></ul>
-->

<p>以下のメソッドはURLモジュールにより提供されます:</p>
<!--
<p>The following methods are provided by the URL module:</p>
-->

<h3>url.parse(urlStr, parseQueryString=false)</h3>

<p>URL文字列を引数に取り、解析結果のオブジェクトを返します。
<code>querystring</code>モジュールを使ってクエリ文字列も解析したい場合は、
第2引数に <code>true</code> を渡してください。
<!--
<p>Take a URL string, and return an object.  Pass <code>true</code> as the second argument to also parse
the query string using the <code>querystring</code> module.</p>
-->

<h3>url.format(urlObj)</h3>

<p>URLオブジェクトを引数に取り、フォーマットしたURL文字列を返します。</p>
<!--
<p>Take a parsed URL object, and return a formatted URL string.</p>
-->

<h3>url.resolve(from, to)</h3>

<p>ベースとなるURLと相対URLを引数に取り、ブラウザがアンカータグに対して行うのと同様にURLを解決します。</p>
<!--
<p>Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag.</p>
-->

<h2 id="Query String">クエリ文字列</h2>
<!--
<h2 id="Query String">Query String</h2>
-->
<p>このモジュールはクエリ文字列を処理するユーティリティを提供します。 以下のメソッドから成ります:</p>
<!--
<p>This module provides utilities for dealing with query strings.  It provides the following methods:</p>
-->

<h3>querystring.stringify(obj, sep='&amp;', eq='=', munge=true)</h3>

<p>クエリオブジェクトを文字列へ直列化します。オプションとしてデフォルトの区切り文字と代入文字を上書き指定できます。 例:</p>
<!--
<p>Serialize an object to a query string.  Optionally override the default separator and assignment characters.
Example:</p>
-->

<pre><code>querystring.stringify({foo: 'bar'})
// 戻り値
'foo=bar'

querystring.stringify({foo: 'bar', baz: 'bob'}, ';', ':')
// 戻り値
'foo:bar;baz:bob'</code></pre>

<p>この関数はデフォルトでPHP/Railsスタイルのようにパラメータに複雑な処理を行います。
配列やオブジェクトに対して <code>obj</code> に含まれる値を用いて処理を行います。 例:</p>
<!--
<p>By default, this function will perform PHP/Rails-style parameter munging for arrays and objects used as
values within <code>obj</code>.
Example:</p>
-->

<pre><code>querystring.stringify({foo: ['bar', 'baz', 'boz']})
// 戻り値
'foo%5B%5D=bar&amp;foo%5B%5D=baz&amp;foo%5B%5D=boz'

querystring.stringify({foo: {bar: 'baz'}})
// 戻り値
'foo%5Bbar%5D=baz'</code></pre>

<p>もし配列への複雑な処理を無効にしたい場合は (Javaサーブレット用にパラメータを生成する時など)、
引数の <code>munge</code> に対して <code>false</code> を設定することができます。例:</p>
<!--
<p>If you wish to disable the array munging (e.g. when generating parameters for a Java servlet), you
can set the <code>munge</code> argument to <code>false</code>.
Example:</p>
-->

<pre><code>querystring.stringify({foo: ['bar', 'baz', 'boz']}, '&amp;', '=', false)
// 戻り値
'foo=bar&amp;foo=baz&amp;foo=boz'</code></pre>

<p><code>munge</code> に <code>false</code> が設定されている時でも、 値にオブジェクトが設定されている場合は複雑に処理されたままであることに注意してください。</p>
<!--
<p>Note that when <code>munge</code> is <code>false</code>, parameter names with object values will still be munged.</p>
-->

<h3>querystring.parse(str, sep='&amp;', eq='=')</h3>

<p>クエリ文字列をオブジェクトに復元します。オプションとしてデフォルトの区切り文字と代入文字を上書き指定できます。</p>
<!--
<p>Deserialize a query string to an object.  Optionally override the default separator and assignment characters.</p>
-->

<pre><code>querystring.parse('a=b&amp;b=c')
// 戻り値
{ 'a': 'b'
, 'b': 'c'
}</code></pre>

<p>この関数は複雑化したクエリ文字列/していないクエリ文字列どちらに対しても解析することができます。 (詳細は <code>stringify</code> を参照)。</p>
<!--
<p>This function can parse both munged and unmunged query strings (see <code>stringify</code> for details).</p>
-->

<h3>querystring.escape</h3>

<p>escape関数は <code>querystring.stringify</code> で使用されていて、必要な場合にオーバーライドできるよう提供されています。</p>
<!--
<p>The escape function used by <code>querystring.stringify</code>, provided so that it could be overridden if necessary.</p>
-->

<h3>querystring.unescape</h3>

<p>unescape関数は <code>querystring.parse</code> で使用されていて、必要な場合にオーバーライドできるよう提供されています。</p>
<!--
<p>The unescape function used by <code>querystring.parse</code>, provided so that it could be overridden if necessary.</p>
-->

<h2 id="REPL">REPL</h2>

<p>Read-Eval-Print-Loop (REPL) は単独のプログラムとしても他のプログラムに手軽に取り込む形でも利用することができます。
REPLは対話的にJavaScriptを実行して結果を確認する手段を提供します。 
デバッグやテストやその他の様々なことを試す用途で利用されます。</p>
<!--
<p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily
includable in other programs.  REPL provides a way to interactively run
JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.</p>
-->

<p>コマンドラインから <code>node</code> を引数無しで実行することで、REPLプログラムに入ります。
REPLはEmacs風の簡易な行編集機能を備えています。</p>
<!--
<p>By executing <code>node</code> without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editing.</p>
-->

<pre><code>mjr:~$ node
Type '.help' for options.
node&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
node&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>

<p>より進んだ行編集を行うには、環境変数に <code>NODE_NO_READLINE=1</code> を設定してnodeを起動してください。
これによって正規の端末設定でREPLを起動し、<code>rlwrap</code> を有効にした状態でREPLを利用することができます。</p>
<!--
<p>For advanced line-editors, start node with the environmental variable <code>NODE_NO_READLINE=1</code>.
This will start the REPL in canonical terminal settings which will allow you to use with <code>rlwrap</code>.</p>
-->

<p>例として、bashrcファイルに以下のように設定を追加します:</p>
<!--
<p>For example, you could add this to your bashrc file:</p>
-->

<pre><code>alias node="env NODE_NO_READLINE=1 rlwrap node"</code></pre>

<h3>repl.start(prompt='node&gt; ', stream=process.openStdin())</h3>

<p><code>prompt</code> でプロンプト記号を、 <code>stream</code> でI/Oを引数に取ってREPLを起動します。
<code>prompt</code> は省略可能で、 デフォルトは <code>node&gt; </code> です。
<code>stream</code> は省略可能で、 デフォルトは <code>process.openStdin()</code>です。</p>
<!--
<p>Starts a REPL with <code>prompt</code> as the prompt and <code>stream</code> for all I/O.  <code>prompt</code>
is optional and defaults to <code>node&gt; </code>.  <code>stream</code> is optional and defaults to 
<code>process.openStdin()</code>.</p>
-->

<p>複数のREPLを起動した場合、同一のnodeインスタンスが実行されないことがあります。
それぞれのREPLはグローバルオブジェクトを共有しますが、I/Oは固有のものを持ちます。</p>
<!--
<p>Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.</p>
-->

<p>REPLを標準入力、Unixドメインソケット、TCPソケットのもとで起動する例を示します:</p>
<!--
<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:</p>
-->

<pre><code>var net = require("net"),
    repl = require("repl");

connections = 0;

repl.start("node via stdin&gt; ");

net.createServer(function (socket) {
  connections += 1;
  repl.start("node via Unix socket&gt; ", socket);
}).listen("/tmp/node-repl-sock");

net.createServer(function (socket) {
  connections += 1;
  repl.start("node via TCP socket&gt; ", socket);
}).listen(5001);</code></pre>

<p>このプログラムをコマンドラインから実行すると、標準入力のもとでREPLが起動します。
他のREPLクライアントはUnixドメインソケットかTCPソケットを介して接続することができます。
<code>telnet</code> がTCPソケットへの接続に便利です。
<code>socat</code> はUnixドメイン/TCP両方のソケットへの接続に利用できます。</p>
<!--
<p>Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. <code>telnet</code> is useful
for connecting to TCP sockets, and <code>socat</code> can be used to connect to both Unix and
TCP sockets.</p>
-->

<p>標準入力の代わりにUnixドメインソケットをベースとしたサーバからREPLを起動することによって、
再起動することなくnodeの常駐プロセスへ接続することができます。</p>
<!--
<p>By starting a REPL from a Unix socket-based server instead of stdin, you can 
connect to a long-running node process without restarting it.</p>
-->

<h3>REPLの特長</h3>
<!--
<h3>REPL Features</h3>
-->
<p>REPLの中で Control+D を実行すると終了します。複数行に渡る式を入力とすることができます。</p>
<!--
<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.</p>
-->

<p>特別な変数である <code>_</code> (アンダースコア) は一番最後の式の結果を保持します。</p>
<!--
<p>The special variable <code>_</code> (underscore) contains the result of the last expression.</p>
-->

<pre><code>node&gt; [ "a", "b", "c" ]
[ 'a', 'b', 'c' ]
node&gt; _.length 
3
node&gt; _ += 1
4</code></pre>

<p>REPLはグローバルスコープに存在する全ての変数にアクセス可能です。
それぞれの<code>REPLServer</code> に紐づく<code>context</code> オブジェクトに変数を付与することで、
明示的に変数を公開させることが可能です。 例:</p>
<!--
<p>The REPL provides access to any variables in the global scope. You can expose a variable 
to the REPL explicitly by assigning it to the <code>context</code> object associated with each
<code>REPLServer</code>.  For example:</p>
-->

<pre><code>// repl_test.js
var repl = require("repl"),
    msg = "message";

repl.start().context.m = msg;</code></pre>

<p><code>context</code> オブジェクトに設定された変数は、REPLの中ではローカルな変数として現れます:</p>
<!--
<p>Things in the <code>context</code> object appear as local within the REPL:</p>
-->

<pre><code>mjr:~$ node repl_test.js 
node&gt; m
'message'</code></pre>

<p>REPLには多くの特別なコマンドがあります:</p>
<!--
<p>There are a few special REPL commands:</p>
-->

<ul>
<li><p><code>.break</code> - 複数行に渡って式を入力している間に、途中で分からなくなったり完了させなくても良くなることがあります。<code>.break</code> で最初からやり直します。</p></li>
<li><p><code>.clear</code> - <code>context</code> オブジェクトを空の状態にリセットし、複数行に入力している式をクリアします。</p></li>
<li><p><code>.exit</code> - I/Oストリームを閉じ、REPLを終了させます。</p></li>
<li><p><code>.help</code> - このコマンドの一覧を表示します。</p></li>
</ul>

<!--
<ul><li><p><code>.break</code> - While inputting a multi-line expression, sometimes you get lost or just don't care 
about completing it.  <code>.break</code> will start over.</p></li><li><p><code>.clear</code> - Resets the <code>context</code> object to an empty object and clears any multi-line
 expression.</p></li><li><p><code>.exit</code> - Close the I/O stream, which will cause the REPL to exit.</p></li><li><p><code>.help</code> - Show this list of special commands.</
p></li></ul>
-->

<h2 id="Modules">Modules</h2>

<p>Node uses the CommonJS module system.</p>

<p>Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, <code>foo.js</code> loads the module
<code>circle.js</code> in the same directory.</p>

<p>The contents of <code>foo.js</code>:</p>

<pre><code>var circle = require('./circle');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));</code></pre>

<p>The contents of <code>circle.js</code>:</p>

<pre><code>var PI = 3.14;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>

<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and
<code>circumference()</code>.  To export an object, add to the special <code>exports</code>
object.  (Alternatively, one can use <code>this</code> instead of <code>exports</code>.) Variables
local to the module will be private. In this example the variable <code>PI</code> is
private to <code>circle.js</code>. The function <code>puts()</code> comes from the module <code>'sys'</code>,
which is a built-in module. Modules which are not prefixed by <code>'./'</code> are
built-in module--more about this later.</p>

<p>A module prefixed with <code>'./'</code> is relative to the file calling <code>require()</code>.
That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for
<code>require('./circle')</code> to find it.</p>

<p>Without the leading <code>'./'</code>, like <code>require('assert')</code> the module is searched
for in the <code>require.paths</code> array. <code>require.paths</code> on my system looks like
this: </p>

<p><code>[ '/home/ryan/.node_libraries' ]</code></p>

<p>That is, when <code>require('assert')</code> is called Node looks for: </p>

<ul><li>1: <code>/home/ryan/.node_libraries/assert.js</code></li><li>2: <code>/home/ryan/.node_libraries/assert.node</code></li><li>3: <code>/home/ryan/.node_libraries/assert/index.js</code></li><li>4: <code>/home/ryan/.node_libraries/assert/index.node</code></li></ul>

<p>interrupting once a file is found. Files ending in <code>'.node'</code> are binary Addon
Modules; see 'Addons' below. <code>'index.js'</code> allows one to package a module as
a directory.</p>

<p><code>require.paths</code> can be modified at runtime by simply unshifting new
paths onto it, or at startup with the <code>NODE_PATH</code> environmental
variable (which should be a list of paths, colon separated).</p>

<h2 id="Addons">Addons</h2>

<p>Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:</p>

<ul><li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:
creating objects, calling functions, etc.  Documented mostly in the
<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node source tree).</p></li><li><p>libev, C event loop library. Anytime one needs to wait for a file
descriptor to become readable, wait for a timer, or wait for a signal to
received one will need to interface with libev.  That is, if you perform
any I/O, libev will need to be used.  Node uses the <code>EV_DEFAULT</code> event
loop.  Documentation can be found http:/cvs.schmorp.de/libev/ev.html[here].</p></li><li><p>libeio, C thread pool library. Used to execute blocking POSIX system
calls asynchronously. Mostly wrappers already exist for such calls, in
<code>src/file.cc</code> so you will probably not need to use it. If you do need it,
look at the header file <code>deps/libeio/eio.h</code>.</p></li><li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code>
class which you will likely want to derive from.</p></li><li><p>Others. Look in <code>deps/</code> for what else is available.</p></li></ul>

<p>Node statically compiles all its dependencies into the executable. When
compiling your module, you don't need to worry about linking to any of these
libraries.</p>

<p>To get started let's make a small Addon which does the following except in
C++:</p>

<pre><code>exports.hello = 'world';</code></pre>

<p>To get started we create a file <code>hello.cc</code>:</p>

<pre><code>#include &lt;v8.h&gt;

using namespace v8;

extern "C" void
init (Handle&lt;Object&gt; target) 
{
  HandleScope scope;
  target-&gt;Set(String::New("hello"), String::New("World"));
}</code></pre>

<p>This source code needs to be built into <code>hello.node</code>, the binary Addon. To
do this we create a file called <code>wscript</code> which is python code and looks
like this:</p>

<pre><code>srcdir = '.'
blddir = 'build'
VERSION = '0.0.1'

def set_options(opt):
  opt.tool_options('compiler_cxx')

def configure(conf):
  conf.check_tool('compiler_cxx')
  conf.check_tool('node_addon')

def build(bld):
  obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
  obj.target = 'hello'
  obj.source = 'hello.cc'</code></pre>

<p>Running <code>node-waf configure build</code> will create a file
<code>build/default/hello.node</code> which is our Addon.</p>

<p><code>node-waf</code> is just http://code.google.com/p/waf/[WAF], the python-based build system. <code>node-waf</code> is
provided for the ease of users.</p>

<p>All Node addons must export a function called <code>init</code> with this signature:</p>

<pre><code>extern 'C' void init (Handle&lt;Object&gt; target)</code></pre>

<p>For the moment, that is all the documentation on addons. Please see
<a href="http://github.com/ry/node_postgres">http://github.com/ry/node_postgres</a> for a real example.</p>

<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</div>
<script type="text/javascript" src="./jquery.js"></script>
<script type="text/javascript" src="./sh_main.js"></script>
<script type="text/javascript" src="./sh_javascript.min.js"></script>
<script type="text/javascript" src="./doc.js"></script>
</body>
</html>
