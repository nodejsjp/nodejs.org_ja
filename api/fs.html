<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>fs - Node.js v0.7.1 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/docs/latest/api/fs.html">
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js v0.7.1 Manual &amp; Documentation</h1>
      <div id="gtoc">
        <p><a href="index.html">Index</a> | <a href="all.html">View on single page</a></p>
      </div>
      <hr>
    </header>
    <div id="toc"><h2>Table Of Contents</h2><ul><li><a href="#file_System">File System</a><ul><li><a href="#fs.rename">fs.rename(path1, path2, [callback])</a></li><li><a href="#fs.renameSync">fs.renameSync(path1, path2)</a></li><li><a href="#fs.truncate">fs.truncate(fd, len, [callback])</a></li><li><a href="#fs.truncateSync">fs.truncateSync(fd, len)</a></li><li><a href="#fs.chown">fs.chown(path, uid, gid, [callback])</a></li><li><a href="#fs.chownSync">fs.chownSync(path, uid, gid)</a></li><li><a href="#fs.fchown">fs.fchown(fd, uid, gid, [callback])</a></li><li><a href="#fs.fchownSync">fs.fchownSync(fd, uid, gid)</a></li><li><a href="#fs.lchown">fs.lchown(path, uid, gid, [callback])</a></li><li><a href="#fs.lchownSync">fs.lchownSync(path, uid, gid)</a></li><li><a href="#fs.chmod">fs.chmod(path, mode, [callback])</a></li><li><a href="#fs.chmodSync">fs.chmodSync(path, mode)</a></li><li><a href="#fs.fchmod">fs.fchmod(fd, mode, [callback])</a></li><li><a href="#fs.fchmodSync">fs.fchmodSync(fd, mode)</a></li><li><a href="#fs.lchmod">fs.lchmod(path, mode, [callback])</a></li><li><a href="#fs.lchmodSync">fs.lchmodSync(path, mode)</a></li><li><a href="#fs.stat">fs.stat(path, [callback])</a></li><li><a href="#fs.lstat">fs.lstat(path, [callback])</a></li><li><a href="#fs.fstat">fs.fstat(fd, [callback])</a></li><li><a href="#fs.statSync">fs.statSync(path)</a></li><li><a href="#fs.lstatSync">fs.lstatSync(path)</a></li><li><a href="#fs.fstatSync">fs.fstatSync(fd)</a></li><li><a href="#fs.link">fs.link(srcpath, dstpath, [callback])</a></li><li><a href="#fs.linkSync">fs.linkSync(srcpath, dstpath)</a></li><li><a href="#fs.symlink">fs.symlink(linkdata, path, [type], [callback])</a></li><li><a href="#fs.symlinkSync">fs.symlinkSync(linkdata, path, [type])</a></li><li><a href="#fs.readlink">fs.readlink(path, [callback])</a></li><li><a href="#fs.readlinkSync">fs.readlinkSync(path)</a></li><li><a href="#fs.realpath">fs.realpath(path, [callback])</a></li><li><a href="#fs.realpathSync">fs.realpathSync(path)</a></li><li><a href="#fs.unlink">fs.unlink(path, [callback])</a></li><li><a href="#fs.unlinkSync">fs.unlinkSync(path)</a></li><li><a href="#fs.rmdir">fs.rmdir(path, [callback])</a></li><li><a href="#fs.rmdirSync">fs.rmdirSync(path)</a></li><li><a href="#fs.mkdir">fs.mkdir(path, [mode], [callback])</a></li><li><a href="#fs.mkdirSync">fs.mkdirSync(path, [mode])</a></li><li><a href="#fs.readdir">fs.readdir(path, [callback])</a></li><li><a href="#fs.readdirSync">fs.readdirSync(path)</a></li><li><a href="#fs.close">fs.close(fd, [callback])</a></li><li><a href="#fs.closeSync">fs.closeSync(fd)</a></li><li><a href="#fs.open">fs.open(path, flags, [mode], [callback])</a></li><li><a href="#fs.openSync">fs.openSync(path, flags, [mode])</a></li><li><a href="#fs.utimes">fs.utimes(path, atime, mtime, [callback])</a></li><li><a href="#fs.utimesSync">fs.utimesSync(path, atime, mtime)</a></li><li><a href="#fs.futimes">fs.futimes(fd, atime, mtime, [callback])</a></li><li><a href="#fs.futimesSync">fs.futimesSync(fd, atime, mtime)</a></li><li><a href="#fs.fsync">fs.fsync(fd, [callback])</a></li><li><a href="#fs.fsyncSync">fs.fsyncSync(fd)</a></li><li><a href="#fs.write">fs.write(fd, buffer, offset, length, position, [callback])</a></li><li><a href="#fs.writeSync">fs.writeSync(fd, buffer, offset, length, position)</a></li><li><a href="#fs.writeSync">fs.writeSync(fd, str, position, [encoding])</a></li><li><a href="#fs.read">fs.read(fd, buffer, offset, length, position, [callback])</a></li><li><a href="#fs.readSync">fs.readSync(fd, buffer, offset, length, position)</a></li><li><a href="#fs.readSync">fs.readSync(fd, length, position, encoding)</a></li><li><a href="#fs.readFile">fs.readFile(filename, [encoding], [callback])</a></li><li><a href="#fs.readFileSync">fs.readFileSync(filename, [encoding])</a></li><li><a href="#fs.writeFile">fs.writeFile(filename, data, [encoding], [callback])</a></li><li><a href="#fs.writeFileSync">fs.writeFileSync(filename, data, [encoding])</a></li><li><a href="#fs.appendFile">fs.appendFile(filename, data, encoding='utf8', [callback])</a></li><li><a href="#fs.appendFileSync">fs.appendFileSync(filename, data, encoding='utf8')</a></li><li><a href="#fs.watchFile">fs.watchFile(filename, [options], listener)</a></li><li><a href="#fs.unwatchFile">fs.unwatchFile(filename)</a></li><li><a href="#fs.watch">fs.watch(filename, [options], listener)</a></li><li><a href="#fs.exists">fs.exists(p, [callback])</a></li><li><a href="#fs.existsSync">fs.existsSync(p)</a></li></ul></li><li><a href="#fs.Stats">fs.Stats</a></li><li><a href="#fs.ReadStream">fs.ReadStream</a><ul><li><a href="#event_open_">Event: 'open'</a></li><li><a href="#fs.createReadStream">fs.createReadStream(path, [options])</a></li></ul></li><li><a href="#fs.WriteStream">fs.WriteStream</a><ul><li><a href="#event_open_">Event: 'open'</a></li><li><a href="#file.bytesWritten">file.bytesWritten</a></li><li><a href="#fs.createWriteStream">fs.createWriteStream(path, [options])</a></li></ul></li><li><a href="#fs.FSWatcher">fs.FSWatcher</a><ul><li><a href="#watcher.close">watcher.close()</a></li><li><a href="#event_change_">Event: 'change'</a></li><li><a href="#event_error_">Event: 'error'</a></li></ul></li></ul></li></ul><hr /></div>
<h2 id="file_System">File System</h2>

<p>File I/O は POSIX 標準の関数に対する単純なラッパーとして提供されます。
このモジュールを使用するには <code>require('fs')</code> してください。
全てのメソッドは非同期と同期の形式があります。</p>

<p>非同期の形式は常に最後の引数として完了コールバックを受け取ります。
引数として渡される完了コールバックはメソッドに依存しますが、
最初の引数は常に例外のために予約されています。
操作が成功で完了すると最初の引数は <code>null</code> または <code>undefined</code> となります</p>

<p>同期の形式では、全ての例外はすぐにスローされます。
例外は try/catch で捕まえることも、そのまま通過させることもできます。</p>

<p>非同期バージョンの例です:</p>

<pre><code>var fs = require('fs');

fs.unlink('/tmp/hello', function (err) {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});</code></pre>

<p>同期バージョンです:</p>

<pre><code>var fs = require('fs');

fs.unlinkSync('/tmp/hello')
console.log('successfully deleted /tmp/hello');</code></pre>

<p>非同期メソッドでは順序の保証はありません。
以下のような傾向のエラーがあります。</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  console.log('renamed complete');
});
fs.stat('/tmp/world', function (err, stats) {
  if (err) throw err;
  console.log('stats: ' + JSON.stringify(stats));
});</code></pre>

<p><code>fs.stat</code> は <code>fs.rename</code> より先に実行される可能性がありrます。
正しい方法はコールバックをチェーンすることです。</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  fs.stat('/tmp/world', function (err, stats) {
    if (err) throw err;
    console.log('stats: ' + JSON.stringify(stats));
  });
});</code></pre>

<p>忙しいプロセスでは、プログラマはこれらの非同期バージョンを使うことが<em>強く推奨</em>されます。
同期バージョンはそれが完了するまでプロセス全体をブロックします － 全ての接続を停止します。</p>

<p>ファイル名には相対パスを使うことが出来ます。しかし、このパスは
<code>process.cwd()</code> からの相対パスであることを思い出してください。</p>

<h3 id="fs.rename">fs.rename(path1, path2, [callback]) <a href="#fs.rename">#</a></h3>

<p>非同期の rename(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.renameSync">fs.renameSync(path1, path2) <a href="#fs.renameSync">#</a></h3>

<p>同期の rename(2)。</p>

<h3 id="fs.truncate">fs.truncate(fd, len, [callback]) <a href="#fs.truncate">#</a></h3>

<p>非同期の ftruncate(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.truncateSync">fs.truncateSync(fd, len) <a href="#fs.truncateSync">#</a></h3>

<p>同期の ftruncate(2)。</p>

<h3 id="fs.chown">fs.chown(path, uid, gid, [callback]) <a href="#fs.chown">#</a></h3>

<p>非同期の chown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.chownSync">fs.chownSync(path, uid, gid) <a href="#fs.chownSync">#</a></h3>

<p>同期の chown(2)。</p>

<h3 id="fs.fchown">fs.fchown(fd, uid, gid, [callback]) <a href="#fs.fchown">#</a></h3>

<p>非同期の fchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.fchownSync">fs.fchownSync(fd, uid, gid) <a href="#fs.fchownSync">#</a></h3>

<p>同期の fchown(2)。</p>

<h3 id="fs.lchown">fs.lchown(path, uid, gid, [callback]) <a href="#fs.lchown">#</a></h3>

<p>非同期の lchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.lchownSync">fs.lchownSync(path, uid, gid) <a href="#fs.lchownSync">#</a></h3>

<p>同期の lchown(2)。</p>

<h3 id="fs.chmod">fs.chmod(path, mode, [callback]) <a href="#fs.chmod">#</a></h3>

<p>非同期の chmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.chmodSync">fs.chmodSync(path, mode) <a href="#fs.chmodSync">#</a></h3>

<p>同期の chmod(2)。</p>

<h3 id="fs.fchmod">fs.fchmod(fd, mode, [callback]) <a href="#fs.fchmod">#</a></h3>

<p>非同期の fchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.fchmodSync">fs.fchmodSync(fd, mode) <a href="#fs.fchmodSync">#</a></h3>

<p>同期の fchmod(2)。</p>

<h3 id="fs.lchmod">fs.lchmod(path, mode, [callback]) <a href="#fs.lchmod">#</a></h3>

<p>非同期の lchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.lchmodSync">fs.lchmodSync(path, mode) <a href="#fs.lchmodSync">#</a></h3>

<p>同期の lchmod(2)。</p>

<h3 id="fs.stat">fs.stat(path, [callback]) <a href="#fs.stat">#</a></h3>

<p>非同期の stat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <a href="#fs.Stats">fs.Stats</a> オブジェクトです。
詳細は <a href="#fs.Stats">fs.Stats</a> の節を参照してください。</p>

<p>より詳しくは後述の <a href="#fs.Stats">fs.Stats</a> の節を参照してください。</p>

<h3 id="fs.lstat">fs.lstat(path, [callback]) <a href="#fs.lstat">#</a></h3>

<p>非同期の lstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。
<code>lstat()</code> はパスがシンボリックリンクだった場合に、
参照先のファイルではなくそのリンク自身が調べられる点を除いて <code>stat()</code> と同じす。</p>

<h3 id="fs.fstat">fs.fstat(fd, [callback]) <a href="#fs.fstat">#</a></h3>

<p>非同期の fstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code> で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。
状態を取得するファイルをファイル記述子 <code>fd</code> で指定することを除いて、
<code>fstat()</code> は <code>stat()</code> と同じです。</p>

<h3 id="fs.statSync">fs.statSync(path) <a href="#fs.statSync">#</a></h3>

<p>同期の stat(2)。<code>fs.Stats</code> のインスタンスを返します。</p>

<h3 id="fs.lstatSync">fs.lstatSync(path) <a href="#fs.lstatSync">#</a></h3>

<p>同期の lstat(2)。<code>fs.Stats</code> のインスタンスを返します。</p>

<h3 id="fs.fstatSync">fs.fstatSync(fd) <a href="#fs.fstatSync">#</a></h3>

<p>同期の fstat(2)。<code>fs.Stats</code> のインスタンスを返します。</p>

<h3 id="fs.link">fs.link(srcpath, dstpath, [callback]) <a href="#fs.link">#</a></h3>

<p>非同期の link(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.linkSync">fs.linkSync(srcpath, dstpath) <a href="#fs.linkSync">#</a></h3>

<p>同期の link(2)。</p>

<h3 id="fs.symlink">fs.symlink(linkdata, path, [type], [callback]) <a href="#fs.symlink">#</a></h3>

<p>非同期の symlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。
<code>type</code> 引数は <code>'dir'</code> または <code>'file'</code> (デフォルトは <code>'file'</code>) です。
これは Windows でのみ使われます (他のプラットフォームでは無視されます)。</p>

<h3 id="fs.symlinkSync">fs.symlinkSync(linkdata, path, [type]) <a href="#fs.symlinkSync">#</a></h3>

<p>同期の symlink(2)。</p>

<h3 id="fs.readlink">fs.readlink(path, [callback]) <a href="#fs.readlink">#</a></h3>

<p>非同期の readlink(2)。コールバックは 2 つの引数を受け取る <code>(err, linkString)</code>です。</p>

<h3 id="fs.readlinkSync">fs.readlinkSync(path) <a href="#fs.readlinkSync">#</a></h3>

<p>同期の readlink(2)。シンボリックリンクの持つ文字列値を返します。</p>

<h3 id="fs.realpath">fs.realpath(path, [callback]) <a href="#fs.realpath">#</a></h3>

<p>非同期の realpath(2)。コールバックは 2 つの引数を受け取る <code>(err, resolvedPath)</code>です。
相対パスを解決するために <code>process.cwd</code> を使用することができます。</p>

<h3 id="fs.realpathSync">fs.realpathSync(path) <a href="#fs.realpathSync">#</a></h3>

<p>同期の realpath(2)。解決されたパスを返します。</p>

<h3 id="fs.unlink">fs.unlink(path, [callback]) <a href="#fs.unlink">#</a></h3>

<p>非同期の unlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.unlinkSync">fs.unlinkSync(path) <a href="#fs.unlinkSync">#</a></h3>

<p>同期の unlink(2)。</p>

<h3 id="fs.rmdir">fs.rmdir(path, [callback]) <a href="#fs.rmdir">#</a></h3>

<p>非同期の rmdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.rmdirSync">fs.rmdirSync(path) <a href="#fs.rmdirSync">#</a></h3>

<p>同期の rmdir(2)。</p>

<h3 id="fs.mkdir">fs.mkdir(path, [mode], [callback]) <a href="#fs.mkdir">#</a></h3>

<p>非同期の mkdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。
<code>mode</code> のデフォルトは <code>0777</code> です。</p>

<h3 id="fs.mkdirSync">fs.mkdirSync(path, [mode]) <a href="#fs.mkdirSync">#</a></h3>

<p>同期の mkdir(2)。</p>

<h3 id="fs.readdir">fs.readdir(path, [callback]) <a href="#fs.readdir">#</a></h3>

<p>非同期の readdir(3)。ディレクトリの内容を読み込みます。
コールバックは 2 つの引数を受け取る <code>(err, files)</code>で、
<code>files</code> は <code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列です。</p>

<h3 id="fs.readdirSync">fs.readdirSync(path) <a href="#fs.readdirSync">#</a></h3>

<p>同期の readdir(3)。<code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列を返します。</p>

<h3 id="fs.close">fs.close(fd, [callback]) <a href="#fs.close">#</a></h3>

<p>非同期の close(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.closeSync">fs.closeSync(fd) <a href="#fs.closeSync">#</a></h3>

<p>同期の close(2)。</p>

<h3 id="fs.open">fs.open(path, flags, [mode], [callback]) <a href="#fs.open">#</a></h3>

<p>非同期のファイルオープン。open(2) を参照してください。
フラグは以下になります:</p>

<ul><li><p><code>'r'</code> - 読み込み専用でオープンします。
ファイルが存在しない場合は例外が発生します。</p></li><li><p><code>'r+'</code> - 読み書き両用でオープンします。
ファイルが存在しない場合は例外が発生します。</p></li><li><p><code>'w'</code> - 書き込み専用でオープンします。
ファイルは作成される (存在しない場合) または長さ 0 に切り詰められます
(存在する場合)。</p></li><li><p><code>'r+'</code> - 読み書き両用でオープンします。
ファイルは作成される (存在しない場合) または長さ 0 に切り詰められます
(存在する場合)。</p></li><li><p><code>'a'</code> - 追記用でオープンします。
ファイルが存在しない場合は作成されます。</p></li><li><p><code>'a+'</code> - 読み込みおよび追記用でオープンします。
ファイルが存在しない場合は作成されます。</p></li></ul>

<p><code>mode</code> のデフォルトは 0666 です。
コールバックは 2 つの引数を受け取る <code>(err, fd)</code>です。</p>

<h3 id="fs.openSync">fs.openSync(path, flags, [mode]) <a href="#fs.openSync">#</a></h3>

<p>同期の open(2)。</p>

<h3 id="fs.utimes">fs.utimes(path, atime, mtime, [callback]) <a href="#fs.utimes">#</a></h3>

<h3 id="fs.utimesSync">fs.utimesSync(path, atime, mtime) <a href="#fs.utimesSync">#</a></h3>

<p>渡されたパスが参照するファイルのタイムスタンプを変更します。</p>

<h3 id="fs.futimes">fs.futimes(fd, atime, mtime, [callback]) <a href="#fs.futimes">#</a></h3>

<h3 id="fs.futimesSync">fs.futimesSync(fd, atime, mtime) <a href="#fs.futimesSync">#</a></h3>

<p>渡されたファイル記述子が参照するファイルのタイムスタンプを変更します。</p>

<h3 id="fs.fsync">fs.fsync(fd, [callback]) <a href="#fs.fsync">#</a></h3>

<p>非同期の fsync(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。</p>

<h3 id="fs.fsyncSync">fs.fsyncSync(fd) <a href="#fs.fsyncSync">#</a></h3>

<p>同期の fsync(2)。</p>

<h3 id="fs.write">fs.write(fd, buffer, offset, length, position, [callback]) <a href="#fs.write">#</a></h3>

<p><code>fd</code> で指定されたファイルに <code>buffer</code> を書き込みます。</p>

<p><code>position</code> はデータが書き込まれる位置をファイルの先頭からのオフセットで示します。
<code>position</code> が <code>null</code> の場合、データは現在の位置から書き込まれます。
pwrite(2) を参照してください。</p>

<p>コールバックは 3 つの引数が与えられる <code>(err, written, buffer)</code> で、
<code>written</code> は <code>buffer</code> から書き込まれた<em>バイト数</em>を示します。</p>

<p>同じファイルに対してコールバックされるのを待つことなく <code>fs.write()</code> を何度も呼び出すことは、安全ではないことに注意してください。
このシナリオでは、 <code>fs.createWriteStream()</code> を強く推奨します。</p>

<h3 id="fs.writeSync">fs.writeSync(fd, buffer, offset, length, position) <a href="#fs.writeSync">#</a></h3>

<p>同期版のバッファに基づく <code>fs.write()</code>。書き込まれたバイト数を返します。</p>

<h3 id="fs.writeSync">fs.writeSync(fd, str, position, [encoding]) <a href="#fs.writeSync">#</a></h3>

<p>同期版の文字列に基づく <code>fs.write()</code>。
<code>encoding</code> のデフォルトは <code>'utf8'</code> です。
書き込まれたバイト数を返します。</p>

<h3 id="fs.read">fs.read(fd, buffer, offset, length, position, [callback]) <a href="#fs.read">#</a></h3>

<p><code>fd</code> で指定されたファイルからデータを読み込みます。</p>

<p><code>buffer</code> はデータが書き込まれるバッファです。</p>

<p><code>offset</code> は書き込みを開始するバッファ内のオフセットです。</p>

<p><code>length</code> は読み込むバイト数を指定する整数です。</p>

<p><code>position</code> はファイルの読み込みを開始する位置を指定する整数です。
<code>position</code> が <code>null</code> の場合、データは現在の位置から読み込まれます。</p>

<p>コールバックは3つの引数が与えられる <code>(err, bytesRead, buffer)</code> です。</p>

<h3 id="fs.readSync">fs.readSync(fd, buffer, offset, length, position) <a href="#fs.readSync">#</a></h3>

<p>同期版のバッファに基づく <code>fs.read</code>。<code>bytesRead</code> の数を返します。</p>

<h3 id="fs.readSync">fs.readSync(fd, length, position, encoding) <a href="#fs.readSync">#</a></h3>

<p>同期版の文字列に基づく <code>fs.read</code>。<code>bytesRead</code> の数を返します。</p>

<h3 id="fs.readFile">fs.readFile(filename, [encoding], [callback]) <a href="#fs.readFile">#</a></h3>

<p>ファイル全体の内容を非同期に読み込みます。例:</p>

<pre><code>fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>

<p>コールバックは 2 つの引数が渡される <code>(err, data)</code> で、<code>data</code> はファイルの内容です。</p>

<p>エンコーディングが指定されなければ、生のバッファが渡されます。</p>

<h3 id="fs.readFileSync">fs.readFileSync(filename, [encoding]) <a href="#fs.readFileSync">#</a></h3>

<p>同期版の <code>fs.readFile</code>。<code>filename</code> の内容を返します。</p>

<p><code>encoding</code> が指定されるとこの関数は文字列を返します。
そうでなければバッファを返します。</p>

<h3 id="fs.writeFile">fs.writeFile(filename, data, [encoding], [callback]) <a href="#fs.writeFile">#</a></h3>

<p>非同期にデータをファイルに書き込みます。
ファイルが既に存在する場合は置き換えられます。
<code>data</code> は文字列またはバッファです。
<code>data</code> がバッファの場合、<code>encoding</code> は無視されます。
デフォルトは <code>'utf8'</code> です。</p>

<p>例:</p>

<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {
  if (err) throw err;
  console.log('It\'s saved!');
});</code></pre>

<h3 id="fs.writeFileSync">fs.writeFileSync(filename, data, [encoding]) <a href="#fs.writeFileSync">#</a></h3>

<p>同期版の <code>fs.writeFile</code>。</p>

<h3 id="fs.appendFile">fs.appendFile(filename, data, encoding='utf8', [callback]) <a href="#fs.appendFile">#</a></h3>

<p>非同期にデータをファイルに追加します。
ファイルが存在しなければ作成されます。
<code>data</code> は文字列またはバッファです。
<code>data</code> がバッファの場合、<code>encoding</code> は無視されます。
デフォルトは <code>'utf8'</code> です。</p>

<p>例:</p>

<pre><code>fs.appendFile('message.txt', 'data to append', function (err) {
  if (err) throw err;
  console.log('The "data to append" was appended to file!');
});</code></pre>

<h3 id="fs.appendFileSync">fs.appendFileSync(filename, data, encoding='utf8') <a href="#fs.appendFileSync">#</a></h3>

<p>同期版の <code>fs.appendFile</code>。</p>

<h3 id="fs.watchFile">fs.watchFile(filename, [options], listener) <a href="#fs.watchFile">#</a></h3>

<p><code>filename</code> の変更を監視します。コールバックの <code>listener</code> はファイルがアクセスされる度に呼び出されます。</p>

<p>第 2 引数はオプションです．
<code>options</code> が与えられる場合、それは boolean の <code>persistent</code> と <code>interval</code>
の二つのメンバを含むオブジェクトです。
<code>persistent</code> はファイルが監視されている間、
プロセスが実行し続けることを示します。
<code>interval</code> は対象をポーリングする間隔をミリ秒で示します
(inotify を備えた Linux システムでは <code>interval</code> は無視されます)。
デフォルトは <code>{ persistent: true, interval: 0}</code> です。</p>

<p><code>listener</code> は現在の状態オブジェクトと前の状態オブジェクトの 2 つの引数を受け取ります:</p>

<pre><code>fs.watchFile('message.text', function (curr, prev) {
  console.log('the current mtime is: ' + curr.mtime);
  console.log('the previous mtime was: ' + prev.mtime);
});</code></pre>

<p>これらの状態オブジェクトは <code>fs.Stat</code> のインスタンスです。</p>

<p>もしファイルがアクセスされただけでなく、変更された時の通知が必要であれば、<code>curr.mtime</code> と <code>prev.mtime</code> を比較する必要があります。</p>

<h3 id="fs.unwatchFile">fs.unwatchFile(filename) <a href="#fs.unwatchFile">#</a></h3>

<p><code>filename</code> の変更に対する監視を終了します。</p>

<h3 id="fs.watch">fs.watch(filename, [options], listener) <a href="#fs.watch">#</a></h3>

<p><code>filename</code> の変更を監視します。
<code>filename</code> はファイルまたはディレクトリのどちらかです。
戻り値のオブジェクトは <a href="#fs.FSWatcher">fs.FSWatcher</a> です。</p>

<p>第 2 引数はオプションです。
もし指定されるなら、<code>options</code> は boolean の <code>persistent</code> プロパティを
持つオブジェクトであるべきです。
<code>persistent</code> はファイルが監視されている間、
プロセスが実行し続けることを示します。
デフォルトは <code>{ persistent: true }</code> です。</p>

<p>リスナーコールバックは二つの引数 <code>(event, filename)</code> を与えられます。
<code>event</code> は <code>'rename'</code> または <code>'change'</code>、そして <code>filename</code> はイベントを
引き起こしたファイルの名前です。</p>

<p><strong>*警告:</strong>*
コールバックに提供される <code>filename</code> 引数は、
全てのプラットフォームでサポートされるわけではありません
(現時点では Linux と Windows でのみサポートされます)。
サポートされるプラットフォームであっても、<code>filename</code> が常に提供されることが
保証されているわけではありません。
そのため、コールバックは <code>filename</code> 引数が常に提供されると仮定せず、
それが <code>null</code> だったときの代替手段を持つべきです。</p>

<pre><code>fs.watch('somedir', function (event, filename) {
  console.log('event is: ' + event);
  if (filename) {
    console.log('filename provided: ' + filename);
  } else {
    console.log('filename not provided');
  }
});</code></pre>

<h3 id="fs.exists">fs.exists(p, [callback]) <a href="#fs.exists">#</a></h3>

<p>与えられたパスがファイルシステム上に存在するかどうか検査します。
そして引数の <code>callback</code> を真か偽か検査の結果とともに呼び出します。
例:</p>

<pre><code>fs.exists('/etc/passwd', function (exists) {
  util.debug(exists ? "it's there" : "no passwd!");
});</code></pre>

<h3 id="fs.existsSync">fs.existsSync(p) <a href="#fs.existsSync">#</a></h3>

<p>同期版の <code>fs.exists</code> です。</p>

<h2 id="fs.Stats">fs.Stats</h2>

<p><code>fs.stat()</code>、<code>fs.lstat()</code>、<code>fs.fstat()</code>、そしてそれらの同期版 から返される
オブジェクトはこの型です。</p>

<ul><li><code>stats.isFile()</code></li><li><code>stats.isDirectory()</code></li><li><code>stats.isBlockDevice()</code></li><li><code>stats.isCharacterDevice()</code></li><li><code>stats.isSymbolicLink()</code> (<code>fs.lstat()</code> でのみ有効)</li><li><code>stats.isFIFO()</code></li><li><code>stats.isSocket()</code></li></ul>

<p><code>util.inspect(stats)</code> は通常のファイルに対して次のような文字列を返します。</p>

<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>

<p><code>atime</code>、<code>mtime</code>、そして <code>ctime</code> は <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> オブジェクトであり、
その値を比較するには適切な方法があるということに注意してください。
もっとも一般的に使われる <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> は <em>1970 年 1 月
1 日</em>からの経過時間をミリ秒単位で返します。
それは比較には十分ですが、曖昧な情報を表示するには別の方法を使ってください。
より詳しい情報は <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> で探すことができます。</p>

<h2 id="fs.ReadStream">fs.ReadStream</h2>

<p><code>ReadStream</code> は <a href="streams.html#readable_Stream">Readable Stream</a> です。</p>

<h3 id="event_open_">Event: 'open' <a href="#event_open_">#</a></h3>

<p><code>function (fd) { }</code></p>

<p><code>fd</code> は ReadStream に使われているファイル記述子です。</p>

<h3 id="fs.createReadStream">fs.createReadStream(path, [options]) <a href="#fs.createReadStream">#</a></h3>

<p>新しい ReadStream オブジェクトを返します (<code>Readable Stream</code> を参照してください)。</p>

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:</p>

<pre><code>{ flags: 'r',
  encoding: null,
  fd: null,
  mode: 0666,
  bufferSize: 64 * 1024
}</code></pre>

<p>ファイル全体を読み込む代わりに一部の範囲を読み込むため、
<code>options</code> に <code>start</code> および <code>end</code> を含めることができます。
<code>start</code> と <code>end</code> はどちらも包含的で0から始まります。</p>

<p>100 バイトの長さを持つファイルの最後の 10 バイトを読み込む例:</p>

<pre><code>fs.createReadStream('sample.txt', {start: 90, end: 99});</code></pre>

<h2 id="fs.WriteStream">fs.WriteStream</h2>

<p><code>WriteStream</code> は <a href="streams.html#writable_Stream">Writable Stream</a> です。</p>

<h3 id="event_open_">Event: 'open' <a href="#event_open_">#</a></h3>

<p><code>function (fd) { }</code></p>

<p><code>fd</code> は WriteStream に使われているファイル記述子です。</p>

<h3 id="file.bytesWritten">file.bytesWritten <a href="#file.bytesWritten">#</a></h3>

<p>これまでに書き込まれたバイト数。
書き込みがキューイングされたままのデータは含まれません。</p>

<h3 id="fs.createWriteStream">fs.createWriteStream(path, [options]) <a href="#fs.createWriteStream">#</a></h3>

<p>新しい WriteStream オブジェクトを返します (<code>Writable Stream</code> を参照してください)。</p>

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:</p>

<pre><code>{ flags: 'w',
  encoding: null,
  mode: 0666 }</code></pre>

<p><code>options</code> にはデータをファイルのどの位置に書き込むかを指定する
<code>start</code> を含めることができます。
ファイルを置換するのではなく変更する場合は、 <code>flags</code> にデフォルトの
<code>w</code> ではなく <code>r+</code> が必要となります。</p>

<h2 id="fs.FSWatcher">fs.FSWatcher</h2>

<p><code>fs.watch()</code> が返すオブジェクトはこの型です。</p>

<h4 id="watcher.close">watcher.close() <a href="#watcher.close">#</a></h4>

<p><code>fs.FSWatcher</code> に与えられたファイルの監視を終了します。</p>

<h4 id="event_change_">Event: 'change' <a href="#event_change_">#</a></h4>

<p><code>function (event, filename) {}</code></p>

<p>監視しているファイルまたはディレクトリに変更があると生成されます。
詳しくは <a href="#fs.watch">fs.watch</a> を参照してください。</p>

<h4 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h4>

<p><code>function (exception) {}</code></p>

<p>エラーが発生すると生成されます。</p>
  </div>
  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <script>
    var gaJsHost = (("https:" == document.location.protocol) ?
    "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script>
    try {
      var pageTracker = _gat._getTracker("UA-10874194-2");
      pageTracker._trackPageview();
      } catch(err) {}</script>
</body>
</html>
