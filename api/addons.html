<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>addons - Node.js v0.7.2 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/docs/latest/api/addons.html">
</head>
<body class="alt apidoc">
    <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
            <img id="logo" src="assets/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <!--
                <li><a href="/" class="home">Home</a></li>
                <li><a href="/#download" class="download">Download</a></li>
                <li><a href="/about/" class="about">About</a></li>
                <li><a href="http://search.npmjs.org/" class="npm">npm Registry</a></li>
                <li><a href="http://nodejs.org/docs/latest/api/index.html" class="docs current">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="/community/" class="community">Community</a></li>
                <li><a href="/logos/" class="logos">Logos</a></li>
                -->
               <li><a href="../" class="home">ホーム</a></li>
               <li><a href="../#download" class="download">ダウンロード</a></li>
               <li><a href="../about/" class="about">概要</a></li>
               <li><a href="http://search.npmjs.org/" class="npm">npm レジストリ</a></li>
               <li><a href="../api/index.html" class="docs current">ドキュメント</a></li>
               <li><a href="http://blog.nodejs.org" class="blog">ブログ</a></li>
               <li><a href="../community/" class="community">コミュニティ</a></li>
               <li><a href="../logos/" class="logos">ロゴ</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Jobs</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>

        <div id="column1" class="interior">
        <header>
          <h1>Node.js v0.7.2 Manual &amp; Documentation</h1>
          <div id="gtoc">
            <p><a href="index.html" name="toc">Index</a> | <a href="all.html">View on single page</a></p>
          </div>
          <hr>
        </header>
        <div id="toc"><h2>Table Of Contents</h2><ul><li><a href="#addons">Addons</a><ul><li><a href="#hello_world">Hello world</a></li></ul></li><li><a href="#addon_patterns">Addon patterns</a><ul><li><a href="#function_arguments">Function arguments</a></li><li><a href="#callbacks">Callbacks</a></li><li><a href="#object_factory">Object factory</a></li><li><a href="#function_factory">Function factory</a></li><li><a href="#wrapping_C_objects">Wrapping C++ objects</a></li><li><a href="#factory_of_wrapped_objects">Factory of wrapped objects</a></li><li><a href="#passing_wrapped_objects_around">Passing wrapped objects around</a></li></ul></li></ul></li></ul><hr></div>
<h2 id="addons">Addons <span><a class="top" href="#">↑</a><a class="mark" href="#addons">#</a></span></h2>

<p>アドオンは動的に共有オブジェクトをリンクします。
それらは、C や C++ のライブラリに接合点を提供します。
API はいくつかのライブラリの知識が必要で、(現時点では) かなり複雑です。</p>

<ul><li><p>V8 JavaScript は C++ のライブラリです。
JavaScript のオブジェクト作成や関数呼び出し等のインタフェースに使用されます。
ドキュメントは主に、<code>v8.h</code> のヘッダファイル
(Node のソースツリーの中の <code>deps/v8/include/v8.h</code>) に記されていますが、
<a href="http://izs.me/v8-docs/main.html">オンライン</a> で参照することもできます。</p></li><li><p><a href="https://github.com/joyent/libuv">libuv</a> は
C のイベントループライブラリです。
ファイル記述子が読み取り可能になるのを待つとき、タイマーを待つとき、
シグナルを受信するのを待つときはいつでも、
libv のインタフェースが必要になります。
つまり、何らかの I/O 処理をすると必ず libuv を使う必要があるということです。</p></li><li><p>Node の内部ライブラリ。
もっとも重要なのは <code>node::ObjectWrap</code> クラスで、
このクラスから派生させることが多くなるでしょう。</p></li><li><p>その他。どのような物が利用できるかは <code>deps/</code> 以下を参照してさい。</p></li></ul>

<p>Node は全ての依存ライブラリを実行ファイルに静的にコンパイルします。
モジュールのコンパイル時には、それらのリンクについて一切気にする必要は有りません。</p>

<h3 id="hello_world">Hello world <span><a class="top" href="#">↑</a><a class="mark" href="#hello_world">#</a></span></h3>

<p>では、 以下の JavaScript コードと同じ様に動作する小さなアドオンを
C++ で作成してみましょう。</p>

<pre><code>exports.hello = function() { return 'world'; };</code></pre>

<p>最初に <code>hello.cc</code> というファイルを作成します:</p>

<pre><code>#include &lt;node.h&gt;
#include &lt;v8.h&gt;

using namespace v8;

Handle&lt;Value&gt; Method(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New("world"));
}

void init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol("hello"),
      FunctionTemplate::New(Method)-&gt;GetFunction());
}
NODE_MODULE(hello, init)</code></pre>

<p>全ての Node アドオンは初期化関数をエクスポートしなければならないことに
注意してください。</p>

<pre><code>void Initialize (Handle&lt;Object&gt; target);
NODE_MODULE(module_name, Initialize)</code></pre>

<p><code>NODE_MODULE</code> は関数ではないので、その後にセミコロンを付けてはいけません
(<code>node.h</code> を参照してください)。</p>

<p><code>module_name</code> は最終的なバイナリのファイル名 (拡張子 .node を除く)
とマッチする必要があります。</p>

<p>このソースコードは、<code>hello.node</code> というバイナリアドオンとしてビルドされる必要が有ります。
そのために <code>wscript</code> と呼ばれる以下のようなコードを Python で書きました:</p>

<pre><code>srcdir = '.'
blddir = 'build'
VERSION = '0.0.1'

def set_options(opt):
  opt.tool_options('compiler_cxx')

def configure(conf):
  conf.check_tool('compiler_cxx')
  conf.check_tool('node_addon')

def build(bld):
  obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
  obj.target = 'hello'
  obj.source = 'hello.cc'</code></pre>

<p><code>node-waf configure build</code> を実行すると、<code>build/default/hello.node</code> が作成されます。これが作成したアドオンです。</p>

<p><code>node-waf</code> 単に <a href="http://code.google.com/p/waf">WAF</a> は Python ベースのビルドシステムです。
<code>node-waf</code> は、ユーザの負担を減らすために提供されています。</p>

<p>ビルドされたモジュールを <code>require</code> で指定することにより、
このバイナリアドオンを Node プロジェクトの <code>hello.js</code> から利用することが
可能になります。</p>

<pre><code>var addon = require('./build/Release/hello');

console.log(addon.hello()); // 'world'</code></pre>

<p>さらに詳しい情報については下記のパターンか、
<a href="https://github.com/pietern/hiredis-node">https://github.com/pietern/hiredis-node</a> を実際のプロダクトにおける
例として参照してください。</p>

<h2 id="addon_patterns">Addon patterns <span><a class="top" href="#">↑</a><a class="mark" href="#addon_patterns">#</a></span></h2>

<p>以下は初心者に役立つアドオンのパターンです。
v8 の様々な API についてはオンラインの
<a href="http://izs.me/v8-docs/main.html">v8 reference</a> が、
そして ハンドルやスコープ、関数テンプレートなどいくつかの概念については
v8 の <a href="http://code.google.com/apis/v8/embed.html">Embedder's Guide</a> が
役に立つでしょう。</p>

<pre><code>srcdir = '.'
blddir = 'build'
VERSION = '0.0.1'

def set_options(opt):
  opt.tool_options('compiler_cxx')

def configure(conf):
  conf.check_tool('compiler_cxx')
  conf.check_tool('node_addon')

def build(bld):
  obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
  obj.target = 'addon'
  obj.source = ['addon.cc']</code></pre>

<p>一つ以上の <code>.cc</code> ファイルがある場合は、単純に <code>obj.source</code> 配列にファイル名を
加えるだけです。例:</p>

<pre><code>obj.source = ['addon.cc', 'myexample.cc']</code></pre>

<h4 id="function_arguments">Function arguments <span><a class="top" href="#">↑</a><a class="mark" href="#function_arguments">#</a></span></h4>

<p>以下のパターンは JavaScript から呼び出された関数で引数を読み出したり、
結果を返す方法を示します。これは <code>addon.cc</code> でのみ必要となります。</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; Add(const Arguments&amp; args) {
  HandleScope scope;

  if (args.Length() &lt; 2) {
    ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
    return scope.Close(Undefined());
  }

  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments")));
    return scope.Close(Undefined());
  }

  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() +
      args[1]-&gt;NumberValue());
  return scope.Close(num);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol("add"),
      FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>

<p>以下の JavaScript コード片でテストすることができます。</p>

<pre><code>var addon = require('./build/Release/addon');

console.log( 'This should be eight:', addon.add(3,5) );</code></pre>

<h4 id="callbacks">Callbacks <span><a class="top" href="#">↑</a><a class="mark" href="#callbacks">#</a></span></h4>

<p>JavaScript の関数を C++ の関数に渡してそこから呼び出すことができます。
これは <code>addon.cc</code> です:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; RunCallback(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);
  const unsigned argc = 1;
  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New("hello world")) };
  cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);

  return scope.Close(Undefined());
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol("runCallback"),
      FunctionTemplate::New(RunCallback)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>

<p>以下の JavaScript コード片でテストすることができます。</p>

<pre><code>var addon = require('./build/Release/addon');

addon.runCallback(function(msg){
  console.log(msg); // 'hello world'
});</code></pre>

<h4 id="object_factory">Object factory <span><a class="top" href="#">↑</a><a class="mark" href="#object_factory">#</a></span></h4>

<p>C++ 関数の中から新しいオブジェクトを作成して返すことができます。
以下の <code>addon.cc</code> のパターンでは、<code>createObject()</code> に渡された文字列を
反映する <code>msg</code> プロパティを持ったオブジェクトを返します。</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Object&gt; obj = Object::New();
  obj-&gt;Set(String::NewSymbol("msg"), args[0]-&gt;ToString());

  return scope.Close(obj);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol("createObject"),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>

<p>テスト用の JavaScript:</p>

<pre><code>var addon = require('./build/Release/addon');

var obj1 = addon.createObject('hello');
var obj2 = addon.createObject('world');
console.log(obj1.msg+' '+obj2.msg); // 'hello world'</code></pre>

<h4 id="function_factory">Function factory <span><a class="top" href="#">↑</a><a class="mark" href="#function_factory">#</a></span></h4>

<p>このパターンは C++ 関数をラップした JavaScript 関数を作成して返す方法を
示します。</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; MyFunction(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New("hello world"));
}

Handle&lt;Value&gt; CreateFunction(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(MyFunction);
  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();
  fn-&gt;SetName(String::NewSymbol("theFunction")); // omit this to make it anonymous

  return scope.Close(fn);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol("createFunction"),
      FunctionTemplate::New(CreateFunction)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>

<p>テスト:</p>

<pre><code>var addon = require('./build/Release/addon');

var fn = addon.createFunction();
console.log(fn()); // 'hello world'</code></pre>

<h4 id="wrapping_C_objects">Wrapping C++ objects <span><a class="top" href="#">↑</a><a class="mark" href="#wrapping_C_objects">#</a></span></h4>

<p>ここでは、
C++ オブジェクト／クラスをラップし、JavaScript から new 演算子を使って
インスタンス化できる <code>MyObject</code> を作成します。
最初にメインモジュール <code>addon.cc</code> を準備します:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include "myobject.h"

using namespace v8;

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init(target);
}

NODE_MODULE(addon, InitAll)</code></pre>

<p>次に、<code>node::ObjectWrap</code> を継承したラッパーを <code>myobject.h</code> に作成します。</p>

<pre><code>#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init(v8::Handle&lt;v8::Object&gt; target);

 private:
  MyObject();
  ~MyObject();

  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);
  double counter_;
};

#endif</code></pre>

<p>公開したい様々なメソッドを <code>myobject.cc</code> に実装します。
ここでは、コンストラクタに渡された値に加算する <code>plusOne</code> を公開しています:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include "myobject.h"

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

void MyObject::Init(Handle&lt;Object&gt; target) {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol("MyObject"));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototype
  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol("plusOne"),
      FunctionTemplate::New(PlusOne)-&gt;GetFunction());

  Persistent&lt;Function&gt; constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
  target-&gt;Set(String::NewSymbol("MyObject"), constructor);
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());
  obj-&gt;counter_ += 1;

  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>

<p>これでテストします:</p>

<pre><code>var addon = require('./build/Release/addon');

var obj = new addon.MyObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13</code></pre>

<h4 id="factory_of_wrapped_objects">Factory of wrapped objects <span><a class="top" href="#">↑</a><a class="mark" href="#factory_of_wrapped_objects">#</a></span></h4>

<p>JavaScript の <code>new</code> 演算子で明示的にインスタンス化することなく、
ネイティブオブジェクトを作成できるようにしたい場合に便利です。例:</p>

<pre><code>var obj = addon.createObject();
// instead of:
// var obj = new addon.Object();</code></pre>

<p><code>createObject</code> を <code>addon.cc</code> に登録しましょう:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include "myobject.h"

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MyObject::NewInstance(args));
}

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init();

  target-&gt;Set(String::NewSymbol("createObject"),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>

<p><code>myobject.h</code> にオブジェクトを生成する static メソッド <code>NewInstance</code> を
導入しましょう (すなわち，それが JavaScript 内の <code>new</code> の働きをします)。</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);

 private:
  MyObject();
  ~MyObject();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);
  double counter_;
};

#endif</code></pre>

<p>実装は前述の <code>myobject.cc</code> と同様です:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include "myobject.h"

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

Persistent&lt;Function&gt; MyObject::constructor;

void MyObject::Init() {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol("MyObject"));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototype
  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol("plusOne"),
      FunctionTemplate::New(PlusOne)-&gt;GetFunction());

  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}

Handle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());
  obj-&gt;counter_ += 1;

  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>

<p>これでテストします:</p>

<pre><code>var addon = require('./build/Release/addon');

var obj = addon.createObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13

var obj2 = addon.createObject(20);
console.log( obj2.plusOne() ); // 21
console.log( obj2.plusOne() ); // 22
console.log( obj2.plusOne() ); // 23</code></pre>

<h4 id="passing_wrapped_objects_around">Passing wrapped objects around <span><a class="top" href="#">↑</a><a class="mark" href="#passing_wrapped_objects_around">#</a></span></h4>

<p>C++ オブジェクトをラップして返すことに加えて、Node が提供するヘルパ関数
<code>node::ObjectWrap::Unwrap</code> を使用してアンラップすることもできます。
以下の <code>addon.cc</code> では、二つの <code>MyObject</code> オブジェクトを受け取る <code>add()</code>
関数を導入します:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include "myobject.h"

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MyObject::NewInstance(args));
}

Handle&lt;Value&gt; Add(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[0]-&gt;ToObject());
  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[1]-&gt;ToObject());

  double sum = obj1-&gt;Val() + obj2-&gt;Val();
  return scope.Close(Number::New(sum));
}

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init();

  target-&gt;Set(String::NewSymbol("createObject"),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());

  target-&gt;Set(String::NewSymbol("add"),
      FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>

<p>よりおもしろくするために、<code>myobject.h</code> にパブリックメソッドを導入しましょう。
したがって、アンラップされたオブジェクトのプライベート変数を調べることが
できます。</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);
  double Val() const { return val_; }

 private:
  MyObject();
  ~MyObject();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  double val_;
};

#endif</code></pre>

<p><code>myobject.cc</code> の実装はこれまでと同様です:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include "myobject.h"

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

Persistent&lt;Function&gt; MyObject::constructor;

void MyObject::Init() {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol("MyObject"));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;val_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}</code></pre>

<p>これでテストします:</p>

<pre><code>var addon = require('./build/Release/addon');

var obj1 = addon.createObject(10);
var obj2 = addon.createObject(20);
var result = addon.add(obj1, obj2);

console.log(result); // 30</code></pre>
        </div>
    </div>
    <div id="footer">
        <ul class="clearfix">
            <!--
            <li><a href="/">Node.js</a></li>
            <li><a href="/#download">Download</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="http://search.npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/docs/latest/api/index.html">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/logos/">Logos</a></li>
            -->
            <li><a href="../">Node.js</a></li>
            <li><a href="../#download">ダウンロード</a></li>
            <li><a href="../about/">概要</a></li>
            <li><a href="http://search.npmjs.org/">npm レジストリ</a></li>
            <li><a href="../api/index.html">ドキュメント</a></li>
            <li><a href="http://blog.nodejs.org">ブログ</a></li>
            <li><a href="../community/">コミュニティ</a></li>
            <li><a href="../logos/">ロゴ</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright 2010 <a href="http://joyent.com">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.7.2/LICENSE">license</a>.</p>
    </div>
    
  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <script>
    var gaJsHost = (("https:" == document.location.protocol) ?
    "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script>
    try {
      var pageTracker = _gat._getTracker("UA-10874194-2");
      pageTracker._trackPageview();
      } catch(err) {}</script>
</body>
</html>
