<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>About this Documentation Node.js v0.6.16 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/all.html">
</head>
<body class="alt apidoc" id="api-section-all">
    <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <!--
                <li><a href="/" class="home">Home</a></li>
                <li><a href="/#download" class="download">Download</a></li>
                <li><a href="/about/" class="about">About</a></li>
                <li><a href="http://search.npmjs.org/" class="npm">npm Registry</a></li>
                <li><a href="http://nodejs.org/api/" class="docs current">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="/community/" class="community">Community</a></li>
                <li><a href="/logos/" class="logos">Logos</a></li>
                -->
               <li><a href="../" class="home">ホーム</a></li>
               <li><a href="../#download" class="download">ダウンロード</a></li>
               <li><a href="../about/" class="about">概要</a></li>
               <li><a href="http://search.npmjs.org/" class="npm">npm レジストリ</a></li>
               <li><a href="../api/index.html" class="docs current">ドキュメント</a></li>
               <li><a href="http://blog.nodejs.org" class="blog">ブログ</a></li>
               <li><a href="../community/" class="community">コミュニティ</a></li>
               <li><a href="../logos/" class="logos">ロゴ</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Jobs</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>

        <div id="column1" class="interior">
          <header>
            <!--
            <h1>Node.js v0.6.16 Manual &amp; Documentation</h1>
            -->
            <h1>Node.js v0.6.16 マニュアル &amp; ドキュメンテーション</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Index</a> |
                <a href="all.html">View on single page</a> |
                <a href="all.json">View as JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
<li><a href="#all_about_this_documentation">About this Documentation</a><ul>
<li><a href="#all_stability_index">Stability Index</a></li>
<li><a href="#all_json_output">JSON Output</a></li>
</ul>
</li>
<li><a href="#all_synopsis">Synopsis</a></li>
<li><a href="#all_global_objects">Global Objects</a><ul>
<li><a href="#all_global">global</a></li>
<li><a href="#all_process">process</a></li>
<li><a href="#all_console">console</a></li>
<li><a href="#all_buffer">Buffer</a></li>
<li><a href="#all_require">require()</a><ul>
<li><a href="#all_require_resolve">require.resolve()</a></li>
<li><a href="#all_require_cache">require.cache</a></li>
</ul>
</li>
<li><a href="#all_filename">__filename</a></li>
<li><a href="#all_dirname">__dirname</a></li>
<li><a href="#all_module">module</a></li>
<li><a href="#all_exports">exports</a></li>
<li><a href="#all_settimeout_cb_ms">setTimeout(cb, ms)</a></li>
<li><a href="#all_cleartimeout_t">clearTimeout(t)</a></li>
<li><a href="#all_setinterval_cb_ms">setInterval(cb, ms)</a></li>
<li><a href="#all_clearinterval_t">clearInterval(t)</a></li>
</ul>
</li>
<li><a href="#all_console_1">console</a><ul>
<li><a href="#all_console_log">console.log()</a></li>
<li><a href="#all_console_info">console.info()</a></li>
<li><a href="#all_console_warn">console.warn()</a></li>
<li><a href="#all_console_error">console.error()</a></li>
<li><a href="#all_console_dir_obj">console.dir(obj)</a></li>
<li><a href="#all_console_time_label">console.time(label)</a></li>
<li><a href="#all_console_timeend_label">console.timeEnd(label)</a></li>
<li><a href="#all_console_trace">console.trace()</a></li>
<li><a href="#all_console_assert">console.assert()</a></li>
</ul>
</li>
<li><a href="#all_timers">Timers</a><ul>
<li><a href="#all_settimeout_callback_delay_arg">setTimeout(callback, delay, [arg], [...])</a></li>
<li><a href="#all_cleartimeout_timeoutid">clearTimeout(timeoutId)</a></li>
<li><a href="#all_setinterval_callback_delay_arg">setInterval(callback, delay, [arg], [...])</a></li>
<li><a href="#all_clearinterval_intervalid">clearInterval(intervalId)</a></li>
</ul>
</li>
<li><a href="#all_modules">Modules</a><ul>
<li><a href="#all_cycles">Cycles</a></li>
<li><a href="#all_core_modules">Core Modules</a></li>
<li><a href="#all_file_modules">File Modules</a></li>
<li><a href="#all_loading_from_node_modules_folders">Loading from <code>node_modules</code> Folders</a></li>
<li><a href="#all_folders_as_modules">Folders as Modules</a></li>
<li><a href="#all_caching">Caching</a><ul>
<li><a href="#all_module_caching_caveats">Module Caching Caveats</a></li>
</ul>
</li>
<li><a href="#all_the_module_object">The <code>module</code> Object</a><ul>
<li><a href="#all_module_exports">module.exports</a></li>
<li><a href="#all_module_require_id">module.require(id)</a></li>
<li><a href="#all_module_id">module.id</a></li>
<li><a href="#all_module_filename">module.filename</a></li>
<li><a href="#all_module_loaded">module.loaded</a></li>
<li><a href="#all_module_parent">module.parent</a></li>
<li><a href="#all_module_children">module.children</a></li>
</ul>
</li>
<li><a href="#all_all_together">All Together...</a></li>
<li><a href="#all_loading_from_the_global_folders">Loading from the global folders</a></li>
<li><a href="#all_accessing_the_main_module">Accessing the main module</a></li>
<li><a href="#all_addenda_package_manager_tips">Addenda: Package Manager Tips</a></li>
</ul>
</li>
<li><a href="#all_addons">Addons</a><ul>
<li><a href="#all_hello_world">Hello world</a></li>
<li><a href="#all_addon_patterns">Addon patterns</a><ul>
<li><a href="#all_function_arguments">Function arguments</a></li>
<li><a href="#all_callbacks">Callbacks</a></li>
<li><a href="#all_object_factory">Object factory</a></li>
<li><a href="#all_function_factory">Function factory</a></li>
<li><a href="#all_wrapping_c_objects">Wrapping C++ objects</a></li>
<li><a href="#all_factory_of_wrapped_objects">Factory of wrapped objects</a></li>
<li><a href="#all_passing_wrapped_objects_around">Passing wrapped objects around</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_process_1">process</a><ul>
<li><a href="#all_event_exit">Event: &apos;exit&apos;</a></li>
<li><a href="#all_event_uncaughtexception">Event: &apos;uncaughtException&apos;</a></li>
<li><a href="#all_signal_events">Signal Events</a></li>
<li><a href="#all_process_stdout">process.stdout</a></li>
<li><a href="#all_process_stderr">process.stderr</a></li>
<li><a href="#all_process_stdin">process.stdin</a></li>
<li><a href="#all_process_argv">process.argv</a></li>
<li><a href="#all_process_execpath">process.execPath</a></li>
<li><a href="#all_process_chdir_directory">process.chdir(directory)</a></li>
<li><a href="#all_process_cwd">process.cwd()</a></li>
<li><a href="#all_process_env">process.env</a></li>
<li><a href="#all_process_exit_code">process.exit([code])</a></li>
<li><a href="#all_process_getgid">process.getgid()</a></li>
<li><a href="#all_process_setgid_id">process.setgid(id)</a></li>
<li><a href="#all_process_getuid">process.getuid()</a></li>
<li><a href="#all_process_setuid_id">process.setuid(id)</a></li>
<li><a href="#all_process_version">process.version</a></li>
<li><a href="#all_process_versions">process.versions</a></li>
<li><a href="#all_process_installprefix">process.installPrefix</a></li>
<li><a href="#all_process_kill_pid_signal">process.kill(pid, [signal])</a></li>
<li><a href="#all_process_pid">process.pid</a></li>
<li><a href="#all_process_title">process.title</a></li>
<li><a href="#all_process_arch">process.arch</a></li>
<li><a href="#all_process_platform">process.platform</a></li>
<li><a href="#all_process_memoryusage">process.memoryUsage()</a></li>
<li><a href="#all_process_nexttick_callback">process.nextTick(callback)</a></li>
<li><a href="#all_process_umask_mask">process.umask([mask])</a></li>
<li><a href="#all_process_uptime">process.uptime()</a></li>
</ul>
</li>
<li><a href="#all_util">util</a><ul>
<li><a href="#all_util_format">util.format()</a></li>
<li><a href="#all_util_debug_string">util.debug(string)</a></li>
<li><a href="#all_util_log_string">util.log(string)</a></li>
<li><a href="#all_util_inspect_object_showhidden_depth_colors">util.inspect(object, [showHidden], [depth], [colors])</a></li>
<li><a href="#all_util_isarray_object">util.isArray(object)</a></li>
<li><a href="#all_util_isregexp_object">util.isRegExp(object)</a></li>
<li><a href="#all_util_isdate_object">util.isDate(object)</a></li>
<li><a href="#all_util_iserror_object">util.isError(object)</a></li>
<li><a href="#all_util_pump_readablestream_writablestream_callback">util.pump(readableStream, writableStream, [callback])</a></li>
<li><a href="#all_util_inherits_constructor_superconstructor">util.inherits(constructor, superConstructor)</a></li>
</ul>
</li>
<li><a href="#all_events">Events</a><ul>
<li><a href="#all_class_events_eventemitter">Class: events.EventEmitter</a><ul>
<li><a href="#all_emitter_addlistener_event_listener">emitter.addListener(event, listener)</a></li>
<li><a href="#all_emitter_on_event_listener">emitter.on(event, listener)</a></li>
<li><a href="#all_emitter_once_event_listener">emitter.once(event, listener)</a></li>
<li><a href="#all_emitter_removelistener_event_listener">emitter.removeListener(event, listener)</a></li>
<li><a href="#all_emitter_removealllisteners_event">emitter.removeAllListeners([event])</a></li>
<li><a href="#all_emitter_setmaxlisteners_n">emitter.setMaxListeners(n)</a></li>
<li><a href="#all_emitter_listeners_event">emitter.listeners(event)</a></li>
<li><a href="#all_emitter_emit_event_arg1_arg2">emitter.emit(event, [arg1], [arg2], [...])</a></li>
<li><a href="#all_event_newlistener">Event: &apos;newListener&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_buffer_1">Buffer</a><ul>
<li><a href="#all_class_buffer">Class: Buffer</a><ul>
<li><a href="#all_new_buffer_size">new Buffer(size)</a></li>
<li><a href="#all_new_buffer_array">new Buffer(array)</a></li>
<li><a href="#all_new_buffer_str_encoding">new Buffer(str, [encoding])</a></li>
<li><a href="#all_buf_write_string_offset_length_encoding">buf.write(string, [offset], [length], [encoding])</a></li>
<li><a href="#all_buf_tostring_encoding_start_end">buf.toString([encoding], [start], [end])</a></li>
<li><a href="#all_buf_index">buf[index]</a></li>
<li><a href="#all_class_method_buffer_isbuffer_obj">Class Method: Buffer.isBuffer(obj)</a></li>
<li><a href="#all_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string, [encoding])</a></li>
<li><a href="#all_buf_length">buf.length</a></li>
<li><a href="#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</a></li>
<li><a href="#all_buf_slice_start_end">buf.slice([start], [end])</a></li>
<li><a href="#all_buf_readuint8_offset_noassert">buf.readUInt8(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint8_offset_noassert">buf.readInt8(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint16le_offset_noassert">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint16be_offset_noassert">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint32le_offset_noassert">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint32be_offset_noassert">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readfloatle_offset_noassert">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_fill_value_offset_end">buf.fill(value, [offset], [end])</a></li>
</ul>
</li>
<li><a href="#all_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="#all_class_slowbuffer">Class: SlowBuffer</a></li>
</ul>
</li>
<li><a href="#all_stream">Stream</a><ul>
<li><a href="#all_readable_stream">Readable Stream</a><ul>
<li><a href="#all_event_data">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end">Event: &apos;end&apos;</a></li>
<li><a href="#all_event_error">Event: &apos;error&apos;</a></li>
<li><a href="#all_event_close">Event: &apos;close&apos;</a></li>
<li><a href="#all_stream_readable">stream.readable</a></li>
<li><a href="#all_stream_setencoding_encoding">stream.setEncoding(encoding)</a></li>
<li><a href="#all_stream_pause">stream.pause()</a></li>
<li><a href="#all_stream_resume">stream.resume()</a></li>
<li><a href="#all_stream_destroy">stream.destroy()</a></li>
<li><a href="#all_stream_destroysoon">stream.destroySoon()</a></li>
<li><a href="#all_stream_pipe_destination_options">stream.pipe(destination, [options])</a></li>
</ul>
</li>
<li><a href="#all_writable_stream">Writable Stream</a><ul>
<li><a href="#all_event_drain">Event: &apos;drain&apos;</a></li>
<li><a href="#all_event_error_1">Event: &apos;error&apos;</a></li>
<li><a href="#all_event_close_1">Event: &apos;close&apos;</a></li>
<li><a href="#all_event_pipe">Event: &apos;pipe&apos;</a></li>
<li><a href="#all_stream_writable">stream.writable</a></li>
<li><a href="#all_stream_write_string_encoding_fd">stream.write(string, [encoding], [fd])</a></li>
<li><a href="#all_stream_write_buffer">stream.write(buffer)</a></li>
<li><a href="#all_stream_end">stream.end()</a></li>
<li><a href="#all_stream_end_string_encoding">stream.end(string, encoding)</a></li>
<li><a href="#all_stream_end_buffer">stream.end(buffer)</a></li>
<li><a href="#all_stream_destroy_1">stream.destroy()</a></li>
<li><a href="#all_stream_destroysoon_1">stream.destroySoon()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_crypto">Crypto</a><ul>
<li><a href="#all_crypto_createcredentials_details">crypto.createCredentials(details)</a></li>
<li><a href="#all_crypto_createhash_algorithm">crypto.createHash(algorithm)</a></li>
<li><a href="#all_class_hash">Class: Hash</a><ul>
<li><a href="#all_hash_update_data_input_encoding">hash.update(data, [input_encoding])</a></li>
<li><a href="#all_hash_digest_encoding">hash.digest([encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createhmac_algorithm_key">crypto.createHmac(algorithm, key)</a></li>
<li><a href="#all_class_hmac">Class: Hmac</a><ul>
<li><a href="#all_hmac_update_data">hmac.update(data)</a></li>
<li><a href="#all_hmac_digest_encoding">hmac.digest([encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createcipher_algorithm_password">crypto.createCipher(algorithm, password)</a></li>
<li><a href="#all_crypto_createcipheriv_algorithm_key_iv">crypto.createCipheriv(algorithm, key, iv)</a></li>
<li><a href="#all_class_cipher">Class: Cipher</a><ul>
<li><a href="#all_cipher_update_data_input_encoding_output_encoding">cipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_cipher_final_output_encoding">cipher.final([output_encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createdecipher_algorithm_password">crypto.createDecipher(algorithm, password)</a></li>
<li><a href="#all_crypto_createdecipheriv_algorithm_key_iv">crypto.createDecipheriv(algorithm, key, iv)</a></li>
<li><a href="#all_class_decipher">Class: Decipher</a><ul>
<li><a href="#all_decipher_update_data_input_encoding_output_encoding">decipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_decipher_final_output_encoding">decipher.final([output_encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createsign_algorithm">crypto.createSign(algorithm)</a></li>
<li><a href="#all_class_signer">Class: Signer</a><ul>
<li><a href="#all_signer_update_data">signer.update(data)</a></li>
<li><a href="#all_signer_sign_private_key_output_format">signer.sign(private_key, [output_format])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createverify_algorithm">crypto.createVerify(algorithm)</a></li>
<li><a href="#all_class_verify">Class: Verify</a><ul>
<li><a href="#all_verifier_update_data">verifier.update(data)</a></li>
<li><a href="#all_verifier_verify_object_signature_signature_format">verifier.verify(object, signature, [signature_format])</a></li>
</ul>
</li>
<li><a href="#all_crypto_creatediffiehellman_prime_length">crypto.createDiffieHellman(prime_length)</a></li>
<li><a href="#all_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman(prime, [encoding])</a></li>
<li><a href="#all_class_diffiehellman">Class: DiffieHellman</a><ul>
<li><a href="#all_diffiehellman_generatekeys_encoding">diffieHellman.generateKeys([encoding])</a></li>
<li><a href="#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_diffiehellman_getprime_encoding">diffieHellman.getPrime([encoding])</a></li>
<li><a href="#all_diffiehellman_getgenerator_encoding">diffieHellman.getGenerator([encoding])</a></li>
<li><a href="#all_diffiehellman_getpublickey_encoding">diffieHellman.getPublicKey([encoding])</a></li>
<li><a href="#all_diffiehellman_getprivatekey_encoding">diffieHellman.getPrivateKey([encoding])</a></li>
<li><a href="#all_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey(public_key, [encoding])</a></li>
<li><a href="#all_diffiehellman_setprivatekey_public_key_encoding">diffieHellman.setPrivateKey(public_key, [encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_pbkdf2_password_salt_iterations_keylen_callback">crypto.pbkdf2(password, salt, iterations, keylen, callback)</a></li>
<li><a href="#all_crypto_randombytes_size_callback">crypto.randomBytes(size, [callback])</a></li>
</ul>
</li>
<li><a href="#all_tls_ssl">TLS (SSL)</a><ul>
<li><a href="#all_client_initiated_renegotiation_attack_mitigation">Client-initiated renegotiation attack mitigation</a></li>
<li><a href="#all_npn_and_sni">NPN and SNI</a></li>
<li><a href="#all_tls_createserver_options_secureconnectionlistener">tls.createServer(options, [secureConnectionListener])</a></li>
<li><a href="#all_tls_connect_port_host_options_secureconnectlistener">tls.connect(port, [host], [options], [secureConnectListener])</a></li>
<li><a href="#all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</a></li>
<li><a href="#all_class_securepair">Class: SecurePair</a><ul>
<li><a href="#all_event_secure">Event: &apos;secure&apos;</a></li>
</ul>
</li>
<li><a href="#all_class_tls_server">Class: tls.Server</a><ul>
<li><a href="#all_event_secureconnection">Event: &apos;secureConnection&apos;</a></li>
<li><a href="#all_event_clienterror">Event: &apos;clientError&apos;</a></li>
<li><a href="#all_server_listen_port_host_callback">server.listen(port, [host], [callback])</a></li>
<li><a href="#all_server_close">server.close()</a></li>
<li><a href="#all_server_address">server.address()</a></li>
<li><a href="#all_server_addcontext_hostname_credentials">server.addContext(hostname, credentials)</a></li>
<li><a href="#all_server_maxconnections">server.maxConnections</a></li>
<li><a href="#all_server_connections">server.connections</a></li>
</ul>
</li>
<li><a href="#all_class_tls_cleartextstream">Class: tls.CleartextStream</a><ul>
<li><a href="#all_event_secureconnect">Event: &apos;secureConnect&apos;</a></li>
<li><a href="#all_cleartextstream_authorized">cleartextStream.authorized</a></li>
<li><a href="#all_cleartextstream_authorizationerror">cleartextStream.authorizationError</a></li>
<li><a href="#all_cleartextstream_getpeercertificate">cleartextStream.getPeerCertificate()</a></li>
<li><a href="#all_cleartextstream_address">cleartextStream.address()</a></li>
<li><a href="#all_cleartextstream_remoteaddress">cleartextStream.remoteAddress</a></li>
<li><a href="#all_cleartextstream_remoteport">cleartextStream.remotePort</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_file_system">File System</a><ul>
<li><a href="#all_fs_rename_path1_path2_callback">fs.rename(path1, path2, [callback])</a></li>
<li><a href="#all_fs_renamesync_path1_path2">fs.renameSync(path1, path2)</a></li>
<li><a href="#all_fs_truncate_fd_len_callback">fs.truncate(fd, len, [callback])</a></li>
<li><a href="#all_fs_truncatesync_fd_len">fs.truncateSync(fd, len)</a></li>
<li><a href="#all_fs_chown_path_uid_gid_callback">fs.chown(path, uid, gid, [callback])</a></li>
<li><a href="#all_fs_chownsync_path_uid_gid">fs.chownSync(path, uid, gid)</a></li>
<li><a href="#all_fs_fchown_fd_uid_gid_callback">fs.fchown(fd, uid, gid, [callback])</a></li>
<li><a href="#all_fs_fchownsync_fd_uid_gid">fs.fchownSync(fd, uid, gid)</a></li>
<li><a href="#all_fs_lchown_path_uid_gid_callback">fs.lchown(path, uid, gid, [callback])</a></li>
<li><a href="#all_fs_lchownsync_path_uid_gid">fs.lchownSync(path, uid, gid)</a></li>
<li><a href="#all_fs_chmod_path_mode_callback">fs.chmod(path, mode, [callback])</a></li>
<li><a href="#all_fs_chmodsync_path_mode">fs.chmodSync(path, mode)</a></li>
<li><a href="#all_fs_fchmod_fd_mode_callback">fs.fchmod(fd, mode, [callback])</a></li>
<li><a href="#all_fs_fchmodsync_fd_mode">fs.fchmodSync(fd, mode)</a></li>
<li><a href="#all_fs_lchmod_path_mode_callback">fs.lchmod(path, mode, [callback])</a></li>
<li><a href="#all_fs_lchmodsync_path_mode">fs.lchmodSync(path, mode)</a></li>
<li><a href="#all_fs_stat_path_callback">fs.stat(path, [callback])</a></li>
<li><a href="#all_fs_lstat_path_callback">fs.lstat(path, [callback])</a></li>
<li><a href="#all_fs_fstat_fd_callback">fs.fstat(fd, [callback])</a></li>
<li><a href="#all_fs_statsync_path">fs.statSync(path)</a></li>
<li><a href="#all_fs_lstatsync_path">fs.lstatSync(path)</a></li>
<li><a href="#all_fs_fstatsync_fd">fs.fstatSync(fd)</a></li>
<li><a href="#all_fs_link_srcpath_dstpath_callback">fs.link(srcpath, dstpath, [callback])</a></li>
<li><a href="#all_fs_linksync_srcpath_dstpath">fs.linkSync(srcpath, dstpath)</a></li>
<li><a href="#all_fs_symlink_linkdata_path_type_callback">fs.symlink(linkdata, path, [type], [callback])</a></li>
<li><a href="#all_fs_symlinksync_linkdata_path_type">fs.symlinkSync(linkdata, path, [type])</a></li>
<li><a href="#all_fs_readlink_path_callback">fs.readlink(path, [callback])</a></li>
<li><a href="#all_fs_readlinksync_path">fs.readlinkSync(path)</a></li>
<li><a href="#all_fs_realpath_path_callback">fs.realpath(path, [callback])</a></li>
<li><a href="#all_fs_realpathsync_path">fs.realpathSync(path)</a></li>
<li><a href="#all_fs_unlink_path_callback">fs.unlink(path, [callback])</a></li>
<li><a href="#all_fs_unlinksync_path">fs.unlinkSync(path)</a></li>
<li><a href="#all_fs_rmdir_path_callback">fs.rmdir(path, [callback])</a></li>
<li><a href="#all_fs_rmdirsync_path">fs.rmdirSync(path)</a></li>
<li><a href="#all_fs_mkdir_path_mode_callback">fs.mkdir(path, [mode], [callback])</a></li>
<li><a href="#all_fs_mkdirsync_path_mode">fs.mkdirSync(path, [mode])</a></li>
<li><a href="#all_fs_readdir_path_callback">fs.readdir(path, [callback])</a></li>
<li><a href="#all_fs_readdirsync_path">fs.readdirSync(path)</a></li>
<li><a href="#all_fs_close_fd_callback">fs.close(fd, [callback])</a></li>
<li><a href="#all_fs_closesync_fd">fs.closeSync(fd)</a></li>
<li><a href="#all_fs_open_path_flags_mode_callback">fs.open(path, flags, [mode], [callback])</a></li>
<li><a href="#all_fs_opensync_path_flags_mode">fs.openSync(path, flags, [mode])</a></li>
<li><a href="#all_fs_utimes_path_atime_mtime_callback">fs.utimes(path, atime, mtime, [callback])</a></li>
<li><a href="#all_fs_utimessync_path_atime_mtime">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="#all_fs_futimes_fd_atime_mtime_callback">fs.futimes(fd, atime, mtime, [callback])</a></li>
<li><a href="#all_fs_futimessync_fd_atime_mtime">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="#all_fs_fsync_fd_callback">fs.fsync(fd, [callback])</a></li>
<li><a href="#all_fs_fsyncsync_fd">fs.fsyncSync(fd)</a></li>
<li><a href="#all_fs_write_fd_buffer_offset_length_position_callback">fs.write(fd, buffer, offset, length, position, [callback])</a></li>
<li><a href="#all_fs_writesync_fd_buffer_offset_length_position">fs.writeSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#all_fs_writesync_fd_str_position_encoding">fs.writeSync(fd, str, position, [encoding])</a></li>
<li><a href="#all_fs_read_fd_buffer_offset_length_position_callback">fs.read(fd, buffer, offset, length, position, [callback])</a></li>
<li><a href="#all_fs_readsync_fd_buffer_offset_length_position">fs.readSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#all_fs_readsync_fd_length_position_encoding">fs.readSync(fd, length, position, encoding)</a></li>
<li><a href="#all_fs_readfile_filename_encoding_callback">fs.readFile(filename, [encoding], [callback])</a></li>
<li><a href="#all_fs_readfilesync_filename_encoding">fs.readFileSync(filename, [encoding])</a></li>
<li><a href="#all_fs_writefile_filename_data_encoding_callback">fs.writeFile(filename, data, [encoding], [callback])</a></li>
<li><a href="#all_fs_writefilesync_filename_data_encoding">fs.writeFileSync(filename, data, [encoding])</a></li>
<li><a href="#all_fs_watchfile_filename_options_listener">fs.watchFile(filename, [options], listener)</a></li>
<li><a href="#all_fs_unwatchfile_filename">fs.unwatchFile(filename)</a></li>
<li><a href="#all_fs_watch_filename_options_listener">fs.watch(filename, [options], listener)</a><ul>
<li><a href="#all_caveats">Caveats</a><ul>
<li><a href="#all_availability">Availability</a></li>
<li><a href="#all_filename_argument">Filename Argument</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_class_fs_stats">Class: fs.Stats</a></li>
<li><a href="#all_fs_createreadstream_path_options">fs.createReadStream(path, [options])</a></li>
<li><a href="#all_class_fs_readstream">Class: fs.ReadStream</a><ul>
<li><a href="#all_event_open">Event: &apos;open&apos;</a></li>
</ul>
</li>
<li><a href="#all_fs_createwritestream_path_options">fs.createWriteStream(path, [options])</a></li>
<li><a href="#all_fs_writestream">fs.WriteStream</a><ul>
<li><a href="#all_event_open_1">Event: &apos;open&apos;</a></li>
<li><a href="#all_file_byteswritten">file.bytesWritten</a></li>
</ul>
</li>
<li><a href="#all_class_fs_fswatcher">Class: fs.FSWatcher</a><ul>
<li><a href="#all_watcher_close">watcher.close()</a></li>
<li><a href="#all_event_change">Event: &apos;change&apos;</a></li>
<li><a href="#all_event_error_2">Event: &apos;error&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_path">Path</a><ul>
<li><a href="#all_path_normalize_p">path.normalize(p)</a></li>
<li><a href="#all_path_join_path1_path2">path.join([path1], [path2], [...])</a></li>
<li><a href="#all_path_resolve_from_to">path.resolve([from ...], to)</a></li>
<li><a href="#all_path_relative_from_to">path.relative(from, to)</a></li>
<li><a href="#all_path_dirname_p">path.dirname(p)</a></li>
<li><a href="#all_path_basename_p_ext">path.basename(p, [ext])</a></li>
<li><a href="#all_path_extname_p">path.extname(p)</a></li>
<li><a href="#all_path_exists_p_callback">path.exists(p, [callback])</a></li>
<li><a href="#all_path_existssync_p">path.existsSync(p)</a></li>
</ul>
</li>
<li><a href="#all_net">net</a><ul>
<li><a href="#all_net_createserver_options_connectionlistener">net.createServer([options], [connectionListener])</a></li>
<li><a href="#all_net_connect_arguments">net.connect(arguments...)</a></li>
<li><a href="#all_net_createconnection_arguments">net.createConnection(arguments...)</a></li>
<li><a href="#all_class_net_server">Class: net.Server</a><ul>
<li><a href="#all_server_listen_port_host_listeninglistener">server.listen(port, [host], [listeningListener])</a></li>
<li><a href="#all_server_listen_path_listeninglistener">server.listen(path, [listeningListener])</a></li>
<li><a href="#all_server_close_1">server.close()</a></li>
<li><a href="#all_server_address_1">server.address()</a></li>
<li><a href="#all_server_maxconnections_1">server.maxConnections</a></li>
</ul>
</li>
<li><a href="#all_server_connections_1">server.connections</a><ul>
<li><a href="#all_event_listening">Event: &apos;listening&apos;</a></li>
<li><a href="#all_event_connection">Event: &apos;connection&apos;</a></li>
<li><a href="#all_event_close_2">Event: &apos;close&apos;</a></li>
<li><a href="#all_event_error_3">Event: &apos;error&apos;</a></li>
</ul>
</li>
<li><a href="#all_class_net_socket">Class: net.Socket</a><ul>
<li><a href="#all_new_net_socket_options">new net.Socket([options])</a></li>
<li><a href="#all_socket_connect_port_host_connectlistener">socket.connect(port, [host], [connectListener])</a></li>
<li><a href="#all_socket_connect_path_connectlistener">socket.connect(path, [connectListener])</a></li>
<li><a href="#all_socket_buffersize">socket.bufferSize</a></li>
<li><a href="#all_socket_setencoding_encoding">socket.setEncoding([encoding])</a></li>
<li><a href="#all_socket_setsecure">socket.setSecure()</a></li>
<li><a href="#all_socket_write_data_encoding_callback">socket.write(data, [encoding], [callback])</a></li>
<li><a href="#all_socket_end_data_encoding">socket.end([data], [encoding])</a></li>
<li><a href="#all_socket_destroy">socket.destroy()</a></li>
<li><a href="#all_socket_pause">socket.pause()</a></li>
<li><a href="#all_socket_resume">socket.resume()</a></li>
<li><a href="#all_socket_settimeout_timeout_callback">socket.setTimeout(timeout, [callback])</a></li>
<li><a href="#all_socket_setnodelay_nodelay">socket.setNoDelay([noDelay])</a></li>
<li><a href="#all_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive([enable], [initialDelay])</a></li>
<li><a href="#all_socket_address">socket.address()</a></li>
<li><a href="#all_socket_remoteaddress">socket.remoteAddress</a></li>
<li><a href="#all_socket_remoteport">socket.remotePort</a></li>
<li><a href="#all_socket_bytesread">socket.bytesRead</a></li>
<li><a href="#all_socket_byteswritten">socket.bytesWritten</a></li>
<li><a href="#all_event_connect">Event: &apos;connect&apos;</a></li>
<li><a href="#all_event_data_1">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_1">Event: &apos;end&apos;</a></li>
<li><a href="#all_event_timeout">Event: &apos;timeout&apos;</a></li>
<li><a href="#all_event_drain_1">Event: &apos;drain&apos;</a></li>
<li><a href="#all_event_error_4">Event: &apos;error&apos;</a></li>
<li><a href="#all_event_close_3">Event: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="#all_net_isip_input">net.isIP(input)</a></li>
<li><a href="#all_net_isipv4_input">net.isIPv4(input)</a></li>
<li><a href="#all_net_isipv6_input">net.isIPv6(input)</a></li>
</ul>
</li>
<li><a href="#all_udp_datagram_sockets">UDP / Datagram Sockets</a><ul>
<li><a href="#all_dgram_createsocket_type_callback">dgram.createSocket(type, [callback])</a></li>
<li><a href="#all_class_socket">Class: Socket</a><ul>
<li><a href="#all_event_message">Event: &apos;message&apos;</a></li>
<li><a href="#all_event_listening_1">Event: &apos;listening&apos;</a></li>
<li><a href="#all_event_close_4">Event: &apos;close&apos;</a></li>
<li><a href="#all_event_error_5">Event: &apos;error&apos;</a></li>
<li><a href="#all_dgram_send_buf_offset_length_port_address_callback">dgram.send(buf, offset, length, port, address, [callback])</a></li>
<li><a href="#all_dgram_bind_port_address">dgram.bind(port, [address])</a></li>
<li><a href="#all_dgram_close">dgram.close()</a></li>
<li><a href="#all_dgram_address">dgram.address()</a></li>
<li><a href="#all_dgram_setbroadcast_flag">dgram.setBroadcast(flag)</a></li>
<li><a href="#all_dgram_setttl_ttl">dgram.setTTL(ttl)</a></li>
<li><a href="#all_dgram_setmulticastttl_ttl">dgram.setMulticastTTL(ttl)</a></li>
<li><a href="#all_dgram_setmulticastloopback_flag">dgram.setMulticastLoopback(flag)</a></li>
<li><a href="#all_dgram_addmembership_multicastaddress_multicastinterface">dgram.addMembership(multicastAddress, [multicastInterface])</a></li>
<li><a href="#all_dgram_dropmembership_multicastaddress_multicastinterface">dgram.dropMembership(multicastAddress, [multicastInterface])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_dns">DNS</a><ul>
<li><a href="#all_dns_lookup_domain_family_callback">dns.lookup(domain, [family], callback)</a></li>
<li><a href="#all_dns_resolve_domain_rrtype_callback">dns.resolve(domain, [rrtype], callback)</a></li>
<li><a href="#all_dns_resolve4_domain_callback">dns.resolve4(domain, callback)</a></li>
<li><a href="#all_dns_resolve6_domain_callback">dns.resolve6(domain, callback)</a></li>
<li><a href="#all_dns_resolvemx_domain_callback">dns.resolveMx(domain, callback)</a></li>
<li><a href="#all_dns_resolvetxt_domain_callback">dns.resolveTxt(domain, callback)</a></li>
<li><a href="#all_dns_resolvesrv_domain_callback">dns.resolveSrv(domain, callback)</a></li>
<li><a href="#all_dns_reverse_ip_callback">dns.reverse(ip, callback)</a></li>
<li><a href="#all_dns_resolvens_domain_callback">dns.resolveNs(domain, callback)</a></li>
<li><a href="#all_dns_resolvecname_domain_callback">dns.resolveCname(domain, callback)</a></li>
</ul>
</li>
<li><a href="#all_http">HTTP</a><ul>
<li><a href="#all_http_createserver_requestlistener">http.createServer([requestListener])</a></li>
<li><a href="#all_class_http_server">Class: http.Server</a><ul>
<li><a href="#all_event_request">Event: &apos;request&apos;</a></li>
<li><a href="#all_event_connection_1">Event: &apos;connection&apos;</a></li>
<li><a href="#all_event_close_5">Event: &apos;close&apos;</a></li>
<li><a href="#all_event_checkcontinue">Event: &apos;checkContinue&apos;</a></li>
<li><a href="#all_event_upgrade">Event: &apos;upgrade&apos;</a></li>
<li><a href="#all_event_clienterror_1">Event: &apos;clientError&apos;</a></li>
<li><a href="#all_server_listen_port_hostname_callback">server.listen(port, [hostname], [callback])</a></li>
<li><a href="#all_server_listen_path_callback">server.listen(path, [callback])</a></li>
<li><a href="#all_server_close_2">server.close()</a></li>
</ul>
</li>
<li><a href="#all_class_http_serverrequest">Class: http.ServerRequest</a><ul>
<li><a href="#all_event_data_2">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_2">Event: &apos;end&apos;</a></li>
<li><a href="#all_event_close_6">Event: &apos;close&apos;</a></li>
<li><a href="#all_request_method">request.method</a></li>
<li><a href="#all_request_url">request.url</a></li>
<li><a href="#all_request_headers">request.headers</a></li>
<li><a href="#all_request_trailers">request.trailers</a></li>
<li><a href="#all_request_httpversion">request.httpVersion</a></li>
<li><a href="#all_request_setencoding_encoding">request.setEncoding([encoding])</a></li>
<li><a href="#all_request_pause">request.pause()</a></li>
<li><a href="#all_request_resume">request.resume()</a></li>
<li><a href="#all_request_connection">request.connection</a></li>
</ul>
</li>
<li><a href="#all_class_http_serverresponse">Class: http.ServerResponse</a><ul>
<li><a href="#all_event_close_7">Event: &apos;close&apos;</a></li>
<li><a href="#all_response_writecontinue">response.writeContinue()</a></li>
<li><a href="#all_response_writehead_statuscode_reasonphrase_headers">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li>
<li><a href="#all_response_statuscode">response.statusCode</a></li>
<li><a href="#all_response_setheader_name_value">response.setHeader(name, value)</a></li>
<li><a href="#all_response_getheader_name">response.getHeader(name)</a></li>
<li><a href="#all_response_removeheader_name">response.removeHeader(name)</a></li>
<li><a href="#all_response_write_chunk_encoding">response.write(chunk, [encoding])</a></li>
<li><a href="#all_response_addtrailers_headers">response.addTrailers(headers)</a></li>
<li><a href="#all_response_end_data_encoding">response.end([data], [encoding])</a></li>
</ul>
</li>
<li><a href="#all_http_request_options_callback">http.request(options, callback)</a></li>
<li><a href="#all_http_get_options_callback">http.get(options, callback)</a></li>
<li><a href="#all_class_http_agent">Class: http.Agent</a><ul>
<li><a href="#all_agent_maxsockets">agent.maxSockets</a></li>
<li><a href="#all_agent_sockets">agent.sockets</a></li>
<li><a href="#all_agent_requests">agent.requests</a></li>
</ul>
</li>
<li><a href="#all_http_globalagent">http.globalAgent</a></li>
<li><a href="#all_class_http_clientrequest">Class: http.ClientRequest</a><ul>
<li><a href="#all_event_response">Event &apos;response&apos;</a></li>
<li><a href="#all_event_socket">Event: &apos;socket&apos;</a></li>
<li><a href="#all_event_upgrade_1">Event: &apos;upgrade&apos;</a></li>
<li><a href="#all_event_continue">Event: &apos;continue&apos;</a></li>
<li><a href="#all_request_write_chunk_encoding">request.write(chunk, [encoding])</a></li>
<li><a href="#all_request_end_data_encoding">request.end([data], [encoding])</a></li>
<li><a href="#all_request_abort">request.abort()</a></li>
<li><a href="#all_request_settimeout_timeout_callback">request.setTimeout(timeout, [callback])</a></li>
<li><a href="#all_request_setnodelay_nodelay">request.setNoDelay([noDelay])</a></li>
<li><a href="#all_request_setsocketkeepalive_enable_initialdelay">request.setSocketKeepAlive([enable], [initialDelay])</a></li>
</ul>
</li>
<li><a href="#all_http_clientresponse">http.ClientResponse</a><ul>
<li><a href="#all_event_data_3">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_3">Event: &apos;end&apos;</a></li>
<li><a href="#all_event_close_8">Event: &apos;close&apos;</a></li>
<li><a href="#all_response_statuscode_1">response.statusCode</a></li>
<li><a href="#all_response_httpversion">response.httpVersion</a></li>
<li><a href="#all_response_headers">response.headers</a></li>
<li><a href="#all_response_trailers">response.trailers</a></li>
<li><a href="#all_response_setencoding_encoding">response.setEncoding([encoding])</a></li>
<li><a href="#all_response_pause">response.pause()</a></li>
<li><a href="#all_response_resume">response.resume()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_https">HTTPS</a><ul>
<li><a href="#all_class_https_server">Class: https.Server</a></li>
<li><a href="#all_https_createserver_options_requestlistener">https.createServer(options, [requestListener])</a></li>
<li><a href="#all_https_request_options_callback">https.request(options, callback)</a></li>
<li><a href="#all_https_get_options_callback">https.get(options, callback)</a></li>
<li><a href="#all_class_https_agent">Class: https.Agent</a></li>
<li><a href="#all_https_globalagent">https.globalAgent</a></li>
</ul>
</li>
<li><a href="#all_url">URL</a><ul>
<li><a href="#all_url_parse_urlstr_parsequerystring_slashesdenotehost">url.parse(urlStr, [parseQueryString], [slashesDenoteHost])</a></li>
<li><a href="#all_url_format_urlobj">url.format(urlObj)</a></li>
<li><a href="#all_url_resolve_from_to">url.resolve(from, to)</a></li>
</ul>
</li>
<li><a href="#all_query_string">Query String</a><ul>
<li><a href="#all_querystring_stringify_obj_sep_eq">querystring.stringify(obj, [sep], [eq])</a></li>
<li><a href="#all_querystring_parse_str_sep_eq">querystring.parse(str, [sep], [eq])</a></li>
<li><a href="#all_querystring_escape">querystring.escape</a></li>
<li><a href="#all_querystring_unescape">querystring.unescape</a></li>
</ul>
</li>
<li><a href="#all_readline">Readline</a><ul>
<li><a href="#all_rl_createinterface_input_output_completer">rl.createInterface(input, output, completer)</a></li>
<li><a href="#all_class_interface">Class: Interface</a><ul>
<li><a href="#all_rl_setprompt_prompt_length">rl.setPrompt(prompt, length)</a></li>
<li><a href="#all_rl_prompt">rl.prompt()</a></li>
<li><a href="#all_rl_question_query_callback">rl.question(query, callback)</a></li>
<li><a href="#all_rl_close">rl.close()</a></li>
<li><a href="#all_rl_pause">rl.pause()</a></li>
<li><a href="#all_rl_resume">rl.resume()</a></li>
<li><a href="#all_rl_write">rl.write()</a></li>
<li><a href="#all_event_line">Event: &apos;line&apos;</a></li>
<li><a href="#all_event_close_9">Event: &apos;close&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_repl">REPL</a><ul>
<li><a href="#all_repl_start_prompt_stream_eval_useglobal_ignoreundefined">repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined])</a></li>
<li><a href="#all_repl_features">REPL Features</a></li>
</ul>
</li>
<li><a href="#all_executing_javascript">Executing JavaScript</a><ul>
<li><a href="#all_vm_runinthiscontext_code_filename">vm.runInThisContext(code, [filename])</a></li>
<li><a href="#all_vm_runinnewcontext_code_sandbox_filename">vm.runInNewContext(code, [sandbox], [filename])</a></li>
<li><a href="#all_vm_runincontext_code_context_filename">vm.runInContext(code, context, [filename])</a></li>
<li><a href="#all_vm_createcontext_initsandbox">vm.createContext([initSandbox])</a></li>
<li><a href="#all_vm_createscript_code_filename">vm.createScript(code, [filename])</a></li>
<li><a href="#all_class_script">Class: Script</a><ul>
<li><a href="#all_script_runinthiscontext">script.runInThisContext()</a></li>
<li><a href="#all_script_runinnewcontext_sandbox">script.runInNewContext([sandbox])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_child_process">Child Process</a><ul>
<li><a href="#all_class_childprocess">Class: ChildProcess</a><ul>
<li><a href="#all_event_exit_1">Event:  &apos;exit&apos;</a></li>
<li><a href="#all_child_stdin">child.stdin</a></li>
<li><a href="#all_child_stdout">child.stdout</a></li>
<li><a href="#all_child_stderr">child.stderr</a></li>
<li><a href="#all_child_pid">child.pid</a></li>
<li><a href="#all_child_kill_signal">child.kill([signal])</a></li>
<li><a href="#all_child_send_message_sendhandle">child.send(message, [sendHandle])</a></li>
</ul>
</li>
<li><a href="#all_child_process_spawn_command_args_options">child_process.spawn(command, [args], [options])</a></li>
<li><a href="#all_child_process_exec_command_options_callback">child_process.exec(command, [options], callback)</a></li>
<li><a href="#all_child_process_execfile_file_args_options_callback">child_process.execFile(file, args, options, callback)</a></li>
<li><a href="#all_child_process_fork_modulepath_args_options">child_process.fork(modulePath, [args], [options])</a></li>
</ul>
</li>
<li><a href="#all_assert">Assert</a><ul>
<li><a href="#all_assert_fail_actual_expected_message_operator">assert.fail(actual, expected, message, operator)</a></li>
<li><a href="#all_assert_value_message_assert_ok_value_message">assert(value, message), assert.ok(value, [message])</a></li>
<li><a href="#all_assert_equal_actual_expected_message">assert.equal(actual, expected, [message])</a></li>
<li><a href="#all_assert_notequal_actual_expected_message">assert.notEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_deepequal_actual_expected_message">assert.deepEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_notdeepequal_actual_expected_message">assert.notDeepEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_strictequal_actual_expected_message">assert.strictEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_notstrictequal_actual_expected_message">assert.notStrictEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_throws_block_error_message">assert.throws(block, [error], [message])</a></li>
<li><a href="#all_assert_doesnotthrow_block_error_message">assert.doesNotThrow(block, [error], [message])</a></li>
<li><a href="#all_assert_iferror_value">assert.ifError(value)</a></li>
</ul>
</li>
<li><a href="#all_tty">TTY</a><ul>
<li><a href="#all_tty_isatty_fd">tty.isatty(fd)</a></li>
<li><a href="#all_tty_setrawmode_mode">tty.setRawMode(mode)</a></li>
</ul>
</li>
<li><a href="#all_zlib">Zlib</a><ul>
<li><a href="#all_examples">Examples</a></li>
<li><a href="#all_constants">Constants</a></li>
<li><a href="#all_zlib_creategzip_options">zlib.createGzip([options])</a></li>
<li><a href="#all_zlib_creategunzip_options">zlib.createGunzip([options])</a></li>
<li><a href="#all_zlib_createdeflate_options">zlib.createDeflate([options])</a></li>
<li><a href="#all_zlib_createinflate_options">zlib.createInflate([options])</a></li>
<li><a href="#all_zlib_createdeflateraw_options">zlib.createDeflateRaw([options])</a></li>
<li><a href="#all_zlib_createinflateraw_options">zlib.createInflateRaw([options])</a></li>
<li><a href="#all_zlib_createunzip_options">zlib.createUnzip([options])</a></li>
<li><a href="#all_class_zlib_gzip">Class: zlib.Gzip</a></li>
<li><a href="#all_class_zlib_gunzip">Class: zlib.Gunzip</a></li>
<li><a href="#all_class_zlib_deflate">Class: zlib.Deflate</a></li>
<li><a href="#all_class_zlib_inflate">Class: zlib.Inflate</a></li>
<li><a href="#all_class_zlib_deflateraw">Class: zlib.DeflateRaw</a></li>
<li><a href="#all_class_zlib_inflateraw">Class: zlib.InflateRaw</a></li>
<li><a href="#all_class_zlib_unzip">Class: zlib.Unzip</a></li>
<li><a href="#all_convenience_methods">Convenience Methods</a></li>
<li><a href="#all_zlib_deflate_buf_callback">zlib.deflate(buf, callback)</a></li>
<li><a href="#all_zlib_deflateraw_buf_callback">zlib.deflateRaw(buf, callback)</a></li>
<li><a href="#all_zlib_gzip_buf_callback">zlib.gzip(buf, callback)</a></li>
<li><a href="#all_zlib_gunzip_buf_callback">zlib.gunzip(buf, callback)</a></li>
<li><a href="#all_zlib_inflate_buf_callback">zlib.inflate(buf, callback)</a></li>
<li><a href="#all_zlib_inflateraw_buf_callback">zlib.inflateRaw(buf, callback)</a></li>
<li><a href="#all_zlib_unzip_buf_callback">zlib.unzip(buf, callback)</a></li>
<li><a href="#all_options">Options</a></li>
<li><a href="#all_memory_usage_tuning">Memory Usage Tuning</a></li>
</ul>
</li>
<li><a href="#all_os">os</a><ul>
<li><a href="#all_os_hostname">os.hostname()</a></li>
<li><a href="#all_os_type">os.type()</a></li>
<li><a href="#all_os_platform">os.platform()</a></li>
<li><a href="#all_os_arch">os.arch()</a></li>
<li><a href="#all_os_release">os.release()</a></li>
<li><a href="#all_os_uptime">os.uptime()</a></li>
<li><a href="#all_os_loadavg">os.loadavg()</a></li>
<li><a href="#all_os_totalmem">os.totalmem()</a></li>
<li><a href="#all_os_freemem">os.freemem()</a></li>
<li><a href="#all_os_cpus">os.cpus()</a></li>
<li><a href="#all_os_networkinterfaces">os.networkInterfaces()</a></li>
</ul>
</li>
<li><a href="#all_debugger">Debugger</a><ul>
<li><a href="#all_watchers">Watchers</a></li>
<li><a href="#all_commands_reference">Commands reference</a><ul>
<li><a href="#all_stepping">Stepping</a></li>
<li><a href="#all_breakpoints">Breakpoints</a></li>
<li><a href="#all_info">Info</a></li>
<li><a href="#all_execution_control">Execution control</a></li>
<li><a href="#all_various">Various</a></li>
</ul>
</li>
<li><a href="#all_advanced_usage">Advanced Usage</a></li>
</ul>
</li>
<li><a href="#all_cluster">Cluster</a><ul>
<li><a href="#all_cluster_fork">cluster.fork()</a></li>
<li><a href="#all_cluster_ismaster">cluster.isMaster</a></li>
<li><a href="#all_cluster_isworker">cluster.isWorker</a></li>
<li><a href="#all_event_death">Event: &apos;death&apos;</a></li>
</ul>
</li>
<li><a href="#all_appendix_1_third_party_modules">Appendix 1 - Third Party Modules</a></li>
</ul>

          </div>

          <div id="apicontent">
            <h1>About this Documentation<span><a class="mark" href="#all_about_this_documentation" id="all_about_this_documentation">#</a></span></h1>
<!-- type=misc -->

<!--
The goal of this documentation is to comprehensively explain the Node.js
API, both from a reference as well as a conceptual point of view.  Each
section describes a built-in module or high-level concept.

Where appropriate, property types, method arguments, and the arguments
provided to event handlers are detailed in a list underneath the topic
heading.

Every `.html` document has a corresponding `.json` document presenting
the same information in a structured manner.  This feature is
experimental, and added for the benefit of IDEs and other utilities that
wish to do programmatic things with the documentation.

Every `.html` and `.json` file is generated based on the corresponding
`.markdown` file in the `doc/api/` folder in node's source tree.  The
documentation is generated using the `tools/doc/generate.js` program.
The HTML template is located at `doc/template.html`.
-->

<p>このドキュメントのゴールは、Node.js の API についてリファレンスとしても，
概念的な視点としても，包括的な説明をすることです。
それぞれのセクションは組込のモジュールまたは高水準の概念について記述します。

</p>
<p>必要に応じて、プロパティの型やメソッドの引数、そしてイベントハンドラに
与えられる引数などの詳細は見出し直後のリストで与えられます。

</p>
<p>すべての <code>.html</code> ドキュメントは、対応する <code>.json</code> ドキュメントを持ちます。
それは同じ情報を同様の構造で表現します。
これは実験的で、ドキュメントをプログラム的に扱いたい IDE や他の
ユーティリティのために加えられました。

</p>
<p>すべての <code>.html</code> と <code>.json</code> ファイルは、node ソースツリーの <code>doc/api/</code>
フォルダにある、対応する <code>.markdown</code> ファイルを基に生成されます。
ドキュメントの生成には <code>tools/doc/generate.js</code> が使われます。
HTML のテンプレートは <code>doc/template.html</code> にあります。

</p>
<h2>Stability Index<span><a class="mark" href="#all_stability_index" id="all_stability_index">#</a></span></h2>
<!--type=misc-->

<!--
Throughout the documentation, you will see indications of a section's
stability.  The Node.js API is still somewhat changing, and as it
matures, certain parts are more reliable than others.  Some are so
proven, and so relied upon, that they are unlikely to ever change at
all.  Others are brand new and experimental, or known to be hazardous
and in the process of being redesigned.

The notices look like this:
-->

<p>ドキュメント全体を通して、セクションの安定度に関する目安を見ることが
できるでしょう。
Node.js の API はまだ少し変更されます。
それが成熟することにより、ある部分は他よりも信頼できるようになります。
いくつかはそのように証明され、したがって信頼され、それらはおそらく
変更されそうもありません。
その他は新しくて実験的か、危険が知られていたり、再実装が始まっていたりします。

</p>
<p>通知は次のようです:

</p>
<pre><code>Stability: 1 Experimental</code></pre>
<!--
The stability indices are as follows:
-->

<p>安定度は以下を示します:

</p>
<!--
* **0 - Deprecated**  This feature is known to be problematic, and changes are
planned.  Do not rely on it.  Use of the feature may cause warnings.  Backwards
compatibility should not be expected.

* **1 - Experimental**  This feature was introduced recently, and may change
or be removed in future versions.  Please try it out and provide feedback.
If it addresses a use-case that is important to you, tell the node core team.

* **2 - Unstable**  The API is in the process of settling, but has not yet had
sufficient real-world testing to be considered stable. Backwards-compatibility
will be maintained if reasonable.

* **3 - Stable**  The API has proven satisfactory, but cleanup in the underlying
code may cause minor changes.  Backwards-compatibility is guaranteed.

* **4 - API Frozen**  This API has been tested extensively in production and is
unlikely to ever have to change.

* **5 - Locked**  Unless serious bugs are found, this code will not ever
change.  Please do not suggest changes in this area; they will be refused.
-->

<ul>
<li><strong>0 - 廃止予定</strong>  この機能には問題があることが知られていて、
変更が計画されています。これに依存しないでください。
この機能を使用すると警告が出されるでしょう。
後方互換性を期待すべきではありません。</li>
</ul>
<ul>
<li><strong>1 - 実験的 </strong>  この機能は最近導入され、将来のバージョンで変更されるか
削除されるかもしれません。それを試してフィードバックをしてください。
重要なユースケースで使われるなら、node コアチームに教えてください。</li>
</ul>
<ul>
<li><strong>2 - 不安定</strong>  API は安定化の途中ですが、まだ安定していると考えられるほどには
現実世界でテストされていません。
もし合理的なら後方互換性が維持されるでしょう。</li>
</ul>
<ul>
<li><strong>3 - 安定</strong>  API は要求を満たすことがわかりましたが、実装コードを
クリーンナップするために小さな変更が行われるかもしれません。
後方互換性は保証されます。</li>
</ul>
<ul>
<li><strong>4 - API 凍結</strong>  API は実運用で広範囲にテストされており、
おそらく変更されることはありません。</li>
</ul>
<ul>
<li><strong>5 - 固定 </strong>  深刻なバグが見つからない限り、コードは変更されません。
このエリアの変更を提案しないでください; そえは拒否されます。</li>
</ul>
<h2>JSON Output<span><a class="mark" href="#all_json_output" id="all_json_output">#</a></span></h2>
<pre><code>Stability: 1 - Experimental</code></pre>
<!--
Every HTML file in the markdown has a corresponding JSON file with the
same data.

This feature is new as of node v0.6.12.  It is experimental.
-->

<p>markdown から作られる全ての HTML ファイルは、対応する JSON ファイルを持ちます。

</p>
<p>これは v0.6.12 からの新機能で、実験的です。

</p>
<h1>Synopsis<span><a class="mark" href="#all_synopsis" id="all_synopsis">#</a></span></h1>
<!--type=misc-->

<!--
An example of a [web server](http.html) written with Node which responds with 'Hello
World':
-->

<p>&apos;Hello World&apos; と返答する Node で書かれたWebサーバの例:

</p>
<pre><code>var http = require(&apos;http&apos;);

http.createServer(function (request, response) {
  response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
  response.end(&apos;Hello World\n&apos;);
}).listen(8124);

console.log(&apos;Server running at http://127.0.0.1:8124/&apos;);</code></pre>
<!--
To run the server, put the code into a file called `example.js` and execute
it with the node program
-->

<p>このサーバを実行するには、コードを <code>example.js</code> というファイルに保存し、
node コマンドで実行してください。

</p>
<pre><code>&gt; node example.js
Server running at http://127.0.0.1:8124/</code></pre>
<!--
All of the examples in the documentation can be run similarly.
-->

<p>このドキュメントの全てのサンプルは同じように実行することができます。

</p>
<h1>Global Objects<span><a class="mark" href="#all_global_objects" id="all_global_objects">#</a></span></h1>
<!-- type=misc -->

<!--
These objects are available in all modules. Some of these objects aren't
actually in the global scope but in the module scope - this will be noted.
-->

<p>これらのオブジェクトは全てのモジュールで有効です。
これらのオブジェクトのいくつかは実際はグローバルスコープではなくモジュールスコープです - 注意してください。

</p>
<h2>global<span><a class="mark" href="#all_global" id="all_global">#</a></span></h2>
<!-- type=global -->

<!--
* {Object} The global namespace object.
-->

<ul>
<li>{Object} グローバルなネームスペースのオブジェクト</li>
</ul>
<!--
In browsers, the top-level scope is the global scope. That means that in
browsers if you're in the global scope `var something` will define a global
variable. In Node this is different. The top-level scope is not the global
scope; `var something` inside a Node module will be local to that module.
-->

<p>ブラウザでは、トップレベルのスコープはグローバルスコープです。
これは、ブラウザではグローバルスコープで <code>var something</code> と定義するとグローバル変数になることを意味します。
Node では異なります。
トップレベルのスコープはグローバルスコープではありません;
Node のモジュール内での <code>var something</code> はそのモジュールでローカルになります。

</p>
<h2>process<span><a class="mark" href="#all_process" id="all_process">#</a></span></h2>
<!-- type=global -->

<ul>
<li>{Object}</li>
</ul>
<!--
The process object. See the [process object](process.html#process) section.
-->

<p>プロセスオブジェクトです。<a href="process.html#process">process object</a> の節を参照してください。

</p>
<h2>console<span><a class="mark" href="#all_console" id="all_console">#</a></span></h2>
<!-- type=global -->

<ul>
<li>{Object}</li>
</ul>
<!--
Used to print to stdout and stderr. See the [stdio](stdio.html) section.
-->

<p>標準出力および標準エラー出力へのプリントに使われます。
<a href="stdio.html">標準入出力</a> を参照してください。

</p>
<h2>Buffer<span><a class="mark" href="#all_buffer" id="all_buffer">#</a></span></h2>
<!-- type=global -->

<ul>
<li>{Object}</li>
</ul>
<!--
Used to handle binary data. See the [buffer section](buffer.html).
-->

<p>バイナリデータを扱うために使われます。
<a href="buffers.html">buffer セクション</a> を参照してください。

</p>
<h2>require()<span><a class="mark" href="#all_require" id="all_require">#</a></span></h2>
<!-- type=var -->

<ul>
<li>{Function}</li>
</ul>
<!--
To require modules. See the [Modules](modules.html#modules) section.
`require` isn't actually a global but rather local to each module.
-->

<p>require モジュールを指します。<a href="modules.html#modules">モジュール</a> の節を参照してください。
<code>require</code> は実際はグローバルではなく、各モジュール毎のローカルです。

</p>
<h3>require.resolve()<span><a class="mark" href="#all_require_resolve" id="all_require_resolve">#</a></span></h3>
<!--
Use the internal `require()` machinery to look up the location of a module,
but rather than loading the module, just return the resolved filename.
-->

<p><code>require()</code> の内部でモジュールの位置を検索するために使われます。
モジュールのロードは行わず、ファイル名を解決して返すだけです。

</p>
<h3>require.cache<span><a class="mark" href="#all_require_cache" id="all_require_cache">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<!--
Modules are cached in this object when they are required. By deleting a key
value from this object, the next `require` will reload the module.
-->

<p>モジュールが要求されると、このオブジェクトの中にキャッシュされます。
このオブジェクトからキーと値を削除すると、次にそのモジュールが
<code>require</code> されたときにリロードされます。

</p>
<h2>__filename<span><a class="mark" href="#all_filename" id="all_filename">#</a></span></h2>
<!-- type=var -->

<ul>
<li>{String}</li>
</ul>
<!--
The filename of the code being executed.  This is the resolved absolute path
of this code file.  For a main program this is not necessarily the same
filename used in the command line.  The value inside a module is the path
to that module file.
-->

<p>実行されているコードのファイル名です。これは解決された絶対パスです。
メインプログラムでは、必ずしもコマンドライン引数で使われたファイル名と
同じではありません。
モジュールの中では、この値はそのモジュールファイルのパスとなります。

</p>
<!--
Example: running `node example.js` from `/Users/mjr`
-->

<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する

</p>
<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>
<!--
`__filename` isn't actually a global but rather local to each module.
-->

<p><code>__filename</code> は実際はグローバルではなく、各モジュール毎のローカルです。

</p>
<h2>__dirname<span><a class="mark" href="#all_dirname" id="all_dirname">#</a></span></h2>
<!-- type=var -->

<ul>
<li>{String}</li>
</ul>
<!--
The name of the directory that the currently executing script resides in.
-->

<p>現在実行されているスクリプトが存在するディレクトリの名前です。

</p>
<!--
Example: running `node example.js` from `/Users/mjr`
-->

<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する

</p>
<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>
<!--
`__dirname` isn't actually a global but rather local to each module.
-->

<p><code>__dirname</code> は実際はグローバルではなく、各モジュール毎のローカルです。


</p>
<h2>module<span><a class="mark" href="#all_module" id="all_module">#</a></span></h2>
<!-- type=var -->

<ul>
<li>{Object}</li>
</ul>
<!--
A reference to the current module. In particular
`module.exports` is the same as the `exports` object. See `src/node.js`
for more information.
`module` isn't actually a global but rather local to each module.
-->

<p>現在のモジュールへの参照です。
特に <code>module.exports</code> は <code>exports</code> オブジェクトと同じです。
より詳しくは <code>src/node.js</code> を参照してください。
<code>module</code> は実際はグローバルではなく、各モジュール毎のローカルです。

</p>
<h2>exports<span><a class="mark" href="#all_exports" id="all_exports">#</a></span></h2>
<!-- type=var -->

<!--
An object which is shared between all instances of the current module and
made accessible through `require()`.
`exports` is the same as the `module.exports` object. See `src/node.js`
for more information.
`exports` isn't actually a global but rather local to each module.
-->

<p>現在のモジュールの全てのインスタンス間で共有されるオブジェクトで、
<code>require</code> を通じてアクセス可能になります。
<code>exports</code> は <code>module.exports</code> と同じオブジェクトです。
より詳しくは <code>src/node.js</code> を参照してください。
<code>exports</code> は実際はグローバルではなく、各モジュール毎のローカルです。

</p>
<!--
See the [module system documentation](modules.html) for more
information.

See the [module section](modules.html) for more information.
-->

<p>より詳細は<a href="modules.html">モジュールのセクション</a> を参照してください。

</p>
<h2>setTimeout(cb, ms)<span><a class="mark" href="#all_settimeout_cb_ms" id="all_settimeout_cb_ms">#</a></span></h2>
<h2>clearTimeout(t)<span><a class="mark" href="#all_cleartimeout_t" id="all_cleartimeout_t">#</a></span></h2>
<h2>setInterval(cb, ms)<span><a class="mark" href="#all_setinterval_cb_ms" id="all_setinterval_cb_ms">#</a></span></h2>
<h2>clearInterval(t)<span><a class="mark" href="#all_clearinterval_t" id="all_clearinterval_t">#</a></span></h2>
<!--type=global-->

<!--
The timer functions are global variables. See the [timers](timers.html) section.
-->

<p>タイマー関数はグローバル変数です。<a href="timers.html">タイマー</a> を参照してください。

</p>
<h1>console<span><a class="mark" href="#all_console_1" id="all_console_1">#</a></span></h1>
<pre><code>Stability: 4 - API Frozen</code></pre>
<ul>
<li>{Object}</li>
</ul>
<!--type=global-->

<!--
For printing to stdout and stderr.  Similar to the console object functions
provided by most web browsers, here the output is sent to stdout or stderr.
-->

<p>標準出力と標準エラーに出力するためのものです。
ほとんどのブラウザで提供されているコンソールオブジェクトと同様ですが、
出力は標準出力か標準エラー出力に送られます。


</p>
<h2>console.log()<span><a class="mark" href="#all_console_log" id="all_console_log">#</a></span></h2>
<!--
Prints to stdout with newline. This function can take multiple arguments in a
`printf()`-like way. Example:
-->

<p>改行を伴って標準出力へプリントします。
この関数は <code>printf()</code> のように複数の引数を受け付けます。

</p>
<pre><code>console.log(&apos;count: %d&apos;, count);</code></pre>
<!--
If formatting elements are not found in the first string then `util.inspect`
is used on each argument.
See [util.format()](util.html#util.format) for more information.
-->

<p>最初の引数文字列からフォーマット要素が見つからなかった場合は、
<code>util.inspect</code> が各引数に使われます。
より詳細は <a href="util.html#util.format">util.format()</a> を参照してください。

</p>
<h2>console.info()<span><a class="mark" href="#all_console_info" id="all_console_info">#</a></span></h2>
<!--
Same as `console.log`.
-->

<p><code>console.log</code> と同じです。

</p>
<h2>console.warn()<span><a class="mark" href="#all_console_warn" id="all_console_warn">#</a></span></h2>
<h2>console.error()<span><a class="mark" href="#all_console_error" id="all_console_error">#</a></span></h2>
<!--
Same as `console.log` but prints to stderr.
-->

<p><code>console.log</code> と同様ですが、標準エラー出力にプリントします。

</p>
<h2>console.dir(obj)<span><a class="mark" href="#all_console_dir_obj" id="all_console_dir_obj">#</a></span></h2>
<!--
Uses `util.inspect` on `obj` and prints resulting string to stderr.
-->

<p><code>util.inspect</code> を使って <code>obj</code> を文字列化した結果を標準エラー出力にプリントします。

</p>
<h2>console.time(label)<span><a class="mark" href="#all_console_time_label" id="all_console_time_label">#</a></span></h2>
<!--
Mark a time.
-->

<p>タイマを作成します。


</p>
<h2>console.timeEnd(label)<span><a class="mark" href="#all_console_timeend_label" id="all_console_timeend_label">#</a></span></h2>
<!--
Finish timer, record output. Example
-->

<p>タイマを終了し、結果を出力します。例

</p>
<pre><code>console.time(&apos;100-elements&apos;);
for (var i = 0; i &lt; 100; i++) {
  ;
}
console.timeEnd(&apos;100-elements&apos;);</code></pre>
<h2>console.trace()<span><a class="mark" href="#all_console_trace" id="all_console_trace">#</a></span></h2>
<!--
Print a stack trace to stderr of the current position.
-->

<p>現在のスタックトレースを標準エラー出力にプリントします。

</p>
<h2>console.assert()<span><a class="mark" href="#all_console_assert" id="all_console_assert">#</a></span></h2>
<!--
Same as `assert.ok()`.
-->

<p><code>assert.ok()</code> と同じです。

</p>
<h1>Timers<span><a class="mark" href="#all_timers" id="all_timers">#</a></span></h1>
<pre><code>Stability: 5 - Locked</code></pre>
<!--
All of the timer functions are globals.  You do not need to `require()`
this module in order to use them.
-->

<p>全てのタイマ関数はグローバルです。
このモジュールを使うために <code>require()</code> をする必要はありません。

</p>
<h2>setTimeout(callback, delay, [arg], [...])<span><a class="mark" href="#all_settimeout_callback_delay_arg" id="all_settimeout_callback_delay_arg">#</a></span></h2>
<!--
To schedule execution of a one-time `callback` after `delay` milliseconds. Returns a
`timeoutId` for possible use with `clearTimeout()`. Optionally you can
also pass arguments to the callback.
-->

<p><code>delay</code> ミリ秒が経過した後で、
<code>callback</code> が一度だけ実行されるようにスケジュールします。
<code>clearTimeout()</code> で使うことができる <code>timeoutId</code> を返します。
オプションとして、コールバックへの引数を渡すこともできます。

</p>
<!--
It is important to note that your callback will probably not be called in exactly
`delay` milliseconds - Node.js makes no guarantees about the exact timing of when
the callback will fire, nor of the ordering things will fire in. The callback will
be called as close as possible to the time specified.
-->

<p>コールバックが正確に <code>delay</code> ミリ秒後に呼び出されるとは限らない点に
注目することは重要です - 
Node.js はコールバックが呼び出される正確なタイミングも、
呼び出される順番も保証しません。
コールバックはできるだけ指定された時間に近いタイミングで呼び出されます。

</p>
<h2>clearTimeout(timeoutId)<span><a class="mark" href="#all_cleartimeout_timeoutid" id="all_cleartimeout_timeoutid">#</a></span></h2>
<!--
Prevents a timeout from triggering.
-->

<p>タイムアウトがトリガーされるのを止めます。

</p>
<h2>setInterval(callback, delay, [arg], [...])<span><a class="mark" href="#all_setinterval_callback_delay_arg" id="all_setinterval_callback_delay_arg">#</a></span></h2>
<!--
To schedule the repeated execution of `callback` every `delay` milliseconds.
Returns a `intervalId` for possible use with `clearInterval()`. Optionally
you can also pass arguments to the callback.
-->

<p><code>delay</code> ミリ秒が経過するごとに繰り返し <code>callback</code> が実行されるようにスケジュールします。
<code>clearInterval()</code> で使うことができる <code>intervalId</code> を返します。
オプションとして、コールバックへの引数を渡すこともできます。

</p>
<h2>clearInterval(intervalId)<span><a class="mark" href="#all_clearinterval_intervalid" id="all_clearinterval_intervalid">#</a></span></h2>
<!--
Stops a interval from triggering.
-->

<p>インターバルがトリガーされるのを止めます。

</p>
<h1>Modules<span><a class="mark" href="#all_modules" id="all_modules">#</a></span></h1>
<pre><code>Stability: 5 - Locked</code></pre>
<!--name=module-->

<!--
Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, `foo.js` loads the module
`circle.js` in the same directory.
-->

<p>Node はシンプルなモジュールローディングシステムを持ちます。
Node では、ファイルとモジュールは１対１に対応します。
例として、 <code>foo.js</code> は、同じディレクトリにある <code>circle.js</code> をロードしています。

</p>
<!--
The contents of `foo.js`:
-->

<p><code>foo.js</code> の内容:

</p>
<pre><code>var circle = require(&apos;./circle.js&apos;);
console.log( &apos;The area of a circle of radius 4 is &apos;
           + circle.area(4));</code></pre>
<!--
The contents of `circle.js`:
-->

<p><code>circle.js</code> の内容:

</p>
<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>
<!--
The module `circle.js` has exported the functions `area()` and
`circumference()`.  To export an object, add to the special `exports`
object.

Variables
local to the module will be private. In this example the variable `PI` is
private to `circle.js`.

The module system is implemented in the `require("module")` module.
-->

<p><code>circle.js</code> モジュールは <code>area()</code> と <code>circumference()</code> をエクスポートしています。
オブジェクトをエクスポートするには、 <code>exports</code> という特別なオブジェクトに加えます。

</p>
<p>モジュールのローカル変数はプライベートです。
この例の場合、変数 <code>PI</code> は <code>circle.js</code> のプライベート変数です。

</p>
<p>モジュールシステムは <code>require(&quot;module&quot;)</code> モジュールによって実装されます。

</p>
<h2>Cycles<span><a class="mark" href="#all_cycles" id="all_cycles">#</a></span></h2>
<!--type=misc-->

<!--
When there are circular `require()` calls, a module might not be
done being executed when it is returned.

Consider this situation:
-->

<p><code>require()</code> が循環的に呼び出される場合、実行が完了していないモジュールが
返されることがあります。

</p>
<p>次の状況を考えてください:

</p>
<p><code>a.js</code>:

</p>
<pre><code>console.log(&apos;a starting&apos;);
exports.done = false;
var b = require(&apos;./b.js&apos;);
console.log(&apos;in a, b.done = %j&apos;, b.done);
exports.done = true;
console.log(&apos;a done&apos;);</code></pre>
<p><code>b.js</code>:

</p>
<pre><code>console.log(&apos;b starting&apos;);
exports.done = false;
var a = require(&apos;./a.js&apos;);
console.log(&apos;in b, a.done = %j&apos;, a.done);
exports.done = true;
console.log(&apos;b done&apos;);</code></pre>
<p><code>main.js</code>:

</p>
<pre><code>console.log(&apos;main starting&apos;);
var a = require(&apos;./a.js&apos;);
var b = require(&apos;./b.js&apos;);
console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done);</code></pre>
<!--
When `main.js` loads `a.js`, then `a.js` in turn loads `b.js`.  At that
point, `b.js` tries to load `a.js`.  In order to prevent an infinite
loop an **unfinished copy** of the `a.js` exports object is returned to the
`b.js` module.  `b.js` then finishes loading, and its exports object is
provided to the `a.js` module.

By the time `main.js` has loaded both modules, they're both finished.
The output of this program would thus be:
-->

<p><code>main.js</code> が <code>a.js</code> をロードすると、<code>a.js</code> は <code>b.js</code> をロードします。
ポイントは、<code>b.js</code> は <code>a.js</code> のロードを試みることです。
無限ループを避けるため、<code>a.js</code> がエクスポートしたオブジェクトの
<strong>未完了のコピー</strong> が <code>b.js</code> モジュールに返されます。
<code>b.js</code> のロードが完了すると、エクスポートされたオブジェクトが <code>a.js</code>
モジュールに提供されます。

</p>
<p><code>main.js</code> が両方のモジュールをロードするまでには、どちらも完了します。
このプログラムの出力はこのようになります:

</p>
<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true</code></pre>
<!--
If you have cyclic module dependencies in your program, make sure to
plan accordingly.
-->

<p>プログラムが循環参照するモジュールを持つ場合は、計画が適切か確認してください。


</p>
<h2>Core Modules<span><a class="mark" href="#all_core_modules" id="all_core_modules">#</a></span></h2>
<!--type=misc-->

<!--
Node has several modules compiled into the binary.  These modules are
described in greater detail elsewhere in this documentation.

The core modules are defined in node's source in the `lib/` folder.

Core modules are always preferentially loaded if their identifier is
passed to `require()`.  For instance, `require('http')` will always
return the built in HTTP module, even if there is a file by that name.
-->

<p>Node にはバイナリにコンパイル済みのいくつかのモジュールがあります。
これらのモジュールについては、このドキュメントの他の場所でより詳しく記述されています。

</p>
<p>コアモジュールは、 Node のソースの <code>lib/</code> フォルダにて定義されています。

</p>
<p><code>require()</code> では常にコアモジュールの識別名を優先的に解釈します。
例えば <code>require(&apos;http&apos;)</code> は、例え同名のファイルが存在していたとしても、常にビルトイインの HTTP モジュールを返します。

</p>
<h2>File Modules<span><a class="mark" href="#all_file_modules" id="all_file_modules">#</a></span></h2>
<!--type=misc-->

<!--
If the exact filename is not found, then node will attempt to load the
required filename with the added extension of `.js`, `.json`, and then `.node`.

`.js` files are interpreted as JavaScript text files, and `.json` files are
parsed as JSON text files. `.node` files are interpreted as compiled addon
modules loaded with `dlopen`.

A module prefixed with `'/'` is an absolute path to the file.  For
example, `require('/home/marco/foo.js')` will load the file at
`/home/marco/foo.js`.

A module prefixed with `'./'` is relative to the file calling `require()`.
That is, `circle.js` must be in the same directory as `foo.js` for
`require('./circle')` to find it.

Without a leading '/' or './' to indicate a file, the module is either a
"core module" or is loaded from a `node_modules` folder.
-->

<p>指定された名前のファイルが見つからなければ、 Node は指定されたファイル名に
<code>.js</code>、<code>.json</code>、または <code>.node</code> を付けたものを読み込もうとします。

</p>
<p><code>.js</code> ファイルは JavaScript ファイルとして解釈され、
<code>.json</code> ファイルは JSON ファイルとして解釈されます。
一方 <code>.node</code> ファイルはコンパイル済みのアドオンモジュールとして解釈され、
<code>dlopen</code> を使って読み込まれます。

</p>
<p><code>&apos;/&apos;</code> から始まるモジュールは、ファイルへの絶対パスと見なされます。
例えば、 <code>require(&apos;/home/marco/foo.js&apos;)</code> は <code>/home/macro/foo.js</code> を読み込みます。

</p>
<p><code>&apos;./&apos;</code> から始まるモジュールは、 <code>require()</code> を呼んだファイルからの相対パスになります。
すなわち、 <code>foo.js</code> から <code>require(&apos;./circle&apos;)</code> によって <code>circle.js</code> を読み込むには、 <code>circle.js</code> は <code>foo.js</code> と同じディレクトリに存在していなければなりません。

</p>
<p>&apos;/&apos; や &apos;./&apos; が先頭になければ、モジュールは &quot;コアモジュール&quot; であるかもしくは <code>node_modules</code> フォルダから読み込まれることになります。

</p>
<h2>Loading from <code>node_modules</code> Folders<span><a class="mark" href="#all_loading_from_node_modules_folders" id="all_loading_from_node_modules_folders">#</a></span></h2>
<!--type=misc-->

<!--
If the module identifier passed to `require()` is not a native module,
and does not begin with `'/'`, `'../'`, or `'./'`, then node starts at the
parent directory of the current module, and adds `/node_modules`, and
attempts to load the module from that location.

If it is not found there, then it moves to the parent directory, and so
on, until the root of the tree is reached.

For example, if the file at `'/home/ry/projects/foo.js'` called
`require('bar.js')`, then node would look in the following locations, in
this order:
-->

<p>もし <code>require()</code> に渡されたモジュール識別子がネイティブモジュールではなく、かつ  <code>&apos;/&apos;</code> や <code>&apos;../&apos;</code> や <code>&apos;./&apos;</code> から始まらないならば、 Node は現在のモジュールの親ディレクトリに <code>&apos;/node_modules&apos;</code> を付与してそこからモジュールを読み込もうとします。

</p>
<p>そこに見つからない場合はさらに親ディレクトリに移動し、モジュールが見つかるか root ディレクトリに到達するまで同様のことを繰り返していきます。

</p>
<p>例えば <code>&apos;/home/ry/projects/foo.js&apos;</code> の中で <code>require(&apos;bar.js&apos;)</code> を呼んでいた場合、 Node は下記の位置を上から順番に見ていきます。

</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<!--
This allows programs to localize their dependencies, so that they do not
clash.
-->

<p>この仕組みによって、プログラムはクラッシュを避けるために依存関係を上書きすることができるのです。

</p>
<h2>Folders as Modules<span><a class="mark" href="#all_folders_as_modules" id="all_folders_as_modules">#</a></span></h2>
<!--type=misc-->

<!--
It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library.
There are three ways in which a folder may be passed to `require()` as
an argument.

The first is to create a `package.json` file in the root of the folder,
which specifies a `main` module.  An example package.json file might
look like this:
-->

<p>プログラムとライブラリをディレクトリ内にまとめて、そのエントリポイントを提示するという便利な方法もあります。
それには <code>require()</code> に引数として何を渡すかによって3通りの方法があります。

</p>
<p>1つ目は、 <code>package.json</code> というファイルをフォルダ直下に作成し、 <code>main</code> モジュールを指定するという方法です。
例えば、 package.json は以下のようなファイルになります:

</p>
<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>
<!--
If this was in a folder at `./some-library`, then
`require('./some-library')` would attempt to load
`./some-library/lib/some-library.js`.

This is the extent of Node's awareness of package.json files.

If there is no package.json file present in the directory, then node
will attempt to load an `index.js` or `index.node` file out of that
directory.  For example, if there was no package.json file in the above
example, then `require('./some-library')` would attempt to load:
-->

<p>もし <code>./some-library</code> フォルダ内にこのファイルがあれば、 <code>require(&apos;./some-library&apos;)</code> は <code>./some-library/lib/some-library.js</code> を読みにいきます。

</p>
<p>これは、 Node が package.json の存在に気づくことによってもたらされます。

</p>
<p>もし package.json がディレクトリに存在していなければ、 Node はそのディレクトリで <code>index.js</code> もしくは <code>index.node</code> を探します。
例えば、もし上の例で package.json がいるが存在しないとすると、 <code>require(&apos;./some-library&apos;)</code> は以下のファイルを読み込もうとします: 

</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>
<h2>Caching<span><a class="mark" href="#all_caching" id="all_caching">#</a></span></h2>
<!--type=misc-->

<!--
Modules are cached after the first time they are loaded.  This means
(among other things) that every call to `require('foo')` will get
exactly the same object returned, if it would resolve to the same file.
-->

<p>モジュールは初めて読み込まれたときにキャッシュされます。
すなわち（他のキャッシュと同様に） <code>require(&apos;foo&apos;)</code> を呼ぶたびに、もし引数の意味するものが同一のファイルであったなら全く同一のオブジェクトが返されます。

</p>
<!--
Multiple calls to `require('foo')` may not cause the module code to be
executed multiple times.  This is an important feature.  With it,
"partially done" objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.
-->

<p><code>require(&apos;foo&apos;)</code> が複数回呼び出されても、モジュールが複数回実行されることにはなりません。
これは重要な特徴です。
そのため、「部分的に完了した」オブジェクトを返すことで、
推移的な依存関係が循環していてもロードすることができます。

</p>
<!--
If you want to have a module execute code multiple times, then export a
function, and call that function.
-->

<p>もしモジュールを複数回実行したければ、関数を公開して、
その関数を呼び出してください。

</p>
<h3>Module Caching Caveats<span><a class="mark" href="#all_module_caching_caveats" id="all_module_caching_caveats">#</a></span></h3>
<!--type=misc-->

<!--
Modules are cached based on their resolved filename.  Since modules may
resolve to a different filename based on the location of the calling
module (loading from `node_modules` folders), it is not a *guarantee*
that `require('foo')` will always return the exact same object, if it
would resolve to different files.
-->

<p>モジュールは解決されたファイル名に基づいてキャッシュされます。
異なる場所にあるモジュールから呼び出されたモジュールは、
(<code>node_module</code> フォルダからロードされるため) 異なったファイル名で
解決されることがあるため、 <code>require(&apos;foo&apos;)</code> が常に同じオブジェクトを返す
<em>保証</em>はなく、異なるファイルとして解決されます。

</p>
<h2>The <code>module</code> Object<span><a class="mark" href="#all_the_module_object" id="all_the_module_object">#</a></span></h2>
<!-- type=var -->

<p>!-- name=module --&gt;

</p>
<ul>
<li>{Object}</li>
</ul>
<!--
In each module, the `module` free variable is a reference to the object
representing the current module.  In particular
`module.exports` is the same as the `exports` object.
`module` isn't actually a global but rather local to each module.
-->

<p>どのモジュールでも、<code>module</code> 自由変数は現在のモジュールを表現するオブジェクトを
参照します。特に、<code>module.exports</code> は <code>exports</code> オブジェクトと同じです。
<code>module</code> は実際はグローバルではなく、各モジュールにローカルです。

</p>
<h3>module.exports<span><a class="mark" href="#all_module_exports" id="all_module_exports">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>The <code>exports</code> object is created by the Module system. Sometimes this is not
acceptable, many want their module to be an instance of some class. To do this
assign the desired export object to <code>module.exports</code>. For example suppose we
were making a module called <code>a.js</code>
--&gt;

</p>
<p><code>exports</code> オブジェクトはモジュールシステムによって作成されます。
時々これは受け入れられず、多くのモジュールは何らかのクラスのインスタンスであることを望みます。
それには公開したいオブジェクトを <code>module.exports</code> に割り当てます。
例えば <code>a.js</code> と呼ばれるモジュールを作るとしたら


</p>
<pre><code>var EventEmitter = require(&apos;events&apos;).EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the &apos;ready&apos; event from the module itself.
setTimeout(function() {
  module.exports.emit(&apos;ready&apos;);
}, 1000);</code></pre>
<!--
Then in another file we could do
-->

<p>そして別のファイルで

</p>
<pre><code>var a = require(&apos;./a&apos;);
a.on(&apos;ready&apos;, function() {
  console.log(&apos;module a is ready&apos;);
});</code></pre>
<!--
Note that assignment to `module.exports` must be done immediately. It cannot be
done in any callbacks.  This does not work:
-->

<p><code>module.exports</code> への代入はすぐに行わなければなりません。
コールバックの中ではできません。以下は動きません。

</p>
<p>x.js:

</p>
<pre><code>setTimeout(function() {
  module.exports = { a: &quot;hello&quot; };
}, 0);</code></pre>
<p>y.js:

</p>
<pre><code>var x = require(&apos;./x&apos;);
console.log(x.a);</code></pre>
<h3>module.require(id)<span><a class="mark" href="#all_module_require_id" id="all_module_require_id">#</a></span></h3>
<!--
* `id` {String}
* Return: {Object} `exports` from the resolved module
-->

<ul>
<li><code>id</code> {String}</li>
<li>Return: {Object} 解決されたモジュールの <code>exports</code></li>
</ul>
<!--
The `module.require` method provides a way to load a module as if
`require()` was called from the original module.
-->

<p><code>module.require</code> メソッドは、元のモジュールが <code>require()</code>
を呼び出したかのようにモジュールをロードするために提供されています。

</p>
<!--
Note that in order to do this, you must get a reference to the `module`
object.  Since `require()` returns the `exports`, and the `module` is
typically *only* available within a specific module's code, it must be
explicitly exported in order to be used.
-->

<p>それには <code>module</code> オブジェクトの参照が必要なことに注意してください。
<code>require()</code> が <code>exports</code> を返した後、一般的に <code>module</code> 
はそのモジュールのコードで <em>のみ</em> 利用可能です。
それが使われるようにするには、明示的にエクスポートする必要があります。

</p>
<h3>module.id<span><a class="mark" href="#all_module_id" id="all_module_id">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">String</span></li>
</div></ul>
<!--
The identifier for the module.  Typically this is the fully resolved
filename.
-->

<p>モジュールの識別子。通常は完全に解決されたファイル名です。


</p>
<h3>module.filename<span><a class="mark" href="#all_module_filename" id="all_module_filename">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">String</span></li>
</div></ul>
<!--
The fully resolved filename to the module.
-->

<p>完全に解決されたモジュールのファイル名です。


</p>
<h3>module.loaded<span><a class="mark" href="#all_module_loaded" id="all_module_loaded">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<!--
Whether or not the module is done loading, or is in the process of
loading.
-->

<p>モジュールのロードが完了したか，あるいはローディング中かを示します。


</p>
<h3>module.parent<span><a class="mark" href="#all_module_parent" id="all_module_parent">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Module Object</span></li>
</div></ul>
<!--
The module that required this one.
-->

<p>このモジュールを要求したモジュールです。


</p>
<h3>module.children<span><a class="mark" href="#all_module_children" id="all_module_children">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Array</span></li>
</div></ul>
<!--
The module objects required by this one.
-->

<p>このモジュールが要求したモジュールです。



</p>
<h2>All Together...<span><a class="mark" href="#all_all_together" id="all_all_together">#</a></span></h2>
<!-- type=misc -->

<!--
To get the exact filename that will be loaded when `require()` is called, use
the `require.resolve()` function.
-->

<p><code>require()</code> が呼び出されると、正確なファイル名を得るために <code>require.resolve()</code> が使われます。

</p>
<!--
Putting together all of the above, here is the high-level algorithm
in pseudocode of what require.resolve does:
-->

<p>上で述べたことをまとめると、 require.resolve は以下の擬似コードで記述されるようなハイレベルなアルゴリズムに則っています:

</p>
<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with &apos;./&apos; or &apos;/&apos; or &apos;../&apos;
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for &quot;main&quot; field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of &quot;node_modules&quot; in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS</code></pre>
<h2>Loading from the global folders<span><a class="mark" href="#all_loading_from_the_global_folders" id="all_loading_from_the_global_folders">#</a></span></h2>
<!-- type=misc -->

<!--
If the `NODE_PATH` environment variable is set to a colon-delimited list
of absolute paths, then node will search those paths for modules if they
are not found elsewhere.  (Note: On Windows, `NODE_PATH` is delimited by
semicolons instead of colons.)

Additionally, node will search in the following locations:
-->

<p><code>NODE_PATH</code> 環境変数に絶対パスをコロンで区切ったリストを設定すると、
node は他で見つからなかったモジュールをそれらのパスから探します。
(注意: Windows では、<code>NODE_PATH</code> はコロンではなくセミコロンで区切られます)

</p>
<p>加えると、node は以下の場所から検索します。

</p>
<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>
<!--
Where `$HOME` is the user's home directory, and `$PREFIX` is node's
configured `installPrefix`.

These are mostly for historic reasons.  You are highly encouraged to
place your dependencies locally in `node_modules` folders.  They will be
loaded faster, and more reliably.
-->

<p><code>$HOME</code> はユーザのホームディレクトリ、<code>$PREFIX</code> は node を
configure した時の <code>installPrefix</code> です。

</p>
<p>これらは主に歴史的な理由によるものです。
あなたが依存するものはローカルの <code>node_modules</code> フォルダに置くことが
強く推奨されます。それは素早くロードされ、確実です。

</p>
<h2>Accessing the main module<span><a class="mark" href="#all_accessing_the_main_module" id="all_accessing_the_main_module">#</a></span></h2>
<!-- type=misc -->

<!--
When a file is run directly from Node, `require.main` is set to its
`module`. That means that you can determine whether a file has been run
directly by testing
-->

<p>ファイルがNodeによって直接実行される場合、その <code>module</code> が
<code>require.main</code> に設定されます。
これは、ファイルが直接実行されたかを決定できることを意味します。

</p>
<pre><code>require.main === module</code></pre>
<!--
For a file `foo.js`, this will be `true` if run via `node foo.js`, but
`false` if run by `require('./foo')`.

Because `module` provides a `filename` property (normally equivalent to
`__filename`), the entry point of the current application can be obtained
by checking `require.main.filename`.
-->

<p><code>foo.js</code> ファイルの場合、<code>node foo.js</code> と実行された場合にこれは <code>true</code> 
になりますが、<code>require(&apos;./foo&apos;)</code> で実行された場合は <code>false</code> になります。

</p>
<p><code>module</code> は <code>filename</code> プロパティ (通常 <code>__filename</code> と同じです) 
を提供するため、現在のアプリケーションのエントリポイントは
<code>require.main.filename</code> をチェックすることで得ることができます。

</p>
<h2>Addenda: Package Manager Tips<span><a class="mark" href="#all_addenda_package_manager_tips" id="all_addenda_package_manager_tips">#</a></span></h2>
<!-- type=misc -->

<!--
The semantics of Node's `require()` function were designed to be general
enough to support a number of sane directory structures. Package manager
programs such as `dpkg`, `rpm`, and `npm` will hopefully find it possible to
build native packages from Node modules without modification.
-->

<p>Node の <code>require()</code> は普通のディレクトリ構造をサポートできるよう汎用的に設計されています。
<code>dpkg</code> や <code>rpm</code> や <code>npm</code> のようなパッケージ管理プログラムは修正なしに Node モジュールからネイティブパッケージを組み立てることができるでしょう。

</p>
<!--
Below we give a suggested directory structure that could work:

Let's say that we wanted to have the folder at
`/usr/lib/node/<some-package>/<some-version>` hold the contents of a
specific version of a package.
-->

<p>推奨するディレクトリ構造は次のようになります:

</p>
<p>例えば <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> フォルダに、あるパッケージの特定のバージョンを保持する形式です。

</p>
<!--
Packages can depend on one another. In order to install package `foo`, you
may have to install a specific version of package `bar`.  The `bar` package
may itself have dependencies, and in some cases, these dependencies may even
collide or form cycles.
-->

<p>パッケージは相互に依存しあうことがあります。
<code>foo</code> パッケージをインストールするためにはある特定のバージョンの <code>bar</code> パッケージをインストールする必要があります。
<code>bar</code> パッケージ自身も依存関係をもっているので、ときには依存関係が衝突したり循環したりすることがあります。

</p>
<!--
Since Node looks up the `realpath` of any modules it loads (that is,
resolves symlinks), and then looks for their dependencies in the
`node_modules` folders as described above, this situation is very simple to
resolve with the following architecture:
-->

<p>Node はモジュールの <code>realpath</code> （シンボリックリンクを解釈します）を調べ、その依存関係を上述の <code>node_modules</code> フォルダの仕組みで探しにいきます。
これによって次のような構造をとてもシンプルに解釈することができます。

</p>
<!--
* `/usr/lib/node/foo/1.2.3/` - Contents of the `foo` package, version 1.2.3.
* `/usr/lib/node/bar/4.3.2/` - Contents of the `bar` package that `foo`
  depends on.
* `/usr/lib/node/foo/1.2.3/node_modules/bar` - Symbolic link to
  `/usr/lib/node/bar/4.3.2/`.
* `/usr/lib/node/bar/4.3.2/node_modules/*` - Symbolic links to the packages
  that `bar` depends on.
-->

<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - <code>foo</code> パッケージの中身。バージョン1.2.3。</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - <code>bar</code> パッケージの中身。 <code>foo</code> が依存している。</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - <code>/usr/lib/node/bar/4.3.2/</code> へのシンボリックリンク。</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - <code>bar</code> が依存しているパッケージへのシンボリックリンク。</li>
</ul>
<!--
Thus, even if a cycle is encountered, or if there are dependency
conflicts, every module will be able to get a version of its dependency
that it can use.

When the code in the `foo` package does `require('bar')`, it will get the
version that is symlinked into `/usr/lib/node/foo/1.2.3/node_modules/bar`.
Then, when the code in the `bar` package calls `require('quux')`, it'll get
the version that is symlinked into
`/usr/lib/node/bar/4.3.2/node_modules/quux`.

Furthermore, to make the module lookup process even more optimal, rather
than putting packages directly in `/usr/lib/node`, we could put them in
`/usr/lib/node_modules/<name>/<version>`.  Then node will not bother
looking for missing dependencies in `/usr/node_modules` or `/node_modules`.

In order to make modules available to the node REPL, it might be useful to
also add the `/usr/lib/node_modules` folder to the `$NODE_PATH` environment
variable.  Since the module lookups using `node_modules` folders are all
relative, and based on the real path of the files making the calls to
`require()`, the packages themselves can be anywhere.
-->

<p>このようにして、もし仮に依存関係に循環や衝突が見つかったとしても、全てのモジュールは依存しているパッケージの特定のバージョンを取得することができます。

</p>
<p><code>foo</code> パッケージの中で <code>require(&apos;bar&apos;)</code> したら、 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> からリンクされているバージョンを取得します。
そして、 <code>bar</code> パッケージ内で <code>require(&apos;quux&apos;)</code> を呼んだら、 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code> からリンクされているバージョンを取得します。

</p>
<p>さらに、モジュールを探索する過程をより最適化するために、 <code>/usr/lib/node</code> にパッケージを置くよりも <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code> に置くのをお勧めします。
そうすることで Node は見つからない依存パッケージを <code>/usr/node_modules</code> や <code>/node_modules</code> に探しにいかなくてもようなります。

</p>
<p>Node の REPL でモジュールを使えるようにするために、 <code>/usr/lib/node_modules</code> フォルダを <code>$NODE_PATH</code> 環境変数に追加するとよいでしょう。
<code>node_modules</code> フォルダを使ったモジュール探索は全て相対的なものであり、 <code>require()</code> を呼び出したファイルの絶対パスを基準としているので、パッケージ自体はどこにでも配置することができます。

</p>
<h1>Addons<span><a class="mark" href="#all_addons" id="all_addons">#</a></span></h1>
<!--
Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:
-->

<p>アドオンは動的に共有オブジェクトをリンクします。
それらは、C や C++ のライブラリに接合点を提供します。
API はいくつかのライブラリの知識が必要で、(現時点では) かなり複雑です。

</p>
<!--
 - V8 JavaScript, a C++ library. Used for interfacing with JavaScript:
   creating objects, calling functions, etc.  Documented mostly in the
   `v8.h` header file (`deps/v8/include/v8.h` in the Node source tree),
   which is also available [online](http://izs.me/v8-docs/main.html).
-->

<ul>
<li>V8 JavaScript は C++ のライブラリです。
JavaScript のオブジェクト作成や関数呼び出し等のインタフェースに使用されます。
ドキュメントは主に、<code>v8.h</code> のヘッダファイル
(Node のソースツリーの中の <code>deps/v8/include/v8.h</code>) に記されていますが、
<a href="http://izs.me/v8-docs/main.html">オンライン</a> で参照することもできます。</li>
</ul>
<!--
 - [libuv](https://github.com/joyent/libuv), C event loop library. Anytime one
   needs to wait for a file descriptor to become readable, wait for a timer, or
   wait for a signal to received one will need to interface with libuv. That is,
   if you perform any I/O, libuv will need to be used.
-->

<ul>
<li><a href="https://github.com/joyent/libuv">libuv</a> は
C のイベントループライブラリです。
ファイル記述子が読み取り可能になるのを待つとき、タイマーを待つとき、
シグナルを受信するのを待つときはいつでも、
libv のインタフェースが必要になります。
つまり、何らかの I/O 処理をすると必ず libuv を使う必要があるということです。</li>
</ul>
<!--
 - Internal Node libraries. Most importantly is the `node::ObjectWrap`
   class which you will likely want to derive from.
-->

<ul>
<li>Node の内部ライブラリ。
もっとも重要なのは <code>node::ObjectWrap</code> クラスで、
このクラスから派生させることが多くなるでしょう。</li>
</ul>
<!--
 - Others. Look in `deps/` for what else is available.
-->

<ul>
<li>その他。どのような物が利用できるかは <code>deps/</code> 以下を参照してさい。</li>
</ul>
<!--
Node statically compiles all its dependencies into the executable. When
compiling your module, you don't need to worry about linking to any of these
libraries.
-->

<p>Node は全ての依存ライブラリを実行ファイルに静的にコンパイルします。
モジュールのコンパイル時には、それらのリンクについて一切気にする必要は有りません。

</p>
<h2>Hello world<span><a class="mark" href="#all_hello_world" id="all_hello_world">#</a></span></h2>
<!--
To get started let's make a small Addon which is the C++ equivalent of
the following Javascript code:
-->

<p>では、 以下の JavaScript コードと同じ様に動作する小さなアドオンを
C++ で作成してみましょう。

</p>
<pre><code>exports.hello = function() { return &apos;world&apos;; };</code></pre>
<!--
First we create a file `hello.cc`:
-->

<p>最初に <code>hello.cc</code> というファイルを作成します:


</p>
<pre><code>#include &lt;node.h&gt;
#include &lt;v8.h&gt;

using namespace v8;

Handle&lt;Value&gt; Method(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New(&quot;world&quot;));
}

void init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;hello&quot;),
      FunctionTemplate::New(Method)-&gt;GetFunction());
}
NODE_MODULE(hello, init)</code></pre>
<!--
Note that all Node addons must export an initialization function:
-->

<p>全ての Node アドオンは初期化関数をエクスポートしなければならないことに
注意してください。

</p>
<pre><code>void Initialize (Handle&lt;Object&gt; target);
NODE_MODULE(module_name, Initialize)</code></pre>
<!--
There is no semi-colon after `NODE_MODULE` as it's not a function (see `node.h`).

The `module_name` needs to match the filename of the final binary (minus the
.node suffix).

The source code needs to be built into `hello.node`, the binary Addon. To
do this we create a file called `wscript` which is python code and looks
like this:
-->

<p><code>NODE_MODULE</code> は関数ではないので、その後にセミコロンを付けてはいけません
(<code>node.h</code> を参照してください)。

</p>
<p><code>module_name</code> は最終的なバイナリのファイル名 (拡張子 .node を除く)
とマッチする必要があります。

</p>
<p>このソースコードは、<code>hello.node</code> というバイナリアドオンとしてビルドされる必要が有ります。
そのために <code>wscript</code> と呼ばれる以下のようなコードを Python で書きました:

</p>
<pre><code>srcdir = &apos;.&apos;
blddir = &apos;build&apos;
VERSION = &apos;0.0.1&apos;

def set_options(opt):
  opt.tool_options(&apos;compiler_cxx&apos;)

def configure(conf):
  conf.check_tool(&apos;compiler_cxx&apos;)
  conf.check_tool(&apos;node_addon&apos;)

def build(bld):
  obj = bld.new_task_gen(&apos;cxx&apos;, &apos;shlib&apos;, &apos;node_addon&apos;)
  obj.target = &apos;hello&apos;
  obj.source = &apos;hello.cc&apos;</code></pre>
<!--
Running `node-waf configure build` will create a file
`build/default/hello.node` which is our Addon.
-->

<p><code>node-waf configure build</code> を実行すると、<code>build/default/hello.node</code> が作成されます。これが作成したアドオンです。

</p>
<!--
`node-waf` is just [WAF](http://code.google.com/p/waf), the python-based build system. `node-waf` is
provided for the ease of users.
-->

<p><code>node-waf</code> 単に <a href="http://code.google.com/p/waf">WAF</a> は Python ベースのビルドシステムです。
<code>node-waf</code> は、ユーザの負担を減らすために提供されています。

</p>
<!--
You can now use the binary addon in a Node project `hello.js` by pointing `require` to
the recently built module:
-->

<p>ビルドされたモジュールを <code>require</code> で指定することにより、
このバイナリアドオンを Node プロジェクトの <code>hello.js</code> から利用することが
可能になります。

</p>
<pre><code>var addon = require(&apos;./build/Release/hello&apos;);

console.log(addon.hello()); // &apos;world&apos;</code></pre>
<!--
Please see patterns below for further information or
<https://github.com/pietern/hiredis-node> for an example in production.
-->

<p>さらに詳しい情報については下記のパターンか、
</p>
<p><a href="https://github.com/pietern/hiredis-node">https://github.com/pietern/hiredis-node</a> を実際のプロダクトにおける
例として参照してください。

</p>
<h2>Addon patterns<span><a class="mark" href="#all_addon_patterns" id="all_addon_patterns">#</a></span></h2>
<!--
Below are some addon patterns to help you get started. Consult the online
[v8 reference](http://izs.me/v8-docs/main.html) for help with the various v8
calls, and v8's [Embedder's Guide](http://code.google.com/apis/v8/embed.html)
for an explanation of several concepts used such as handles, scopes,
function templates, etc.

To compile these examples, create the `wscript` file below and run
`node-waf configure build`:
-->

<p>以下は初心者に役立つアドオンのパターンです。
v8 の様々な API についてはオンラインの
<a href="http://izs.me/v8-docs/main.html">v8 reference</a> が、
そして ハンドルやスコープ、関数テンプレートなどいくつかの概念については
v8 の <a href="http://code.google.com/apis/v8/embed.html">Embedder&apos;s Guide</a> が
役に立つでしょう。

</p>
<pre><code>srcdir = &apos;.&apos;
blddir = &apos;build&apos;
VERSION = &apos;0.0.1&apos;

def set_options(opt):
  opt.tool_options(&apos;compiler_cxx&apos;)

def configure(conf):
  conf.check_tool(&apos;compiler_cxx&apos;)
  conf.check_tool(&apos;node_addon&apos;)

def build(bld):
  obj = bld.new_task_gen(&apos;cxx&apos;, &apos;shlib&apos;, &apos;node_addon&apos;)
  obj.target = &apos;addon&apos;
  obj.source = [&apos;addon.cc&apos;]</code></pre>
<!--
In cases where there is more than one `.cc` file, simply add the file name to the
`obj.source` array, e.g.:
-->

<p>一つ以上の <code>.cc</code> ファイルがある場合は、単純に <code>obj.source</code> 配列にファイル名を
加えるだけです。例:

</p>
<pre><code>obj.source = [&apos;addon.cc&apos;, &apos;myexample.cc&apos;]</code></pre>
<h3>Function arguments<span><a class="mark" href="#all_function_arguments" id="all_function_arguments">#</a></span></h3>
<!--
The following pattern illustrates how to read arguments from JavaScript
function calls and return a result. This is the main and only needed source
`addon.cc`:
-->

<p>以下のパターンは JavaScript から呼び出された関数で引数を読み出したり、
結果を返す方法を示します。これは <code>addon.cc</code> でのみ必要となります。

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; Add(const Arguments&amp; args) {
  HandleScope scope;

  if (args.Length() &lt; 2) {
    ThrowException(Exception::TypeError(String::New(&quot;Wrong number of arguments&quot;)));
    return scope.Close(Undefined());
  }

  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {
    ThrowException(Exception::TypeError(String::New(&quot;Wrong arguments&quot;)));
    return scope.Close(Undefined());
  }

  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() +
      args[1]-&gt;NumberValue());
  return scope.Close(num);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;add&quot;),
      FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<!--
You can test it with the following JavaScript snippet:
-->

<p>以下の JavaScript コード片でテストすることができます。

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

console.log( &apos;This should be eight:&apos;, addon.add(3,5) );</code></pre>
<h3>Callbacks<span><a class="mark" href="#all_callbacks" id="all_callbacks">#</a></span></h3>
<!--
You can pass JavaScript functions to a C++ function and execute them from
there. Here's `addon.cc`:
-->

<p>JavaScript の関数を C++ の関数に渡してそこから呼び出すことができます。
これは <code>addon.cc</code> です:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; RunCallback(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);
  const unsigned argc = 1;
  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(&quot;hello world&quot;)) };
  cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);

  return scope.Close(Undefined());
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;runCallback&quot;),
      FunctionTemplate::New(RunCallback)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<!--
To test it run the following JavaScript snippet:
-->

<p>以下の JavaScript コード片でテストすることができます。

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

addon.runCallback(function(msg){
  console.log(msg); // &apos;hello world&apos;
});</code></pre>
<h3>Object factory<span><a class="mark" href="#all_object_factory" id="all_object_factory">#</a></span></h3>
<!--
You can create and return new objects from within a C++ function with this
`addon.cc` pattern, which returns an object with property `msg` that echoes
the string passed to `createObject()`:
-->

<p>C++ 関数の中から新しいオブジェクトを作成して返すことができます。
以下の <code>addon.cc</code> のパターンでは、<code>createObject()</code> に渡された文字列を
反映する <code>msg</code> プロパティを持ったオブジェクトを返します。

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Object&gt; obj = Object::New();
  obj-&gt;Set(String::NewSymbol(&quot;msg&quot;), args[0]-&gt;ToString());

  return scope.Close(obj);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;createObject&quot;),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<!--
To test it in JavaScript:
-->

<p>テスト用の JavaScript:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj1 = addon.createObject(&apos;hello&apos;);
var obj2 = addon.createObject(&apos;world&apos;);
console.log(obj1.msg+&apos; &apos;+obj2.msg); // &apos;hello world&apos;</code></pre>
<h3>Function factory<span><a class="mark" href="#all_function_factory" id="all_function_factory">#</a></span></h3>
<!--
This pattern illustrates how to create and return a JavaScript function that
wraps a C++ function:
-->

<p>このパターンは C++ 関数をラップした JavaScript 関数を作成して返す方法を
示します。

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; MyFunction(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New(&quot;hello world&quot;));
}

Handle&lt;Value&gt; CreateFunction(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(MyFunction);
  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();
  fn-&gt;SetName(String::NewSymbol(&quot;theFunction&quot;)); // omit this to make it anonymous

  return scope.Close(fn);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;createFunction&quot;),
      FunctionTemplate::New(CreateFunction)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<!--
To test:
-->

<p>テスト:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var fn = addon.createFunction();
console.log(fn()); // &apos;hello world&apos;</code></pre>
<h3>Wrapping C++ objects<span><a class="mark" href="#all_wrapping_c_objects" id="all_wrapping_c_objects">#</a></span></h3>
<!--
Here we will create a wrapper for a C++ object/class `MyObject` that can be
instantiated in JavaScript through the `new` operator. First prepare the main
module `addon.cc`:
-->

<p>ここでは、
C++ オブジェクト／クラスをラップし、JavaScript から new 演算子を使って
インスタンス化できる <code>MyObject</code> を作成します。
最初にメインモジュール <code>addon.cc</code> を準備します:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init(target);
}

NODE_MODULE(addon, InitAll)</code></pre>
<!--
Then in `myobject.h` make your wrapper inherit from `node::ObjectWrap`:
-->

<p>次に、<code>node::ObjectWrap</code> を継承したラッパーを <code>myobject.h</code> に作成します。

</p>
<pre><code>#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init(v8::Handle&lt;v8::Object&gt; target);

 private:
  MyObject();
  ~MyObject();

  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);
  double counter_;
};

#endif</code></pre>
<!--
And in `myobject.cc` implement the various methods that you want to expose.
Here we expose the method `plusOne` by adding it to the constructor's
prototype:
-->

<p>公開したい様々なメソッドを <code>myobject.cc</code> に実装します。
ここでは、コンストラクタに渡された値に加算する <code>plusOne</code> を公開しています:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

void MyObject::Init(Handle&lt;Object&gt; target) {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototype
  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),
      FunctionTemplate::New(PlusOne)-&gt;GetFunction());

  Persistent&lt;Function&gt; constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
  target-&gt;Set(String::NewSymbol(&quot;MyObject&quot;), constructor);
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());
  obj-&gt;counter_ += 1;

  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<!--
Test it with:
-->

<p>これでテストします:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj = new addon.MyObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13</code></pre>
<h3>Factory of wrapped objects<span><a class="mark" href="#all_factory_of_wrapped_objects" id="all_factory_of_wrapped_objects">#</a></span></h3>
<!--
This is useful when you want to be able to create native objects without
explicitly instantiating them with the `new` operator in JavaScript, e.g.
-->

<p>JavaScript の <code>new</code> 演算子で明示的にインスタンス化することなく、
ネイティブオブジェクトを作成できるようにしたい場合に便利です。例:

</p>
<pre><code>var obj = addon.createObject();
// instead of:
// var obj = new addon.Object();</code></pre>
<!--
Let's register our `createObject` method in `addon.cc`:
-->

<p>createObject<code> を </code>addon.cc` に登録しましょう:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MyObject::NewInstance(args));
}

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init();

  target-&gt;Set(String::NewSymbol(&quot;createObject&quot;),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>
<!--
In `myobject.h` we now introduce the static method `NewInstance` that takes
care of instantiating the object (i.e. it does the job of `new` in JavaScript):
-->

<p><code>myobject.h</code> にオブジェクトを生成する static メソッド <code>NewInstance</code> を
導入しましょう (すなわち，それが JavaScript 内の <code>new</code> の働きをします)。

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);

 private:
  MyObject();
  ~MyObject();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);
  double counter_;
};

#endif</code></pre>
<!--
The implementation is similar to the above in `myobject.cc`:
-->

<p>実装は前述の <code>myobject.cc</code> と同様です:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

Persistent&lt;Function&gt; MyObject::constructor;

void MyObject::Init() {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototype
  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),
      FunctionTemplate::New(PlusOne)-&gt;GetFunction());

  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}

Handle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());
  obj-&gt;counter_ += 1;

  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<!--
Test it with:
-->

<p>これでテストします:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj = addon.createObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13

var obj2 = addon.createObject(20);
console.log( obj2.plusOne() ); // 21
console.log( obj2.plusOne() ); // 22
console.log( obj2.plusOne() ); // 23</code></pre>
<h3>Passing wrapped objects around<span><a class="mark" href="#all_passing_wrapped_objects_around" id="all_passing_wrapped_objects_around">#</a></span></h3>
<!--
In addition to wrapping and returning C++ objects, you can pass them around
by unwrapping them with Node's `node::ObjectWrap::Unwrap` helper function.
In the following `addon.cc` we introduce a function `add()` that can take on two
`MyObject` objects:
-->

<p>C++ オブジェクトをラップして返すことに加えて、Node が提供するヘルパ関数
<code>node::ObjectWrap::Unwrap</code> を使用してアンラップすることもできます。
以下の <code>addon.cc</code> では、二つの <code>MyObject</code> オブジェクトを受け取る <code>add()</code>
関数を導入します:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MyObject::NewInstance(args));
}

Handle&lt;Value&gt; Add(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[0]-&gt;ToObject());
  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[1]-&gt;ToObject());

  double sum = obj1-&gt;Val() + obj2-&gt;Val();
  return scope.Close(Number::New(sum));
}

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init();

  target-&gt;Set(String::NewSymbol(&quot;createObject&quot;),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());

  target-&gt;Set(String::NewSymbol(&quot;add&quot;),
      FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>
<!--
To make things interesting we introduce a public method in `myobject.h` so we
can probe private values after unwrapping the object:
-->

<p>よりおもしろくするために、<code>myobject.h</code> にパブリックメソッドを導入しましょう。
したがって、アンラップされたオブジェクトのプライベート変数を調べることが
できます。

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);
  double Val() const { return val_; }

 private:
  MyObject();
  ~MyObject();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  double val_;
};

#endif</code></pre>
<!--
The implementation of `myobject.cc` is similar as before:
-->

<p><code>myobject.cc</code> の実装はこれまでと同様です:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

Persistent&lt;Function&gt; MyObject::constructor;

void MyObject::Init() {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;val_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}</code></pre>
<!--
Test it with:
-->

<p>これでテストします:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj1 = addon.createObject(10);
var obj2 = addon.createObject(20);
var result = addon.add(obj1, obj2);

console.log(result); // 30</code></pre>
<h1>process<span><a class="mark" href="#all_process_1" id="all_process_1">#</a></span></h1>
<!-- type=global -->

<!--
The `process` object is a global object and can be accessed from anywhere.
It is an instance of `EventEmitter`.
-->

<p><code>process</code> はグローバルオブジェクトで、どこからでもアクセスすることができます。
それは <code>EventEmitter</code> のインスタンスです。


</p>
<h2>Event: &apos;exit&apos;<span><a class="mark" href="#all_event_exit" id="all_event_exit">#</a></span></h2>
<!--
Emitted when the process is about to exit.  This is a good hook to perform
constant time checks of the module's state (like for unit tests).  The main
event loop will no longer be run after the 'exit' callback finishes, so
timers may not be scheduled.
-->

<p>プロセスが終了しようとしている時に生成されます。
これは (ユニットテストのように) モジュールの状態を一定の時間でチェックするのに適したフックとなります。
メインのイベントループは &apos;exit&apos; コールバックが終了するともはや動作しないので、
タイマーはスケジュールされないかもしれません。

</p>
<!--
Example of listening for `exit`:
-->

<p><code>exit</code> を監視する例:

</p>
<pre><code>process.on(&apos;exit&apos;, function () {
  process.nextTick(function () {
   console.log(&apos;This will not run&apos;);
  });
  console.log(&apos;About to exit.&apos;);
});</code></pre>
<h2>Event: &apos;uncaughtException&apos;<span><a class="mark" href="#all_event_uncaughtexception" id="all_event_uncaughtexception">#</a></span></h2>
<!--
Emitted when an exception bubbles all the way back to the event loop. If a
listener is added for this exception, the default action (which is to print
a stack trace and exit) will not occur.
-->

<p>発生した例外がイベントループまでたどり着いた場合に生成されます。
もしこの例外に対するリスナーが加えられていれば、
デフォルトの動作 (それはスタックトレースをプリントして終了します) は起こりません。

</p>
<!--
Example of listening for `uncaughtException`:
-->

<p><code>uncaughtException</code> を監視する例:

</p>
<pre><code>process.on(&apos;uncaughtException&apos;, function (err) {
  console.log(&apos;Caught exception: &apos; + err);
});

setTimeout(function () {
  console.log(&apos;This will still run.&apos;);
}, 500);

// Intentionally cause an exception, but don&apos;t catch it.
nonexistentFunc();
console.log(&apos;This will not run.&apos;);</code></pre>
<!--
Note that `uncaughtException` is a very crude mechanism for exception
handling.  Using try / catch in your program will give you more control over
your program's flow.  Especially for server programs that are designed to
stay running forever, `uncaughtException` can be a useful safety mechanism.
-->

<p><code>uncaughtException</code> は例外を扱うとても荒削りなメカニズムであることに注意してください。
プログラムの中で try / catch を使えばもっとプログラムの流れをうまく制御できるでしょう。
特にサーバプログラムはいつまでも実行し続けるように設計されるので、
<code>uncaughtException</code> は有益で安全なメカニズムになり得ます。


</p>
<h2>Signal Events<span><a class="mark" href="#all_signal_events" id="all_signal_events">#</a></span></h2>
<!--type=event-->

<!--name=SIGINT, SIGUSR1, etc.-->

<!--
Emitted when the processes receives a signal. See sigaction(2) for a list of
standard POSIX signal names such as SIGINT, SIGUSR1, etc.
-->

<p>プロセスがシグナルを受信した場合に生成されます。
SIGINT、SIGUSR1、その他の POSIX 標準シグナル名の一覧について は sigaction(2) を参照してください。

</p>
<!--
Example of listening for `SIGINT`:
-->

<p><code>SIGINT</code>を監視する例:

</p>
<pre><code>// Start reading from stdin so we don&apos;t exit.
process.stdin.resume();

process.on(&apos;SIGINT&apos;, function () {
  console.log(&apos;Got SIGINT.  Press Control-D to exit.&apos;);
});</code></pre>
<!--
An easy way to send the `SIGINT` signal is with `Control-C` in most terminal
programs.
-->

<p>多くの端末プログラムで簡単に <code>SIGINT</code> を送る方法は <code>Control-C</code> を押すことです。


</p>
<h2>process.stdout<span><a class="mark" href="#all_process_stdout" id="all_process_stdout">#</a></span></h2>
<!--
A `Writable Stream` to `stdout`.
-->

<p><code>stdout</code> に対する <code>Writable Stream</code> です。

</p>
<!--
Example: the definition of `console.log`
-->

<p>例: <code>console.log</code> の定義

</p>
<pre><code>console.log = function (d) {
  process.stdout.write(d + &apos;\n&apos;);
};</code></pre>
<!--
`process.stderr` and `process.stdout` are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.
-->

<p><code>process.stderr</code> と <code>process.stdout</code> は他のストリームと異なり、
書き込みは通常ブロックします。
それらが通常ファイルや TTY のファイル記述子を参照しているケースでは、
それらはブロックします。
パイプを参照しているケースでは、他のストリームと同様にブロックしません。


</p>
<h2>process.stderr<span><a class="mark" href="#all_process_stderr" id="all_process_stderr">#</a></span></h2>
<!--
A writable stream to stderr.

`process.stderr` and `process.stdout` are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.
-->

<p><code>stderr</code> に対する <code>Writable Stream</code> です。

</p>
<p><code>process.stderr</code> と <code>process.stdout</code> は他のストリームと異なり、
書き込みは通常ブロックします。
それらが通常ファイルや TTY のファイル記述子を参照しているケースでは、
それらはブロックします。
パイプを参照しているケースでは、他のストリームと同様にブロックしません。


</p>
<h2>process.stdin<span><a class="mark" href="#all_process_stdin" id="all_process_stdin">#</a></span></h2>
<!--
A `Readable Stream` for stdin. The stdin stream is paused by default, so one
must call `process.stdin.resume()` to read from it.
-->

<p>標準入力に対する <code>Readable Stream</code> です。
デフォルトでは、標準入力に対するストリームは中断されているため、
読み込みのためには <code>process.stdin.resume()</code> を呼び出さなければなりません。

</p>
<!--
Example of opening standard input and listening for both events:
-->

<p>標準入力をオープンして二つのイベントを監視する例:

</p>
<pre><code>process.stdin.resume();
process.stdin.setEncoding(&apos;utf8&apos;);

process.stdin.on(&apos;data&apos;, function (chunk) {
  process.stdout.write(&apos;data: &apos; + chunk);
});

process.stdin.on(&apos;end&apos;, function () {
  process.stdout.write(&apos;end&apos;);
});</code></pre>
<h2>process.argv<span><a class="mark" href="#all_process_argv" id="all_process_argv">#</a></span></h2>
<!--
An array containing the command line arguments.  The first element will be
'node', the second element will be the name of the JavaScript file.  The
next elements will be any additional command line arguments.
-->

<p>コマンドライン引数を含む配列です。
最初の要素は &apos;node&apos;、2 番目の要素は JavaScript ファイルの名前になります。
その後の要素はコマンドラインの追加の引数になります。

</p>
<pre><code>// print process.argv
process.argv.forEach(function (val, index, array) {
  console.log(index + &apos;: &apos; + val);
});</code></pre>
<!--
This will generate:
-->

<p>このように出力されます:

</p>
<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four</code></pre>
<h2>process.execPath<span><a class="mark" href="#all_process_execpath" id="all_process_execpath">#</a></span></h2>
<!--
This is the absolute pathname of the executable that started the process.
-->

<p>プロセスによって開始された実行可能ファイルの絶対パスです。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>/usr/local/bin/node</code></pre>
<h2>process.chdir(directory)<span><a class="mark" href="#all_process_chdir_directory" id="all_process_chdir_directory">#</a></span></h2>
<!--
Changes the current working directory of the process or throws an exception if that fails.
-->

<p>プロセスのカレントワーキングディレクトリを変更します。
もし失敗した場合は例外をスローします。

</p>
<pre><code>console.log(&apos;Starting directory: &apos; + process.cwd());
try {
  process.chdir(&apos;/tmp&apos;);
  console.log(&apos;New directory: &apos; + process.cwd());
}
catch (err) {
  console.log(&apos;chdir: &apos; + err);
}</code></pre>
<h2>process.cwd()<span><a class="mark" href="#all_process_cwd" id="all_process_cwd">#</a></span></h2>
<!--
Returns the current working directory of the process.
-->

<p>プロセスのカレントワーキングディレクトリを返します。

</p>
<pre><code>console.log(&apos;Current directory: &apos; + process.cwd());</code></pre>
<h2>process.env<span><a class="mark" href="#all_process_env" id="all_process_env">#</a></span></h2>
<!--
An object containing the user environment. See environ(7).
-->

<p>ユーザの環境を含むオブジェクトです。environ(7) を参照してください。


</p>
<h2>process.exit([code])<span><a class="mark" href="#all_process_exit_code" id="all_process_exit_code">#</a></span></h2>
<!--
Ends the process with the specified `code`.  If omitted, exit uses the
'success' code `0`.
-->

<p>指定の <code>code</code> でプロセスを終了します。
もし省略されると、「成功」を示すコード <code>0</code> を使って終了します。

</p>
<!--
To exit with a 'failure' code:
-->

<p>「失敗」を示すコードで終了する例:

</p>
<pre><code>process.exit(1);</code></pre>
<!--
The shell that executed node should see the exit code as 1.
-->

<p>node を実行したシェルで終了コードが 1 であることを見ることができるでしょう。


</p>
<h2>process.getgid()<span><a class="mark" href="#all_process_getgid" id="all_process_getgid">#</a></span></h2>
<!--
Gets the group identity of the process. (See getgid(2).)
This is the numerical group id, not the group name.
-->

<p>プロセスのグループ識別子を取得します (getgid(2) 参照)。
これは数値によるグループ ID で、グループ名ではありません。

</p>
<pre><code>console.log(&apos;Current gid: &apos; + process.getgid());</code></pre>
<h2>process.setgid(id)<span><a class="mark" href="#all_process_setgid_id" id="all_process_setgid_id">#</a></span></h2>
<!--
Sets the group identity of the process. (See setgid(2).)  This accepts either
a numerical ID or a groupname string. If a groupname is specified, this method
blocks while resolving it to a numerical ID.
-->

<p>プロセスのグループ識別子を設定します (setgid(2) 参照)。
これは数値による ID もグループ名の文字列のどちらも受け入れます。
もしグループ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。

</p>
<pre><code>console.log(&apos;Current gid: &apos; + process.getgid());
try {
  process.setgid(501);
  console.log(&apos;New gid: &apos; + process.getgid());
}
catch (err) {
  console.log(&apos;Failed to set gid: &apos; + err);
}</code></pre>
<h2>process.getuid()<span><a class="mark" href="#all_process_getuid" id="all_process_getuid">#</a></span></h2>
<!--
Gets the user identity of the process. (See getuid(2).)
This is the numerical userid, not the username.
-->

<p>プロセスのユーザ識別子を取得します (getuid(2) 参照)。
これは数値によるユーザ ID で、ユーザ名ではありません。

</p>
<pre><code>console.log(&apos;Current uid: &apos; + process.getuid());</code></pre>
<h2>process.setuid(id)<span><a class="mark" href="#all_process_setuid_id" id="all_process_setuid_id">#</a></span></h2>
<!--
Sets the user identity of the process. (See setuid(2).)  This accepts either
a numerical ID or a username string.  If a username is specified, this method
blocks while resolving it to a numerical ID.
-->

<p>プロセスのユーザ識別子を設定します (setuid(2) 参照)。
これは数値による ID もユーザ名の文字列のどちらも受け入れます。
もしユーザ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。

</p>
<pre><code>console.log(&apos;Current uid: &apos; + process.getuid());
try {
  process.setuid(501);
  console.log(&apos;New uid: &apos; + process.getuid());
}
catch (err) {
  console.log(&apos;Failed to set uid: &apos; + err);
}</code></pre>
<h2>process.version<span><a class="mark" href="#all_process_version" id="all_process_version">#</a></span></h2>
<!--
A compiled-in property that exposes `NODE_VERSION`.
-->

<p><code>NODE_VERSION</code> を提示するコンパイル済みプロパティです。

</p>
<pre><code>console.log(&apos;Version: &apos; + process.version);</code></pre>
<h2>process.versions<span><a class="mark" href="#all_process_versions" id="all_process_versions">#</a></span></h2>
<!--
A property exposing version strings of node and its dependencies.
-->

<p>node と依存ライブラリのバージョン文字列を提示します。

</p>
<pre><code>console.log(process.versions);</code></pre>
<!--
Will output:
-->

<p>は以下を出力します。

</p>
<pre><code>{ node: &apos;0.4.12&apos;,
  v8: &apos;3.1.8.26&apos;,
  ares: &apos;1.7.4&apos;,
  ev: &apos;4.4&apos;,
  openssl: &apos;1.0.0e-fips&apos; }</code></pre>
<h2>process.installPrefix<span><a class="mark" href="#all_process_installprefix" id="all_process_installprefix">#</a></span></h2>
<!--
A compiled-in property that exposes `NODE_PREFIX`.
-->

<p><code>NODE_PREFIX</code> を提示するコンパイル済みプロパティです。

</p>
<pre><code>console.log(&apos;Prefix: &apos; + process.installPrefix);</code></pre>
<h2>process.kill(pid, [signal])<span><a class="mark" href="#all_process_kill_pid_signal" id="all_process_kill_pid_signal">#</a></span></h2>
<!--
Send a signal to a process. `pid` is the process id and `signal` is the
string describing the signal to send.  Signal names are strings like
'SIGINT' or 'SIGUSR1'.  If omitted, the signal will be 'SIGTERM'.
See kill(2) for more information.
-->

<p>プロセスにシグナルを送ります。
<code>pid</code> はプロセス ID で <code>signal</code> は送信されるシグナルを文字列で記述したものです。
シグナルの名前は &apos;SIGINT&apos; や &apos;SIGUSR1&apos; のような文字列です。
省略すると、シグナルは &apos;SIGTERM&apos; となります。
詳細は kill(2) を参照してください。

</p>
<!--
Note that just because the name of this function is `process.kill`, it is
really just a signal sender, like the `kill` system call.  The signal sent
may do something other than kill the target process.
-->

<p>この関数の名前が <code>process.kill</code> であるとおり、
これは <code>kill</code> システムコールのように本当にシグナルを送信することに注意してください。
対象のプロセスを殺すだけでなく、他のシグナルも送信されます。

</p>
<!--
Example of sending a signal to yourself:
-->

<p>自身にシグナルを送信する例:

</p>
<pre><code>process.on(&apos;SIGHUP&apos;, function () {
  console.log(&apos;Got SIGHUP signal.&apos;);
});

setTimeout(function () {
  console.log(&apos;Exiting.&apos;);
  process.exit(0);
}, 100);

process.kill(process.pid, &apos;SIGHUP&apos;);</code></pre>
<h2>process.pid<span><a class="mark" href="#all_process_pid" id="all_process_pid">#</a></span></h2>
<!--
The PID of the process.
-->

<p>プロセスの PID です。

</p>
<pre><code>console.log(&apos;This process is pid &apos; + process.pid);</code></pre>
<h2>process.title<span><a class="mark" href="#all_process_title" id="all_process_title">#</a></span></h2>
<!--
Getter/setter to set what is displayed in 'ps'.
-->

<p>&apos;ps&apos; でどのよう表示されるかを設定するための getter/setter です。


</p>
<h2>process.arch<span><a class="mark" href="#all_process_arch" id="all_process_arch">#</a></span></h2>
<!--
What processor architecture you're running on: `'arm'`, `'ia32'`, or `'x64'`.
-->

<p>実行しているプロセッサのアーキテクチャ: <code>&apos;arm&apos;</code>、<code>&apos;ia32&apos;</code>、または
<code>&apos;x64&apos;</code>。

</p>
<pre><code>console.log(&apos;This processor architecture is &apos; + process.arch);</code></pre>
<h2>process.platform<span><a class="mark" href="#all_process_platform" id="all_process_platform">#</a></span></h2>
<!--
What platform you're running on. `'linux2'`, `'darwin'`, etc.
-->

<p>どのプラットフォームで動いているかです。<code>&apos;linux2&apos;</code>、<code>&apos;darwin&apos;</code>、など。

</p>
<pre><code>console.log(&apos;This platform is &apos; + process.platform);</code></pre>
<h2>process.memoryUsage()<span><a class="mark" href="#all_process_memoryusage" id="all_process_memoryusage">#</a></span></h2>
<!--
Returns an object describing the memory usage of the Node process
measured in bytes.
-->

<p>Node プロセスのメモリ使用状況をバイト単位で記述したオブジェクトを返します。

</p>
<pre><code>var util = require(&apos;util&apos;);

console.log(util.inspect(process.memoryUsage()));</code></pre>
<!--
This will generate:
-->

<p>このように生成されます:

</p>
<pre><code>{ rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472 }</code></pre>
<!--
`heapTotal` and `heapUsed` refer to V8's memory usage.
-->

<p><code>heapTotal</code> と <code>heapUsed</code> は V8 のメモリ使用状況を参照します。


</p>
<h2>process.nextTick(callback)<span><a class="mark" href="#all_process_nexttick_callback" id="all_process_nexttick_callback">#</a></span></h2>
<!--
On the next loop around the event loop call this callback.
This is *not* a simple alias to `setTimeout(fn, 0)`, it's much more
efficient.
-->

<p>イベントループの次以降のループでコールバックを呼び出します。
これは <code>setTimeout(fn, 0)</code> の単純なエイリアス<em>ではなく</em>、
はるかに効率的です。

</p>
<pre><code>process.nextTick(function () {
  console.log(&apos;nextTick callback&apos;);
});</code></pre>
<h2>process.umask([mask])<span><a class="mark" href="#all_process_umask_mask" id="all_process_umask_mask">#</a></span></h2>
<!--
Sets or reads the process's file mode creation mask. Child processes inherit
the mask from the parent process. Returns the old mask if `mask` argument is
given, otherwise returns the current mask.
-->

<p>プロセスのファイルモード作成マスクを設定または読み込みます。
子プロセスは親プロセスからマスクを継承します。
<code>mask</code> 引数が与えられると元のマスクが返され、そうでなければ現在のマスクが返されます。

</p>
<pre><code>var oldmask, newmask = 0644;

oldmask = process.umask(newmask);
console.log(&apos;Changed umask from: &apos; + oldmask.toString(8) +
            &apos; to &apos; + newmask.toString(8));</code></pre>
<h2>process.uptime()<span><a class="mark" href="#all_process_uptime" id="all_process_uptime">#</a></span></h2>
<!--
Number of seconds Node has been running.
-->

<p>Node が実行されてからの秒数です。

</p>
<h1>util<span><a class="mark" href="#all_util" id="all_util">#</a></span></h1>
<pre><code>Stability: 5 - Locked</code></pre>
<!--
These functions are in the module `'util'`. Use `require('util')` to access
them.
-->

<p>これらの関数はモジュール <code>&apos;util&apos;</code> 内にあります。
<code>require(&apos;util&apos;)</code> を使うことでこれらにアクセスします。


</p>
<h2>util.format()<span><a class="mark" href="#all_util_format" id="all_util_format">#</a></span></h2>
<!--
Returns a formatted string using the first argument as a `printf`-like format.
-->

<p>最初の引数を <code>printf</code> のようなフォーマットとして使用して、フォーマット化された
文字列を返します。

</p>
<!--
The first argument is a string that contains zero or more *placeholders*.
Each placeholder is replaced with the converted value from its corresponding
argument. Supported placeholders are:
-->

<p>第一引数は文字列で、0 個以上の <em>プレースホルダ</em> を含みます。
それぞれのプレースホルダは対応する引数を変換した値で置換されます。
サポートするプレースホルダは:

</p>
<!--
* `%s` - String.
* `%d` - Number (both integer and float).
* `%j` - JSON.
* `%%` - single percent sign (`'%'`). This does not consume an argument.
-->

<ul>
<li><code>%s</code> - 文字列。</li>
<li><code>%d</code> - 数値 (整数と浮動小数点数の両方)。</li>
<li><code>%j</code> - JSON。</li>
<li><code>%%</code> - 一つのパーセント記号 (<code>&apos;%&apos;</code>)。これは引数を消費しません。</li>
</ul>
<!--
If the placeholder does not have a corresponding argument, the placeholder is
not replaced.
-->

<p>プレースホルダに対応する引数が無い場合、そのプレースホルダは置換されません。

</p>
<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;); // &apos;foo:%s&apos;</code></pre>
<!--
If there are more arguments than placeholders, the extra arguments are
converted to strings with `util.inspect()` and these strings are concatenated,
delimited by a space.
-->

<p>プレースホルダより多くの引数がある場合、余った引数は <code>util.inspect()</code> によって
文字列化され、それらはスペース区切りで連結されます。

</p>
<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;); // &apos;foo:bar baz&apos;</code></pre>
<!--
If the first argument is not a format string then `util.format()` returns
a string that is the concatenation of all its arguments separated by spaces.
Each argument is converted to a string with `util.inspect()`.
-->

<p>第一引数がフォーマット文字列ではない場合、<code>util.format()</code> は全ての引数を
スペース区切りで連結して返します。
ここの引数は <code>util.inspect()</code> で文字列に変換されます。

</p>
<pre><code>util.format(1, 2, 3); // &apos;1 2 3&apos;</code></pre>
<h2>util.debug(string)<span><a class="mark" href="#all_util_debug_string" id="all_util_debug_string">#</a></span></h2>
<!--
A synchronous output function. Will block the process and
output `string` immediately to `stderr`.
-->

<p>同期的な出力関数です。プロセスをブロックして即座に <code>string</code> を <code>stderr</code> に出力します。

</p>
<pre><code>require(&apos;util&apos;).debug(&apos;message on stderr&apos;);</code></pre>
<h2>util.log(string)<span><a class="mark" href="#all_util_log_string" id="all_util_log_string">#</a></span></h2>
<!--
Output with timestamp on `stdout`.
-->

<p>タイムスタンプとともに <code>stdout</code> へ出力します。

</p>
<pre><code>require(&apos;util&apos;).log(&apos;Timestamped message.&apos;);</code></pre>
<h2>util.inspect(object, [showHidden], [depth], [colors])<span><a class="mark" href="#all_util_inspect_object_showhidden_depth_colors" id="all_util_inspect_object_showhidden_depth_colors">#</a></span></h2>
<!--
Return a string representation of `object`, which is useful for debugging.
-->

<p>デバッグで有用な、<code>object</code> の文字列表現を返します。

</p>
<!--
If `showHidden` is `true`, then the object's non-enumerable properties will be
shown too. Defaults to `false`.
-->

<p><code>showHidden</code> が <code>true</code> の場合、
オブジェクトの Enumerable でないプロパティも表示されます。
デフォルトは <code>false</code> です。

</p>
<!--
If `depth` is provided, it tells `inspect` how many times to recurse while
formatting the object. This is useful for inspecting large complicated objects.
-->

<p><code>depth</code> が与えられた場合、
オブジェクトをフォーマットするために何回再帰するかを <code>inspect</code> に伝えます。
これは巨大で複雑なオブジェクトを調査する場合に便利です。

</p>
<!--
The default is to only recurse twice.  To make it recurse indefinitely, pass
in `null` for `depth`.
-->

<p>デフォルトでは 2 回だけ再帰します。
無限に再帰するには、<code>depth</code> に <code>null</code> を渡します。

</p>
<!--
If `colors` is `true`, the output will be styled with ANSI color codes.
Defaults to `false`.
-->

<p><code>colors</code> が <code>true</code> の場合、出力は ANSI カラーコードで色づけされます。
デフォルトは <code>false</code> です。

</p>
<!--
Example of inspecting all properties of the `util` object:
-->

<p><code>util</code> オブジェクトの全てのプロパティを調査する例:

</p>
<pre><code>var util = require(&apos;util&apos;);

console.log(util.inspect(util, true, null));</code></pre>
<h2>util.isArray(object)<span><a class="mark" href="#all_util_isarray_object" id="all_util_isarray_object">#</a></span></h2>
<!--
Returns `true` if the given "object" is an `Array`. `false` otherwise.
-->

<p><code>object</code> が配列なら <code>true</code> を、それ以外は <code>false</code> を返します。

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isArray([])
  // true
util.isArray(new Array)
  // true
util.isArray({})
  // false</code></pre>
<h2>util.isRegExp(object)<span><a class="mark" href="#all_util_isregexp_object" id="all_util_isregexp_object">#</a></span></h2>
<!--
Returns `true` if the given "object" is a `RegExp`. `false` otherwise.
-->

<p><code>object</code> が <code>RegExp</code> なら <code>true</code> を、それ以外なら <code>false</code> を返します。

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isRegExp(/some regexp/)
  // true
util.isRegExp(new RegExp(&apos;another regexp&apos;))
  // true
util.isRegExp({})
  // false</code></pre>
<h2>util.isDate(object)<span><a class="mark" href="#all_util_isdate_object" id="all_util_isdate_object">#</a></span></h2>
<!--
Returns `true` if the given "object" is a `Date`. `false` otherwise.
-->

<p><code>object</code> が <code>Date</code> なら <code>true</code> を、それ以外なら <code>false</code> を返します。

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isDate(new Date())
  // true
util.isDate(Date())
  // false (without &apos;new&apos; returns a String)
util.isDate({})
  // false</code></pre>
<h2>util.isError(object)<span><a class="mark" href="#all_util_iserror_object" id="all_util_iserror_object">#</a></span></h2>
<!--
Returns `true` if the given "object" is an `Error`. `false` otherwise.
-->

<p><code>object</code> が <code>Error</code> なら <code>true</code> を、それ以外なら <code>false</code> を返します。

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isError(new Error())
  // true
util.isError(new TypeError())
  // true
util.isError({ name: &apos;Error&apos;, message: &apos;an error occurred&apos; })
  // false</code></pre>
<h2>util.pump(readableStream, writableStream, [callback])<span><a class="mark" href="#all_util_pump_readablestream_writablestream_callback" id="all_util_pump_readablestream_writablestream_callback">#</a></span></h2>
<!--
Experimental
-->

<p>実験的

</p>
<!--
Read the data from `readableStream` and send it to the `writableStream`.
When `writableStream.write(data)` returns `false` `readableStream` will be
paused until the `drain` event occurs on the `writableStream`. `callback` gets
an error as its only argument and is called when `writableStream` is closed or
when an error occurs.
-->

<p><code>readableStream</code> からデータを読み、それ を<code>writableStream</code> に送ります。
<code>writableStream.write(data)</code> が <code>false</code> を返す場合、
<code>writableStream</code> が <code>drain</code> イベントを生成するまで、
<code>readableStream</code> は中断します。
<code>writableStream</code> がクローズされるかエラーが発生すると、<code>callback</code> は error を唯一の引数として呼び出されます。


</p>
<h2>util.inherits(constructor, superConstructor)<span><a class="mark" href="#all_util_inherits_constructor_superconstructor" id="all_util_inherits_constructor_superconstructor">#</a></span></h2>
<!--
Inherit the prototype methods from one
[constructor](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor)
into another.  The prototype of `constructor` will be set to a new
object created from `superConstructor`.
-->

<p>ある
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor">コンストラクタ</a>
からプロトタイプメソッドを継承します。
<code>constructor</code> のプロトタイプは <code>superConstructor</code> から作られたオブジェクトに設定されます。

</p>
<!--
As an additional convenience, `superConstructor` will be accessible
through the `constructor.super_` property.
-->

<p>さらなる利便性のために、<code>superConstructor</code> は <code>constructor.super_</code>
プロパティを通じてアクセスすることができるようになります。

</p>
<pre><code>var util = require(&quot;util&quot;);
var events = require(&quot;events&quot;);

function MyStream() {
    events.EventEmitter.call(this);
}

util.inherits(MyStream, events.EventEmitter);

MyStream.prototype.write = function(data) {
    this.emit(&quot;data&quot;, data);
}

var stream = new MyStream();

console.log(stream instanceof events.EventEmitter); // true
console.log(MyStream.super_ === events.EventEmitter); // true

stream.on(&quot;data&quot;, function(data) {
    console.log(&apos;Received data: &quot;&apos; + data + &apos;&quot;&apos;);
})
stream.write(&quot;It works!&quot;); // Received data: &quot;It works!&quot;</code></pre>
<h1>Events<span><a class="mark" href="#all_events" id="all_events">#</a></span></h1>
<pre><code>Stability: 4 - API Frozen</code></pre>
<!--type=module-->

<!--
Many objects in Node emit events: a `net.Server` emits an event each time
a peer connects to it, a `fs.readStream` emits an event when the file is
opened. All objects which emit events are instances of `events.EventEmitter`.
You can access this module by doing: `require("events");`
-->

<p>Node のオブジェクトの多くはイベントを生成します:
<code>net.Server</code>は相手から接続するたびにイベントを生成し、
<code>fs.readStream</code>はファイルがオープンされるたびにイベントを生成します。
イベントを生成する全てのオブジェクトは <code>events.EventEmitter</code> のインスタンスです。
次のようにすることでこのモジュールにアクセスできます: <code>require(&quot;events&quot;);</code>

</p>
<!--
Typically, event names are represented by a camel-cased string, however,
there aren't any strict restrictions on that, as any string will be accepted.
-->

<p>通常、イベント名はキャメル記法による文字列で表現されますが、
厳格な制限ではなく、どんな文字列でも受け入れられます。

</p>
<!--
Functions can then be attached to objects, to be executed when an event
is emitted. These functions are called _listeners_.
-->

<p>関数をオブジェクトにアタッチすることができ、それはイベントが生成された時に実行されます。
これらの関数は<em>リスナー</em>と呼ばれます。


</p>
<h2>Class: events.EventEmitter<span><a class="mark" href="#all_class_events_eventemitter" id="all_class_events_eventemitter">#</a></span></h2>
<!--
To access the EventEmitter class, `require('events').EventEmitter`.
-->

<p>EventEmitterクラスにアクセスするには、<code>require(&apos;events&apos;).EventEmitter</code> を使います。

</p>
<!--
When an `EventEmitter` instance experiences an error, the typical action is
to emit an `'error'` event.  Error events are treated as a special case in node.
If there is no listener for it, then the default action is to print a stack
trace and exit the program.
-->

<p><code>EventEmitter</code> のインスタンスがエラーに遭遇した時、
典型的な動作は <code>&apos;error&apos;</code> イベントを生成することです。
node ではエラーイベントは特別に扱われます．
もしそのリスナーがなければ、デフォルトの動作はスタックトレースを出力してプログラムを終了することです。

</p>
<!--
All EventEmitters emit the event `'newListener'` when new listeners are
added.
-->

<p>全ての EventEmitter は、新しいリスナーが加えられるとイベント <code>&apos;newListener&apos;</code> を生成します。

</p>
<h3>emitter.addListener(event, listener)<span><a class="mark" href="#all_emitter_addlistener_event_listener" id="all_emitter_addlistener_event_listener">#</a></span></h3>
<h3>emitter.on(event, listener)<span><a class="mark" href="#all_emitter_on_event_listener" id="all_emitter_on_event_listener">#</a></span></h3>
<!--
Adds a listener to the end of the listeners array for the specified event.
-->

<p>指定されたイベントに対するリスナー配列の最後にリスナーを追加します。

</p>
<pre><code>server.on(&apos;connection&apos;, function (stream) {
  console.log(&apos;someone connected!&apos;);
});</code></pre>
<h3>emitter.once(event, listener)<span><a class="mark" href="#all_emitter_once_event_listener" id="all_emitter_once_event_listener">#</a></span></h3>
<!--
Adds a **one time** listener for the event. This listener is
invoked only the next time the event is fired, after which
it is removed.
-->

<p><strong>一回限り</strong>のリスナーをイベントに追加します。
このリスナーは次にイベントが発生した時に限り起動され、その後で削除されます。

</p>
<pre><code>server.once(&apos;connection&apos;, function (stream) {
  console.log(&apos;Ah, we have our first user!&apos;);
});</code></pre>
<h3>emitter.removeListener(event, listener)<span><a class="mark" href="#all_emitter_removelistener_event_listener" id="all_emitter_removelistener_event_listener">#</a></span></h3>
<!--
Remove a listener from the listener array for the specified event.
**Caution**: changes array indices in the listener array behind the listener.
-->

<p>指定されたイベントに対するリスナー配列からリスナーを削除します。
<strong>注意</strong>: リスナーの背後にあるリスナー配列のインデックスが変化します。

</p>
<pre><code>var callback = function(stream) {
  console.log(&apos;someone connected!&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);</code></pre>
<h3>emitter.removeAllListeners([event])<span><a class="mark" href="#all_emitter_removealllisteners_event" id="all_emitter_removealllisteners_event">#</a></span></h3>
<!--
Removes all listeners, or those of the specified event.
-->

<p>全てのリスナーまたは指定されたイベントに対するリスナーを削除します。


</p>
<h3>emitter.setMaxListeners(n)<span><a class="mark" href="#all_emitter_setmaxlisteners_n" id="all_emitter_setmaxlisteners_n">#</a></span></h3>
<!--
By default EventEmitters will print a warning if more than 10 listeners are
added for a particular event. This is a useful default which helps finding memory leaks.
Obviously not all Emitters should be limited to 10. This function allows
that to be increased. Set to zero for unlimited.
-->

<p>デフォルトでは、EventEmitter は 10 を越えるリスナが特定のイベントに追加されると警告を出力します。
これはメモリリークを見つけるために役に立つデフォルト値です。
全ての EventEmitter が 10 に制限されなければならないわけではないことは明らかです。
この関数は制限を増やすことを許可します。
0 を設定すると無制限になります。

</p>
<h3>emitter.listeners(event)<span><a class="mark" href="#all_emitter_listeners_event" id="all_emitter_listeners_event">#</a></span></h3>
<!--
Returns an array of listeners for the specified event. This array can be
manipulated, e.g. to remove listeners.
-->

<p>指定されたイベントに対するリスナー配列を返します。
この配列は変更することができます、例えばリスナーを削除するなど。

</p>
<pre><code>server.on(&apos;connection&apos;, function (stream) {
  console.log(&apos;someone connected!&apos;);
});
console.log(util.inspect(server.listeners(&apos;connection&apos;))); // [ [Function] ]</code></pre>
<h3>emitter.emit(event, [arg1], [arg2], [...])<span><a class="mark" href="#all_emitter_emit_event_arg1_arg2" id="all_emitter_emit_event_arg1_arg2">#</a></span></h3>
<!--
Execute each of the listeners in order with the supplied arguments.
-->

<p>提供された引数の並びでそれぞれのリスナーを実行します。

</p>
<h3>Event: &apos;newListener&apos;<span><a class="mark" href="#all_event_newlistener" id="all_event_newlistener">#</a></span></h3>
<div class="signature"><ul>
<li><code>event</code> <span class="type">String</span> The event name</li>
<li><code>listener</code> <span class="type">Function</span> The event handler function</li>
</div></ul>
<!--
This event is emitted any time someone adds a new listener.
-->

<p>このイベントは誰かが新しいリスナーを追加するといつでも生成されます。

</p>
<h1>Buffer<span><a class="mark" href="#all_buffer_1" id="all_buffer_1">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
Pure Javascript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it's necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.
-->

<p>純粋な JavaScript は Unicode と相性がいいものの、バイナリデータの扱いはうまくありません。
TCP ストリームやファイルシステムを扱う場合は、オクテットストリームを処理する必要があります。
Node にはオクテットストリームを操作、作成、消費するためにいくつかの戦略があります。

</p>
<!--
Raw data is stored in instances of the `Buffer` class. A `Buffer` is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A `Buffer` cannot be resized.
-->

<p>生のデータは <code>Buffer</code> クラスのインスタンスに保存されます。
<code>Buffer</code> は整数の配列と似ていますが、
V8 ヒープの外部に割り当てられた生のメモリに対応します。
<code>Buffer</code> のサイズを変更することはできません。

</p>
<!--
The `Buffer` class is a global, making it very rare that one would need
to ever `require('buffer')`.
-->

<p><code>Buffer</code> クラスはグローバルなので、<code>require(&apos;buffer&apos;)</code> が必要になることは
ほとんどありません。

</p>
<!--
Converting between Buffers and JavaScript string objects requires an explicit
encoding method.  Here are the different string encodings.
-->

<p>バッファを JavaScript 文字列オブジェクトとの間で変換するにはエンコーディング方式を明示する必要があります。
いくつかのエンコーディング方式があります。

</p>
<!--
* `'ascii'` - for 7 bit ASCII data only.  This encoding method is very fast, and
  will strip the high bit if set.
  Note that this encoding converts a null character (`'\0'` or `'\u0000'`) into
  `0x20` (character code of a space). If you want to convert a null character
  into `0x00`, you should use `'utf8'`.

* `'utf8'` - Multi byte encoded Unicode characters.  Many web pages and other document formats use UTF-8.

* `'ucs2'` - 2-bytes, little endian encoded Unicode characters. It can encode
  only BMP(Basic Multilingual Plane, U+0000 - U+FFFF).

* `'base64'` - Base64 string encoding.

* `'binary'` - A way of encoding raw binary data into strings by using only
  the first 8 bits of each character. This encoding method is deprecated and
  should be avoided in favor of `Buffer` objects where possible. This encoding
  will be removed in future versions of Node.

* `'hex'` - Encode each byte as two hexidecimal characters.
-->

<ul>
<li><code>&apos;ascii&apos;</code> - 7bit の ASCII データ専用です。
このエンコーディング方式はとても高速で、もし上位ビットがセットされていれば取り除かれます。
このエンコーディングは、null 文字 (<code>&apos;\0&apos;</code> または <code>&apos;\u0000&apos;</code>) を <code>0x20</code>
(スペースの文字コード) に変換することに注意してください。
null 文字を 0x00 に変換したい場合は <code>&apos;utf8&apos;</code> を使用してください。</li>
<li><code>&apos;utf8&apos;</code> - 可変長のバイト単位でエンコードされたUnicode文字。
多くのWebページやその他のドキュメントは UTF-8 を使っています。</li>
<li><code>&apos;ucs2&apos;</code> - 固定長の2バイト（リトルエンディアン）でエンコードされたUnicode文字。
BMP (基本多言語面、U+0000～U+FFFF) のみエンコードすることができます。</li>
<li><code>&apos;base64&apos;</code> - Base64 文字列エンコーディング.</li>
<li><code>&apos;binary&apos;</code> - 生のバイナリデータを各文字の最初の 8bit として使用するエンコーディング方式。
このエンコーディング方式はもはや価値がなく、<code>Buffer</code> オブジェクトでは可能な限り使用すべきではありません。
このエンコーディングは、Node の将来のバージョンで削除される予定です。</li>
<li><code>&apos;hex&apos;</code> - 各バイトを 2 桁の16進数文字列でエンコードします。</li>
</ul>
<h2>Class: Buffer<span><a class="mark" href="#all_class_buffer" id="all_class_buffer">#</a></span></h2>
<!--
The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.
-->

<p>Buffer クラスはバイナリデータを直接扱うためのグローバルな型です。
それは様々な方法で構築することができます。

</p>
<h3>new Buffer(size)<span><a class="mark" href="#all_new_buffer_size" id="all_new_buffer_size">#</a></span></h3>
<div class="signature"><ul>
<li><code>size</code> Number</li>
</div></ul>
<!--
Allocates a new buffer of `size` octets.
-->

<p><code>size</code> オクテットの新しいバッファを割り当てます。

</p>
<h3>new Buffer(array)<span><a class="mark" href="#all_new_buffer_array" id="all_new_buffer_array">#</a></span></h3>
<div class="signature"><ul>
<li><code>array</code> Array</li>
</div></ul>
<!--
Allocates a new buffer using an `array` of octets.
-->

<p>オクテットの <code>array</code> を使用する新しいバッファを割り当てます。

</p>
<h3>new Buffer(str, [encoding])<span><a class="mark" href="#all_new_buffer_str_encoding" id="all_new_buffer_str_encoding">#</a></span></h3>
<!--
* `str` String - string to encode.
* `encoding` String - encoding to use, Optional.
-->

<ul>
<li><code>str</code> String - エンコードされる文字列</li>
<li><code>encoding</code> String - 使用するエンコード、Optional、Default: &apos;utf8&apos;</li>
</ul>
<!--
Allocates a new buffer containing the given `str`.
`encoding` defaults to `'utf8'`.
-->

<p>与えられた <code>str</code> を内容とする新しいバッファを割り当てます。
<code>encoding</code> のデフォルトは <code>&apos;utf8&apos;</code> です。

</p>
<h3>buf.write(string, [offset], [length], [encoding])<span><a class="mark" href="#all_buf_write_string_offset_length_encoding" id="all_buf_write_string_offset_length_encoding">#</a></span></h3>
<!--
* `string` String - data to be written to buffer
* `offset` Number, Optional, Default: 0
* `length` Number, Optional
* `encoding` String, Optional, Default: 'utf8'
-->

<ul>
<li><code>string</code> String - バッファに書き込まれるデータ</li>
<li><code>offset</code> Number, Optional, Default: 0</li>
<li><code>length</code> Number, Optional</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
</ul>
<!--
Writes `string` to the buffer at `offset` using the given encoding.
`offset` defaults to `0`, `encoding` defaults to `'utf8'`. `length` is
the number of bytes to write. Returns number of octets written. If `buffer` did
not contain enough space to fit the entire string, it will write a partial
amount of the string. `length` defaults to `buffer.length - offset`.
The method will not write partial characters.
-->

<p>与えられたエンコーディングを使用して、<code>string</code> をバッファの <code>offset</code> から書き込みます。
<code>offset</code> のデフォルトは <code>0</code>、<code>encoding</code> のデフォルトは <code>&apos;utf8&apos;</code> です。
<code>length</code> は書き込むバイト数です。書き込まれたオクテット数を返します。
もし <code>buffer</code> が文字列全体を挿入するのに十分なスペースを含んでいなければ、文字列の一部だけを書き込みます。
<code>length</code> のデフォルトは <code>buffer.length - offset</code> です。
このメソッドは文字の一部だけを書き込むことはありません。

</p>
<!--
Example: write a utf8 string into a buffer, then print it
-->

<p>例: utf8 の文字列をバッファに書き込み、それをプリントします

</p>
<pre><code>buf = new Buffer(256);
len = buf.write(&apos;\u00bd + \u00bc = \u00be&apos;, 0);
console.log(len + &quot; bytes: &quot; + buf.toString(&apos;utf8&apos;, 0, len));</code></pre>
<!--
The number of characters written (which may be different than the number of
bytes written) is set in `Buffer._charsWritten` and will be overwritten the
next time `buf.write()` is called.
-->

<p>書き込まれた文字数 (書き込まれたバイト数とは異なる場合があります) は、
次に <code>buf.write()</code> が呼び出されて上書きされるまで
<code>Buffer._charsWritten</code> に設定されています。

</p>
<h3>buf.toString([encoding], [start], [end])<span><a class="mark" href="#all_buf_tostring_encoding_start_end" id="all_buf_tostring_encoding_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional</li>
</div></ul>
<!--
Decodes and returns a string from buffer data encoded with `encoding`
(defaults to `'utf8'`) beginning at `start` (defaults to `0`) and ending at
`end` (defaults to `buffer.length`).
-->

<p><code>encoding</code> (デフォルトは <code>&apos;utf8&apos;</code>) でエンコードされたバッファデータの
<code>start</code> (デフォルトは <code>0</code>) から <code>end</code> (デフォルトは <code>buffer.length</code>)
までをデコードした文字列を返します。

</p>
<!--
See `buffer.write()` example, above.
-->

<p>上の <code>buffer.write()</code> の例を参照してください。


</p>
<h3>buf[index]<span><a class="mark" href="#all_buf_index" id="all_buf_index">#</a></span></h3>
<!--type=property-->

<!--name=[index]-->

<!--
Get and set the octet at `index`. The values refer to individual bytes,
so the legal range is between `0x00` and `0xFF` hex or `0` and `255`.
-->

<p><code>index</code> の位置のオクテットを取得および設定します。
その値は個々のバイトを参照するので、妥当な範囲は 16 進の <code>0x00</code> から <code>0xFF</code>
または <code>0</code> から<code>255</code>までの間です。

</p>
<!--
Example: copy an ASCII string into a buffer, one byte at a time:
-->

<p>例: ASCII 文字列を 1 バイトずつバッファにコピーします

</p>
<pre><code>str = &quot;node.js&quot;;
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>
<h3>Class Method: Buffer.isBuffer(obj)<span><a class="mark" href="#all_class_method_buffer_isbuffer_obj" id="all_class_method_buffer_isbuffer_obj">#</a></span></h3>
<div class="signature"><ul>
<li><code>obj</code> Object</li>
<li>Return: Boolean</li>
</div></ul>
<!--
Tests if `obj` is a `Buffer`.
-->

<p><code>obj</code> が <code>Buffer</code> かどうかテストします。

</p>
<h3>Class Method: Buffer.byteLength(string, [encoding])<span><a class="mark" href="#all_class_method_buffer_bytelength_string_encoding" id="all_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>string</code> String</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li>Return: Number</li>
</div></ul>
<!--
Gives the actual byte length of a string. `encoding` defaults to `'utf8'`.
This is not the same as `String.prototype.length` since that returns the
number of *characters* in a string.
-->

<p>文字列の実際のバイト数を返します。<code>encoding</code> のデフォルトは <code>&apos;utf8&apos;</code> です。
これは文字列の<em>文字</em>数を返す <code>String.prototype.length</code> と同じではありません。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>str = &apos;\u00bd + \u00bc = \u00be&apos;;

console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +
  Buffer.byteLength(str, &apos;utf8&apos;) + &quot; bytes&quot;);

// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
<h3>buf.length<span><a class="mark" href="#all_buf_length" id="all_buf_length">#</a></span></h3>
<div class="signature"><ul>
<li>Number</li>
</div></ul>
<!--
The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. `length` refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.
-->

<p>バイト数によるバッファのサイズ。
これは実際の内容のサイズではないことに注意してください。
<code>length</code> はバッファオブジェクトに割り当てられたメモリ全体を参照します。

</p>
<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write(&quot;some string&quot;, &quot;ascii&quot;, 0);
console.log(buf.length);

// 1234
// 1234</code></pre>
<h3>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])<span><a class="mark" href="#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend" id="all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">#</a></span></h3>
<!--
* `targetBuffer` Buffer object - Buffer to copy into
* `targetStart` Number, Optional, Default: 0
* `sourceStart` Number, Optional, Default: 0
* `sourceEnd` Number, Optional, Default: 0
-->

<ul>
<li><code>targetBuffer</code> Buffer object - コピー先の Buffer</li>
<li><code>targetStart</code> Number, Optional, Default: 0</li>
<li><code>sourceStart</code> Number, Optional, Default: 0</li>
<li><code>sourceEnd</code> Number, Optional, Default: 0</li>
</ul>
<!--
Does copy between buffers. The source and target regions can be overlapped.
`targetStart` and `sourceStart` default to `0`.
`sourceEnd` defaults to `buffer.length`.
-->

<p>バッファ間でコピーします。
ソースとターゲットの領域は重なっていても構いません。
<code>targetStart</code> と <code>sourceStart</code> のデフォルトは <code>0</code> です。
<code>sourceEnd</code> のデフォルトは <code>buffer.length</code> です。

</p>
<!--
Example: build two Buffers, then copy `buf1` from byte 16 through byte 19
into `buf2`, starting at the 8th byte in `buf2`.
-->

<p>例: バッファを2個作成し、<code>buf1</code> の 16 バイト目から 19 バイト目を、
<code>buf2</code> の 8 バイト目から始まる位置へコピーします。

</p>
<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString(&apos;ascii&apos;, 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
<h3>buf.slice([start], [end])<span><a class="mark" href="#all_buf_slice_start_end" id="all_buf_slice_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional, Default: 0</li>
</div></ul>
<!--
Returns a new buffer which references the same memory as the old, but offset
and cropped by the `start` (defaults to `0`) and `end` (defaults to
`buffer.length`) indexes.
-->

<p>元のバッファと同じメモリを参照しますが、<code>start</code> (デフォルトは <code>0</code>) と
<code>end</code> (デフォルトは <code>buffer.length</code>) で示されるオフセットと長さを持つ
新しいバッファを返します。

</p>
<!--
**Modifying the new buffer slice will modify memory in the original buffer!**
-->

<p><strong>新しいバッファスライスの変更は、オリジナルバッファのメモリを変更することになります！</strong>

</p>
<!--
Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.
-->

<p>例: ASCII のアルファベットでバッファを構築してスライスし、元のバッファで 1 バイトを変更します。

</p>
<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));

// abc
// !bc</code></pre>
<h3>buf.readUInt8(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint8_offset_noassert" id="all_buf_readuint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<!--
Reads an unsigned 8 bit integer from the buffer at the specified offset.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.
-->

<p>バッファの指定された位置を符号無し 8bit 整数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// 0x3
// 0x4
// 0x23
// 0x42</code></pre>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint16le_offset_noassert" id="all_buf_readuint16le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint16be_offset_noassert" id="all_buf_readuint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<!--
Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.
-->

<p>バッファの指定された位置を符号無し 16bit 整数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint32le_offset_noassert" id="all_buf_readuint32le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint32be_offset_noassert" id="all_buf_readuint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<!--
Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.
-->

<p>バッファの指定された位置を符号無し 32bit 整数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403</code></pre>
<h3>buf.readInt8(offset, [noAssert])<span><a class="mark" href="#all_buf_readint8_offset_noassert" id="all_buf_readint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<!--
Reads a signed 8 bit integer from the buffer at the specified offset.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.

Works as `buffer.readUInt8`, except buffer contents are treated as two's
complement signed values.
-->

<p>バッファの指定された位置を符号付き 8bit 整数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は
<code>buffer.readUInt8</code> と同じように動作します。

</p>
<h3>buf.readInt16LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint16le_offset_noassert" id="all_buf_readint16le_offset_noassert">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint16be_offset_noassert" id="all_buf_readint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<!--
Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.

Works as `buffer.readUInt16*`, except buffer contents are treated as two's
complement signed values.
-->

<p>バッファの指定された位置を符号付き 16bit 整数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は
<code>buffer.readUInt16</code> と同じように動作します。


</p>
<h3>buf.readInt32LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint32le_offset_noassert" id="all_buf_readint32le_offset_noassert">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint32be_offset_noassert" id="all_buf_readint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<!--
Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.

Works as `buffer.readUInt32*`, except buffer contents are treated as two's
complement signed values.
-->

<p>バッファの指定された位置を符号付き 32bit 整数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は
<code>buffer.readUInt32</code> と同じように動作します。


</p>
<h3>buf.readFloatLE(offset, [noAssert])<span><a class="mark" href="#all_buf_readfloatle_offset_noassert" id="all_buf_readfloatle_offset_noassert">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a class="mark" href="#all_buf_readfloatbe_offset_noassert" id="all_buf_readfloatbe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<!--
Reads a 32 bit float from the buffer at the specified offset with specified
endian format.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.
-->

<p>バッファの指定された位置を 32bit 浮動小数点数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// 0x01</code></pre>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a class="mark" href="#all_buf_readdoublele_offset_noassert" id="all_buf_readdoublele_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a class="mark" href="#all_buf_readdoublebe_offset_noassert" id="all_buf_readdoublebe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<!--
Reads a 64 bit double from the buffer at the specified offset with specified
endian format.

Set `noAssert` to true to skip validation of `offset`. This means that `offset`
may be beyond the end of the buffer. Defaults to `false`.
-->

<p>バッファの指定された位置を 64bit 倍精度浮動小数点数として読み込みます。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。
これは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// 0.3333333333333333</code></pre>
<h3>buf.writeUInt8(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint8_value_offset_noassert" id="all_buf_writeuint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<!--
Writes `value` to the buffer at the specified offset. Note, `value` must be a
valid unsigned 8 bit integer.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.
-->

<p><code>value</code> を符号無し 8bit 整数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 8bit 符号無し整数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);

// &lt;Buffer 03 04 23 42&gt;</code></pre>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint16le_value_offset_noassert" id="all_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint16be_value_offset_noassert" id="all_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<!--
Writes `value` to the buffer at the specified offset with specified endian
format. Note, `value` must be a valid unsigned 16 bit integer.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.
-->

<p><code>value</code> を符号無し 16bit 整数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 16bit 符号無し整数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);

// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint32le_value_offset_noassert" id="all_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint32be_value_offset_noassert" id="all_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<!--
Writes `value` to the buffer at the specified offset with specified endian
format. Note, `value` must be a valid unsigned 32 bit integer.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.
-->

<p><code>value</code> を符号無し 32bit 整数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 32bit 符号無し整数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);

// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>
<h3>buf.writeInt8(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint8_value_offset_noassert" id="all_buf_writeint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<!--
Writes `value` to the buffer at the specified offset. Note, `value` must be a
valid signed 8 bit integer.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.

Works as `buffer.writeUInt8`, except value is written out as a two's complement
signed integer into `buffer`.
-->

<p><code>value</code> を符号付き 8bit 整数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 8bit 符号付き整数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は 
<code>buffer.writeUInt8</code> と同じように動作します。

</p>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint16le_value_offset_noassert" id="all_buf_writeint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint16be_value_offset_noassert" id="all_buf_writeint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<!--
Writes `value` to the buffer at the specified offset with specified endian
format. Note, `value` must be a valid signed 16 bit integer.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.

Works as `buffer.writeUInt16*`, except value is written out as a two's
complement signed integer into `buffer`.
-->

<p><code>value</code> を符号付き 16bit 整数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 16bit 符号付き整数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は 
<code>buffer.writeUInt16</code> と同じように動作します。

</p>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint32le_value_offset_noassert" id="all_buf_writeint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint32be_value_offset_noassert" id="all_buf_writeint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<!--
Writes `value` to the buffer at the specified offset with specified endian
format. Note, `value` must be a valid signed 32 bit integer.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.

Works as `buffer.writeUInt32*`, except value is written out as a two's
complement signed integer into `buffer`.
-->

<p><code>value</code> を符号付き 32bit 整数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 32bit 符号付き整数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は 
<code>buffer.writeUInt32</code> と同じように動作します。

</p>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writefloatle_value_offset_noassert" id="all_buf_writefloatle_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writefloatbe_value_offset_noassert" id="all_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<!--
Writes `value` to the buffer at the specified offset with specified endian
format. Note, `value` must be a valid 32 bit float.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.
-->

<p><code>value</code> を 32bit 浮動小数点数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 32bit 浮動小数点数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writedoublele_value_offset_noassert" id="all_buf_writedoublele_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writedoublebe_value_offset_noassert" id="all_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<!--
Writes `value` to the buffer at the specified offset with specified endian
format. Note, `value` must be a valid 64 bit double.

Set `noAssert` to true to skip validation of `value` and `offset`. This means
that `value` may be too large for the specific function and `offset` may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to `false`.
-->

<p><code>value</code> を 64bit 倍精度浮動小数点数としてバッファの指定された位置に、
指定されたエンディアンで書き込みます。
<code>value</code> は妥当な 64bit 倍精度浮動小数点数でなければならないことに注意してください。

</p>
<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。
これは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> 
がバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。
正確性に確信がない限り、これらを使用すべきではありません。
デフォルトは <code>false</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);

// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
<h3>buf.fill(value, [offset], [end])<span><a class="mark" href="#all_buf_fill_value_offset_end" id="all_buf_fill_value_offset_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code></li>
<li><code>offset</code> Number, Optional</li>
<li><code>end</code> Number, Optional</li>
</div></ul>
<!--
Fills the buffer with the specified value. If the `offset` (defaults to `0`)
and `end` (defaults to `buffer.length`) are not given it will fill the entire
buffer.
-->

<p>指定された値でバッファを埋めます。
<code>offset</code> (デフォルトは <code>0</code>) と <code>end</code> (デフォルトは <code>buffer.length</code>)
Fが与えられなかった場合はバッファ全体を埋めます。

</p>
<pre><code>var b = new Buffer(50);
b.fill(&quot;h&quot;);</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#all_buffer_inspect_max_bytes" id="all_buffer_inspect_max_bytes">#</a></span></h2>
<div class="signature"><ul>
<li>Number, Default: 50</li>
</div></ul>
<!--
How many bytes will be returned when `buffer.inspect()` is called. This can
be overridden by user modules.

Note that this is a property on the buffer module returned by
`require('buffer')`, not on the Buffer global, or a buffer instance.
-->

<p><code>buffer.inspect()</code> が呼び出された場合に返すバイト数です。
これはユーザモジュールによって上書きすることができます。

</p>
<p>これはグローバルの Buffer やそのインスタンスではなく、 <code>requrie(&apos;buffer&apos;)</code>
によって返される buffer モジュールのプロパティであることに注意してください。

</p>
<h2>Class: SlowBuffer<span><a class="mark" href="#all_class_slowbuffer" id="all_class_slowbuffer">#</a></span></h2>
<!--
This class is primarily for internal use.  JavaScript programs should
use Buffer instead of using SlowBuffer.

In order to avoid the overhead of allocating many C++ Buffer objects for
small blocks of memory in the lifetime of a server, Node allocates memory
in 8Kb (8192 byte) chunks.  If a buffer is smaller than this size, then it
will be backed by a parent SlowBuffer object.  If it is larger than this,
then Node will allocate a SlowBuffer slab for it directly.
-->

<p>このクラスは主に内部利用のためのものです。JavaScsript プログラムは SlowBuffer
よりも Buffer を使用すべきです。

</p>
<p>サーバの動作中に、小さなメモリブロックのために多くの C++ バッファオブジェクトが
割り当てられるオーバーヘッドを避けるため、Node はメモリを 8Kb (8192 バイト) の
チャンク内に割り当てます。もしバッファがこのサイズより小さければ、それは
親の SlowBuffer に支えられます。それより大きければ、Node は SlowBuffer を
直接割り当てます。

</p>
<h1>Stream<span><a class="mark" href="#all_stream" id="all_stream">#</a></span></h1>
<pre><code>Stability: 2 - Unstable</code></pre>
<!--
A stream is an abstract interface implemented by various objects in Node.
For example a request to an HTTP server is a stream, as is stdout. Streams
are readable, writable, or both. All streams are instances of `EventEmitter`.

You can load up the Stream base class by doing `require('stream')`.
-->

<p>ストリームは Node の様々なオブジェクトで実装される抽象的なインタフェースです。
例えば HTTP サーバへのリクエストは標準出力と同様にストリームです。
ストリームは読み込み可能、書き込み可能、またはその両方です。
全てのストリームは <code>EventEmitter</code> のインスタンスです。

</p>
<p>Stream のベースクラスは <code>require(&apos;stream&apos;)</code> でロードすることができます。

</p>
<h2>Readable Stream<span><a class="mark" href="#all_readable_stream" id="all_readable_stream">#</a></span></h2>
<!--type=class-->

<!--
A `Readable Stream` has the following methods, members, and events.
-->

<p><code>Readable Stream</code> には以下のメソッド、メンバー、そしてイベントがあります。

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data" id="all_event_data">#</a></span></h3>
<p><code>function (data) { }</code>

</p>
<!--
The `'data'` event emits either a `Buffer` (by default) or a string if
`setEncoding()` was used.

Note that the __data will be lost__ if there is no listener when a
`Readable Stream` emits a `'data'` event.
-->

<p><code>&apos;data&apos;</code> イベントは <code>Buffer</code> (デフォルト) または、
<code>setEncoding()</code> された場合は文字列のどちらかを生成します

</p>
<p><code>Readable Stream</code> が <code>&apos;data&apos;</code> イベントを生成した時にリスナが存在しなければ、
<strong>データは失われる</strong>ことに注意してください。

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end" id="all_event_end">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Emitted when the stream has received an EOF (FIN in TCP terminology).
Indicates that no more `'data'` events will happen. If the stream is also
writable, it may be possible to continue writing.
-->

<p>ストリームが EOF (TCP 用語では FIN) を受信した時に生成されます。
<code>&apos;data&apos;</code> イベントがもう発生しないことを示します。
ストリームがもし書き込み可能でもあるなら、書き込みを続けることは可能かもしれません。

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error" id="all_event_error">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<!--
Emitted if there was an error receiving data.
-->

<p>データ受信でエラーがあると生成されます。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close" id="all_event_close">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Emitted when the underlying file descriptor has been closed. Not all streams
will emit this.  (For example, an incoming HTTP request will not emit
`'close'`.)
-->

<p>下層でファイル記述子がクローズされた時に生成されます。
全てのストリームがこのイベントを発生するわけではありません。
(例えば、インカミングの HTTP リクエストは <code>&apos;close&apos;</code> イベントを生成しません。)

</p>
<h3>stream.readable<span><a class="mark" href="#all_stream_readable" id="all_stream_readable">#</a></span></h3>
<!--
A boolean that is `true` by default, but turns `false` after an `'error'`
occurred, the stream came to an `'end'`, or `destroy()` was called.
-->

<p>デフォルトでは <code>true</code> ですが、<code>&apos;error&apos;</code> が発生した後、
ストリームが <code>&apos;end&apos;</code> に達した後、または <code>destroy()</code> が呼ばれた後で、
<code>false</code> に設定される boolean です。

</p>
<h3>stream.setEncoding(encoding)<span><a class="mark" href="#all_stream_setencoding_encoding" id="all_stream_setencoding_encoding">#</a></span></h3>
<!--
Makes the data event emit a string instead of a `Buffer`. `encoding` can be
`'utf8'`, `'ascii'`, or `'base64'`.
-->

<p><code>&apos;data&apos;</code> イベントが <code>Buffer</code> ではなく文字列を生成するようにします。
<code>encoding</code> には <code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>、
または <code>&apos;base64&apos;</code> を指定することができます。

</p>
<h3>stream.pause()<span><a class="mark" href="#all_stream_pause" id="all_stream_pause">#</a></span></h3>
<!--
Pauses the incoming `'data'` events.
-->

<p><code>&apos;data&apos;</code> イベントの到着を中断します。

</p>
<h3>stream.resume()<span><a class="mark" href="#all_stream_resume" id="all_stream_resume">#</a></span></h3>
<!--
Resumes the incoming `'data'` events after a `pause()`.
-->

<p><code>pause()</code> の後で <code>&apos;data&apos;</code> イベントの到着を再開します。

</p>
<h3>stream.destroy()<span><a class="mark" href="#all_stream_destroy" id="all_stream_destroy">#</a></span></h3>
<!--
Closes the underlying file descriptor. Stream will not emit any more events.
-->

<p>下層のファイル記述子をクローズします。ストリームはそれ以上イベントを生成しなくなります。

</p>
<h3>stream.destroySoon()<span><a class="mark" href="#all_stream_destroysoon" id="all_stream_destroysoon">#</a></span></h3>
<!--
After the write queue is drained, close the file descriptor.
-->

<p>書き込みキューが空になった後、ファイル記述子をクローズします。

</p>
<h3>stream.pipe(destination, [options])<span><a class="mark" href="#all_stream_pipe_destination_options" id="all_stream_pipe_destination_options">#</a></span></h3>
<!--
This is a `Stream.prototype` method available on all `Stream`s.
-->

<p>これは全ての <code>Stream</code> で利用可能な <code>Stream.prototype</code> メソッドです。

</p>
<!--
Connects this read stream to `destination` WriteStream. Incoming
data on this stream gets written to `destination`. The destination and source
streams are kept in sync by pausing and resuming as necessary.
-->

<p>読み込みストリームを <code>destination</code> の書き込みストリームに接続します。
このストリームに入ってきたデータは <code>destination</code> に書き込まれます。
接続先と接続元のストリームは、必要に応じて中断と再開することで同期を保ちます。

</p>
<!--
This function returns the `destination` stream.
-->

<p>この関数は <code>destination</code> ストリームを返します。

</p>
<!--
Emulating the Unix `cat` command:
-->

<p>Unix の <code>cat</code> コマンドのエミュレート:

</p>
<pre><code>process.stdin.resume();
process.stdin.pipe(process.stdout);</code></pre>
<!--
By default `end()` is called on the destination when the source stream emits
`end`, so that `destination` is no longer writable. Pass `{ end: false }` as
`options` to keep the destination stream open.
-->

<p>デフォルトでは接続元ストリームで <code>end</code> イベントが生成されると、
接続先の <code>end()</code> が呼ばれるので、もう書き込みはできません。
<code>option</code> に <code>{ end: false }</code> を渡すと接続先はストリームはオープンされたままとなります。

</p>
<!--
This keeps `process.stdout` open so that "Goodbye" can be written at the end.
-->

<p>これは <code>process.stdout</code> をオープンしたままにして最後に &quot;Goodbye&quot; と出力します。

</p>
<pre><code>process.stdin.resume();

process.stdin.pipe(process.stdout, { end: false });

process.stdin.on(&quot;end&quot;, function() {
  process.stdout.write(&quot;Goodbye\n&quot;);
});</code></pre>
<h2>Writable Stream<span><a class="mark" href="#all_writable_stream" id="all_writable_stream">#</a></span></h2>
<!--type=class-->

<!--
A `Writable Stream` has the following methods, members, and events.
-->

<p><code>Writable Stream</code> には以下のメソッド、メンバー、そしてイベントがあります。

</p>
<h3>Event: &apos;drain&apos;<span><a class="mark" href="#all_event_drain" id="all_event_drain">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
After a `write()` method returned `false`, this event is emitted to
indicate that it is safe to write again.
-->

<p><code>write()</code> メソッドが <code>false</code> でリターンした後、
再び安全に書き込むことができるようになったことを示すために、
このイベントは生成されます。

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_1" id="all_event_error_1">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<!--
Emitted on error with the exception `exception`.
-->

<p><code>exception</code> 例外によるエラーについて生成されます。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_1" id="all_event_close_1">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Emitted when the underlying file descriptor has been closed.
-->

<p>下層でファイル記述子がクローズされた時に生成されます。

</p>
<h3>Event: &apos;pipe&apos;<span><a class="mark" href="#all_event_pipe" id="all_event_pipe">#</a></span></h3>
<p><code>function (src) { }</code>

</p>
<!--
Emitted when the stream is passed to a readable stream's pipe method.
-->

<p>このストリームが読み込み可能ストリームの pipe メソッドに渡された時に生成されます。

</p>
<h3>stream.writable<span><a class="mark" href="#all_stream_writable" id="all_stream_writable">#</a></span></h3>
<!--
A boolean that is `true` by default, but turns `false` after an `'error'`
occurred or `end()` / `destroy()` was called.
-->

<p>デフォルトでは <code>true</code> ですが、<code>&apos;error&apos;</code> が発生した後、
<code>end()</code> / <code>destroy()</code> が呼ばれた後で <code>false</code> に設定される boolean です。

</p>
<h3>stream.write(string, [encoding], [fd])<span><a class="mark" href="#all_stream_write_string_encoding_fd" id="all_stream_write_string_encoding_fd">#</a></span></h3>
<!--
Writes `string` with the given `encoding` to the stream.  Returns `true` if
the string has been flushed to the kernel buffer.  Returns `false` to
indicate that the kernel buffer is full, and the data will be sent out in
the future. The `'drain'` event will indicate when the kernel buffer is
empty again. The `encoding` defaults to `'utf8'`.
-->

<p>与えられた <code>encoding</code> で <code>string</code> を書き込みます。
文字列がカーネルバッファにフラッシュされた場合は <code>true</code> が返ります。
カーネルバッファがいっぱいの場合は、データが将来カーネルバッファに送られることを示すために、
<code>false</code> が返ります。
<code>&apos;drain&apos;</code> イベントがカーネルバッファが再び空いたことを示します。
<code>encoding</code> のデフォルトは <code>&apos;utf8&apos;</code> です。

</p>
<!--
If the optional `fd` parameter is specified, it is interpreted as an integral
file descriptor to be sent over the stream. This is only supported for UNIX
streams, and is silently ignored otherwise. When writing a file descriptor in
this manner, closing the descriptor before the stream drains risks sending an
invalid (closed) FD.
-->

<p>オプションの <code>fd</code> 引数が指定されると、
ストリームに送信するための基礎となるファイル記述子として解釈されます。
これは UNIX ストリームでのみサポートされており、その他では黙って無視されます。
このようにファイル記述子に書き込む場合、ストリームが流れきる前にファイル記述子をクローズすると、
データが不正な (クローズされた) ファイル記述子に送られるリスクがあります。

</p>
<h3>stream.write(buffer)<span><a class="mark" href="#all_stream_write_buffer" id="all_stream_write_buffer">#</a></span></h3>
<!--
Same as the above except with a raw buffer.
-->

<p>生のバッファを使うこと以外は上記と同じです。

</p>
<h3>stream.end()<span><a class="mark" href="#all_stream_end" id="all_stream_end">#</a></span></h3>
<!--
Terminates the stream with EOF or FIN.
This call will allow queued write data to be sent before closing the stream.
-->

<p>ストリームを EOF または FIN で終了します。
この呼び出しは、ストリームがクローズされる前にキューイングされたデータが
送信されることを許します。

</p>
<h3>stream.end(string, encoding)<span><a class="mark" href="#all_stream_end_string_encoding" id="all_stream_end_string_encoding">#</a></span></h3>
<!--
Sends `string` with the given `encoding` and terminates the stream with EOF
or FIN. This is useful to reduce the number of packets sent.
-->

<p>与えられた <code>encoding</code> で <code>string</code> を送信してからEOFまたはFINでストリームを終了します。
これは送信するパケットの数を減らすために便利です。

</p>
<h3>stream.end(buffer)<span><a class="mark" href="#all_stream_end_buffer" id="all_stream_end_buffer">#</a></span></h3>
<!--
Same as above but with a `buffer`.
-->

<p><code>buffer</code> であること以外は上記と同じです。

</p>
<h3>stream.destroy()<span><a class="mark" href="#all_stream_destroy_1" id="all_stream_destroy_1">#</a></span></h3>
<!--
Closes the underlying file descriptor. Stream will not emit any more events.
Any queued write data will not be sent.
-->

<p>下層のファイル記述子をクローズします。ストリームはそれ以上イベントを生成しなくなります。
キューイングされたデータは送信されません。

</p>
<h3>stream.destroySoon()<span><a class="mark" href="#all_stream_destroysoon_1" id="all_stream_destroysoon_1">#</a></span></h3>
<!--
After the write queue is drained, close the file descriptor. `destroySoon()`
can still destroy straight away, as long as there is no data left in the queue
for writes.
-->

<p>出力キューが空になった後、ファイル記述子をクローズします。
出力キューにデータが存在しない場合、<code>destroySoon()</code> はすぐに破棄します。

</p>
<h1>Crypto<span><a class="mark" href="#all_crypto" id="all_crypto">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
Use `require('crypto')` to access this module.
-->

<p>このモジュールにアクセスするには <code>require(&apos;crypto&apos;)</code> を使用します。

</p>
<!--
The crypto module requires OpenSSL to be available on the underlying platform.
It offers a way of encapsulating secure credentials to be used as part
of a secure HTTPS net or http connection.
-->

<p>暗号化モジュールは下層のプラットフォームで OpenSSL が有効であることを必要とします。
それは安全な HTTPS ネットワークや http コネクションの一部として使われる、
安全な認証情報をカプセル化する方法を提供します。

</p>
<!--
It also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.
-->

<p>同時に OpenSSL のハッシュ、HMAC、暗号、復号、署名、そして検証へのラッパーを一式提供します。

</p>
<h2>crypto.createCredentials(details)<span><a class="mark" href="#all_crypto_createcredentials_details" id="all_crypto_createcredentials_details">#</a></span></h2>
<!--
Creates a credentials object, with the optional details being a dictionary with keys:
-->

<p>認証情報オブジェクトを作成します。オプションの <code>details</code> は以下のキーを持つ辞書です:

</p>
<!--
* `key` : a string holding the PEM encoded private key
* `cert` : a string holding the PEM encoded certificate
* `ca` : either a string or list of strings of PEM encoded CA certificates to trust.
* `ciphers`: a string describing the ciphers to use or exclude. Consult
  <http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT> for details
  on the format.
-->

<ul>
<li><code>key</code> : PEM でエンコードされた秘密鍵を保持する文字列</li>
<li><code>cert</code> : PEM でエンコードされた証明書を保持する文字列</li>
<li><code>ca</code> : 信頼できる認証局の証明書が PEM でエンコードされた文字列または文字列の配列</li>
<li><code>ciphers</code>: 使用または除外する暗号を記述した文字列。
詳細は <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
を参照してください。</li>
</ul>
<!--
If no 'ca' details are given, then node.js will use the default publicly trusted list of CAs as given in
<http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt>.
-->

<p>&apos;ca&apos; の詳細が与えられなかった場合、node.js はデフォルトとして
</p>
<p><a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>
で与えられる、信頼できる認証局の公開されたリストを使用します。


</p>
<h2>crypto.createHash(algorithm)<span><a class="mark" href="#all_crypto_createhash_algorithm" id="all_crypto_createhash_algorithm">#</a></span></h2>
<!--
Creates and returns a hash object, a cryptographic hash with the given algorithm
which can be used to generate hash digests.
-->

<p>ハッシュオブジェクトを生成して返します。
与えられたアルゴリズムによる暗号ハッシュ関数はダイジェストの生成に使われます。

</p>
<!--
`algorithm` is dependent on the available algorithms supported by the version
of OpenSSL on the platform. Examples are `'sha1'`, `'md5'`, `'sha256'`, `'sha512'`, etc.
On recent releases, `openssl list-message-digest-algorithms` will display the available digest algorithms.
-->

<p><code>algorithm</code> は、プラットフォーム上の OpenSSL 
のバージョンでサポートされている利用可能なアルゴリズムに依存します。
例えば <code>&apos;sha1&apos;</code>、<code>&apos;md5&apos;</code>、<code>&apos;sha256&apos;</code>、<code>&apos;sha512&apos;</code>、などです。
最近のリリースでは、<code>openssl list-message-digest-algorithms</code>
で利用可能なダイジェストアルゴリズムが表示されます。

</p>
<!--
Example: this program that takes the sha1 sum of a file
-->

<p>例: このプログラムはファイルのsha1ハッシュ値を求めます。

</p>
<pre><code>var filename = process.argv[2];
var crypto = require(&apos;crypto&apos;);
var fs = require(&apos;fs&apos;);

var shasum = crypto.createHash(&apos;sha1&apos;);

var s = fs.ReadStream(filename);
s.on(&apos;data&apos;, function(d) {
  shasum.update(d);
});

s.on(&apos;end&apos;, function() {
  var d = shasum.digest(&apos;hex&apos;);
  console.log(d + &apos;  &apos; + filename);
});</code></pre>
<h2>Class: Hash<span><a class="mark" href="#all_class_hash" id="all_class_hash">#</a></span></h2>
<!--
The class for creating hash digests of data.

Returned by `crypto.createHash`.
-->

<p>データのハッシュダイジェストを生成するクラスです。

</p>
<p><code>crypto.createHash()</code> によって返されます。

</p>
<h3>hash.update(data, [input_encoding])<span><a class="mark" href="#all_hash_update_data_input_encoding" id="all_hash_update_data_input_encoding">#</a></span></h3>
<!--
Updates the hash content with the given `data`, the encoding of which is given
in `input_encoding` and can be `'utf8'`, `'ascii'` or `'binary'`.
Defaults to `'binary'`.
This can be called many times with new data as it is streamed.
-->

<p>与えられた <code>data</code> でハッシュの内容を更新します。
そのエンコーディングは <code>input_encoding</code> で与えられ、<code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>、
または <code>&apos;binary&apos;</code> を指定することができます。
デフォルトは <code>&apos;binary&apos;</code> です。
これは新しいデータがストリームに流される際に何度も呼び出されます。

</p>
<h3>hash.digest([encoding])<span><a class="mark" href="#all_hash_digest_encoding" id="all_hash_digest_encoding">#</a></span></h3>
<!--
Calculates the digest of all of the passed data to be hashed.
The `encoding` can be `'hex'`, `'binary'` or `'base64'`.
Defaults to `'binary'`.

Note: `hash` object can not be used after `digest()` method been called.
-->

<p>渡された全てのデータがハッシュ化されたダイジェストを計算します。
<code>encoding</code> は <code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<p>注意: <code>digest()</code> メソッドを呼び出した後で <code>hash</code> 
オブジェクトを使うことはできません。


</p>
<h2>crypto.createHmac(algorithm, key)<span><a class="mark" href="#all_crypto_createhmac_algorithm_key" id="all_crypto_createhmac_algorithm_key">#</a></span></h2>
<!--
Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key.
-->

<p>与えられたアルゴリズムとキーで HMAC を計算する、HMAC オブジェクトを作成して返します。

</p>
<!--
`algorithm` is dependent on the available algorithms supported by OpenSSL - see createHash above.
`key` is the hmac key to be used.
-->

<p><code>algorithm</code> は OpenSSL でサポートされているアルゴリズムに依存します － 
前述の <code>createHash</code> を参照してください。

</p>
<h2>Class: Hmac<span><a class="mark" href="#all_class_hmac" id="all_class_hmac">#</a></span></h2>
<!--
Class for creating cryptographic hmac content.

Returned by `crypto.createHmac`.
-->

<p>暗号化された HMAC コンテントを生成するためのクラスです。

</p>
<p><code>crypto.createHmac()</code> によって返されます。

</p>
<h3>hmac.update(data)<span><a class="mark" href="#all_hmac_update_data" id="all_hmac_update_data">#</a></span></h3>
<!--
Update the hmac content with the given `data`.
This can be called many times with new data as it is streamed.
-->

<p>与えられた <code>data</code> で HMAC の内容を更新します。
これは新しいデータがストリームに流される際に何度も呼び出されます。

</p>
<h3>hmac.digest([encoding])<span><a class="mark" href="#all_hmac_digest_encoding" id="all_hmac_digest_encoding">#</a></span></h3>
<!--
Calculates the digest of all of the passed data to the hmac.
The `encoding` can be `'hex'`, `'binary'` or `'base64'`.
Defaults to `'binary'`.

Note: `hmac` object can not be used after `digest()` method been called.
-->

<p>渡された全てのデータが HMAC 化されたダイジェストを計算します。
<code>encoding</code> は <code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<p>注意: <code>digest()</code> メソッドを呼び出した後で <code>hmac</code> 
オブジェクトを使うことはできません。


</p>
<h2>crypto.createCipher(algorithm, password)<span><a class="mark" href="#all_crypto_createcipher_algorithm_password" id="all_crypto_createcipher_algorithm_password">#</a></span></h2>
<!--
Creates and returns a cipher object, with the given algorithm and password.

`algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc.
On recent releases, `openssl list-cipher-algorithms` will display the
available cipher algorithms.
`password` is used to derive key and IV, which must be `'binary'` encoded
string (See the [Buffer section](buffer.html) for more information).
-->

<p>与えられたアルゴリズムとパスワードを使用する暗号オブジェクトを作成して返します。
<code>algorithm</code> は、OpenSSL に依存します。例えば <code>&apos;aes192&apos;</code> などです。
最近のリリースでは、<code>openssl list-cipher-algorithms</code>
で利用可能な暗号アルゴリズムが表示されます。
<code>password</code> はキーと IV の生成に使用されます。
これは <code>&apos;binary&apos;</code> でエンコードされた文字列でなければなりません
(より詳細は <a href="buffers.html">Buffers</a> を参照してください)。

</p>
<h2>crypto.createCipheriv(algorithm, key, iv)<span><a class="mark" href="#all_crypto_createcipheriv_algorithm_key_iv" id="all_crypto_createcipheriv_algorithm_key_iv">#</a></span></h2>
<!--
Creates and returns a cipher object, with the given algorithm, key and iv.

`algorithm` is the same as the `createCipher()`. `key` is a raw key used in
algorithm. `iv` is an Initialization vector. `key` and `iv` must be `'binary'`
encoded string (See the [Buffer section](buffer.html) for more information).
-->

<p>与えられたアルゴリズムとキーおよび IV を使用する暗号オブジェクトを作成して返します。
<code>algorithm</code> は <code>createCSipher()</code> と同じです。
<code>key</code> はアルゴリズムで使用される生のキーです。 <code>iv</code> は初期化ベクトルです。
<code>key</code> と <code>iv</code> は <code>&apos;binary&apos;</code> でエンコードされた文字列でなければなりません
(より詳細は <a href="buffers.html">Buffers</a> を参照してください)。

</p>
<h2>Class: Cipher<span><a class="mark" href="#all_class_cipher" id="all_class_cipher">#</a></span></h2>
<!--
Class for encrypting data.

Returned by `crypto.createCipher` and `crypto.createCipheriv`.
-->

<p>データを暗号化するためのクラスです。

</p>
<p><code>crypto.createCipher</code> および <code>crypto.createCipheriv</code> から返されます。

</p>
<h3>cipher.update(data, [input_encoding], [output_encoding])<span><a class="mark" href="#all_cipher_update_data_input_encoding_output_encoding" id="all_cipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<!--
Updates the cipher with `data`, the encoding of which is given in
`input_encoding` and can be `'utf8'`, `'ascii'` or `'binary'`.
Defaults to `'binary'`.

The `output_encoding` specifies the output format of the enciphered data,
and can be `'binary'`, `'base64'` or `'hex'`. Defaults to `'binary'`.
-->

<p><code>data</code> で暗号を更新します。
<code>input_encoding</code> で与えられるエンコーディングは <code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>、<code>&apos;binary&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<p><code>output_encoding</code> は暗号化されたデータの出力フォーマットを指定するもので、
<code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code> または <code>&apos;binary&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<!--
Returns the enciphered contents, and can be called many times with new data as it is streamed.
-->

<p>暗号化されたコンテンツが返されます。これは新しいデータがストリームに流される際に何度も呼び出されます。

</p>
<h3>cipher.final([output_encoding])<span><a class="mark" href="#all_cipher_final_output_encoding" id="all_cipher_final_output_encoding">#</a></span></h3>
<!--
Returns any remaining enciphered contents, with `output_encoding` being one of:
`'binary'`, `'base64'` or `'hex'`. Defaults to `'binary'`.

Note: `cipher` object can not be used after `final()` method been called.
-->

<p>暗号化されたコンテンツの残りを返します。
<code>output_encoding</code> は次のいずれかです: <code>&apos;binary&apos;</code>、<code>&apos;base64&apos;</code> または <code>&apos;hex&apos;</code>。
デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<p>注意: <code>final()</code> メソッドを呼び出した後で <code>cipher</code> 
オブジェクトを使うことはできません。


</p>
<h2>crypto.createDecipher(algorithm, password)<span><a class="mark" href="#all_crypto_createdecipher_algorithm_password" id="all_crypto_createdecipher_algorithm_password">#</a></span></h2>
<!--
Creates and returns a decipher object, with the given algorithm and key.
This is the mirror of the [createCipher()](#crypto.createCipher) above.
-->

<p>与えられたアルゴリズムとパスワードを使用する復号オブジェクトを作成して返します。
これは前述の <a href="#crypto.createCipher">createCipher()</a> の鏡写しです。

</p>
<h2>crypto.createDecipheriv(algorithm, key, iv)<span><a class="mark" href="#all_crypto_createdecipheriv_algorithm_key_iv" id="all_crypto_createdecipheriv_algorithm_key_iv">#</a></span></h2>
<!--
Creates and returns a decipher object, with the given algorithm, key and iv.
This is the mirror of the [createCipheriv()](#crypto.createCipheriv) above.
-->

<p>与えられたアルゴリズムとキー、IV を使用する復号オブジェクトを作成して返します。
これは前述の <a href="#crypto.createCipheriv">createCipheriv()</a> の鏡写しです。

</p>
<h2>Class: Decipher<span><a class="mark" href="#all_class_decipher" id="all_class_decipher">#</a></span></h2>
<!--
Class for decrypting data.

Returned by `crypto.createDecipher` and `crypto.createDecipheriv`.
-->

<p>データを復号化するためのクラスです。

</p>
<p><code>crypto.createDecipher</code> または <code>crypto.createDecipheriv</code> から返されます。

</p>
<h3>decipher.update(data, [input_encoding], [output_encoding])<span><a class="mark" href="#all_decipher_update_data_input_encoding_output_encoding" id="all_decipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<!--
Updates the decipher with `data`, which is encoded in `'binary'`, `'base64'`
or `'hex'`. Defaults to `'binary'`.

The `output_decoding` specifies in what format to return the deciphered
plaintext: `'binary'`, `'ascii'` or `'utf8'`. Defaults to `'binary'`.
-->

<p><code>&apos;binary&apos;</code>、<code>&apos;base64&apos;</code> または <code>&apos;hex&apos;</code> のいずれかでエンコードされた復号を
<code>data</code> で更新します。デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<p><code>output_decoding</code> は復号化されたプレーンテキストのフォーマットを指定するもので、
<code>&apos;binary&apos;</code>、<code>&apos;ascii&apos;</code> あるいは <code>&apos;utf8&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h3>decipher.final([output_encoding])<span><a class="mark" href="#all_decipher_final_output_encoding" id="all_decipher_final_output_encoding">#</a></span></h3>
<!--
Returns any remaining plaintext which is deciphered,
with `output_encoding` being one of: `'binary'`, `'ascii'` or `'utf8'`.
Defaults to `'binary'`.

Note: `decipher` object can not be used after `final()` method been called.
-->

<p>復号化されたプレーンテキストの残りを返します。
<code>output_decoding</code> は <code>&apos;binary&apos;</code>、<code>&apos;ascii&apos;</code> あるいは <code>&apos;utf8&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<p>注意: <code>final()</code> メソッドを呼び出した後で <code>decipher</code> 
オブジェクトを使うことはできません。


</p>
<h2>crypto.createSign(algorithm)<span><a class="mark" href="#all_crypto_createsign_algorithm" id="all_crypto_createsign_algorithm">#</a></span></h2>
<!--
Creates and returns a signing object, with the given algorithm.
On recent OpenSSL releases, `openssl list-public-key-algorithms` will display
the available signing algorithms. Examples are `'RSA-SHA256'`.
-->

<p>与えられたアルゴリズムで署名オブジェクトを作成して返します。
最近のOpenSSLのリリースでは、<code>openssl list-public-key-algorithms</code>
で利用可能な署名アルゴリズムの一覧が表示されます。例えば &apos;RSA-SHA256&apos;。

</p>
<h2>Class: Signer<span><a class="mark" href="#all_class_signer" id="all_class_signer">#</a></span></h2>
<!--
Class for generating signatures.

Returned by `crypto.createSign`.
-->

<p>署名を生成するためのクラスです。

</p>
<p><code>crypto.createSign()</code> から返されます。

</p>
<h3>signer.update(data)<span><a class="mark" href="#all_signer_update_data" id="all_signer_update_data">#</a></span></h3>
<!--
Updates the signer object with data.
This can be called many times with new data as it is streamed.
-->

<p>署名オブジェクトをデータで更新します。
これは新しいデータがストリームに流される際に何度も呼び出されます。


</p>
<h3>signer.sign(private_key, [output_format])<span><a class="mark" href="#all_signer_sign_private_key_output_format" id="all_signer_sign_private_key_output_format">#</a></span></h3>
<!--
Calculates the signature on all the updated data passed through the signer.
`private_key` is a string containing the PEM encoded private key for signing.
-->

<p>署名オブジェクトに渡された全ての更新データで署名を計算します。
<code>private_key</code> は PEM でエンコードされた秘密鍵を内容とする文字列です。

</p>
<!--
Returns the signature in `output_format` which can be `'binary'`, `'hex'` or
`'base64'`. Defaults to `'binary'`.

Note: `signer` object can not be used after `sign()` method been called.
-->

<p><code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、あるいは <code>&apos;base64&apos;</code> のいずれかを指定した <code>output_format</code>
による署名を返します。デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<p>注意: <code>sign()</code> メソッドを呼び出した後で <code>signer</code> 
オブジェクトを使うことはできません。

</p>
<h2>crypto.createVerify(algorithm)<span><a class="mark" href="#all_crypto_createverify_algorithm" id="all_crypto_createverify_algorithm">#</a></span></h2>
<!--
Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.
-->

<p>与えられたアルゴリズムで検証オブジェクトを作成して返します。これは前述の署名オブジェクトと鏡写しです。

</p>
<h2>Class: Verify<span><a class="mark" href="#all_class_verify" id="all_class_verify">#</a></span></h2>
<!--
Class for verifying signatures.

Returned by `crypto.createVerify`.
-->

<p>署名を検証するクラスです。

</p>
<p><code>crypto.createVerify()</code> から返されます。

</p>
<h3>verifier.update(data)<span><a class="mark" href="#all_verifier_update_data" id="all_verifier_update_data">#</a></span></h3>
<!--
Updates the verifier object with data.
This can be called many times with new data as it is streamed.
-->

<p>検証オブジェクトをデータで更新します。
これは新しいデータがストリームに流される際に何度も呼び出されます。


</p>
<h3>verifier.verify(object, signature, [signature_format])<span><a class="mark" href="#all_verifier_verify_object_signature_signature_format" id="all_verifier_verify_object_signature_signature_format">#</a></span></h3>
<!--
Verifies the signed data by using the `object` and `signature`. `object` is  a
string containing a PEM encoded object, which can be one of RSA public key,
DSA public key, or X.509 certificate. `signature` is the previously calculated
signature for the data, in the `signature_format` which can be `'binary'`,
`'hex'` or `'base64'`. Defaults to `'binary'`.
-->

<p>署名されたデータを <code>object</code> と <code>signature</code> で検証します。
<code>object</code> は RSA 公開鍵、DSA 公開鍵、X.509証明書のいずれかを
PEM でエンコードしたオブジェクトです。
<code>signature</code> は先に計算したデータの署名で、
その <code>signature_format</code> は <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code>
のいずれかです。デフォルトは <code>&apos;binary&apos;</code> です。

</p>
<!--
Returns true or false depending on the validity of the signature for the data and public key.

Note: `verifier` object can not be used after `verify()` method been called.
-->

<p>署名されたデータと公開鍵による検証の結果によって true または false を返します。

</p>
<p>注意: <code>verify()</code> メソッドを呼び出した後で <code>verifier</code> 
オブジェクトを使うことはできません。

</p>
<h2>crypto.createDiffieHellman(prime_length)<span><a class="mark" href="#all_crypto_creatediffiehellman_prime_length" id="all_crypto_creatediffiehellman_prime_length">#</a></span></h2>
<!--
Creates a Diffie-Hellman key exchange object and generates a prime of the
given bit length. The generator used is `2`.
-->

<p>ディフィー・ヘルマン鍵共有オブジェクトを作成し、
与えられた長さの素数を生成します。生成元は <code>2</code> です。

</p>
<h2>crypto.createDiffieHellman(prime, [encoding])<span><a class="mark" href="#all_crypto_creatediffiehellman_prime_encoding" id="all_crypto_creatediffiehellman_prime_encoding">#</a></span></h2>
<!--
Creates a Diffie-Hellman key exchange object using the supplied prime. The
generator used is `2`. Encoding can be `'binary'`, `'hex'`, or `'base64'`.
Defaults to `'binary'`.
-->

<p>与えられた素数からディフィー・ヘルマン鍵共有オブジェクトを作成します。
生成元は <code>2</code> です。
エンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h2>Class: DiffieHellman<span><a class="mark" href="#all_class_diffiehellman" id="all_class_diffiehellman">#</a></span></h2>
<!--
The class for creating Diffie-Hellman key exchanges.

Returned by `crypto.createDiffieHellman`.
-->

<p>ディフィー・ヘルマン鍵交換を生成するためのクラスです。

</p>
<p><code>crypto.createDiffieHellman()</code> から返されます。

</p>
<h3>diffieHellman.generateKeys([encoding])<span><a class="mark" href="#all_diffiehellman_generatekeys_encoding" id="all_diffiehellman_generatekeys_encoding">#</a></span></h3>
<!--
Generates private and public Diffie-Hellman key values, and returns the
public key in the specified encoding. This key should be transferred to the
other party. Encoding can be `'binary'`, `'hex'`, or `'base64'`.
Defaults to `'binary'`.
-->

<p>ディフィー・ヘルマン法で秘密および公開鍵を作成し、
指定の方法でエンコーディングされた公開鍵を返します。
この鍵は相手側に渡されるものです。
エンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h3>diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])<span><a class="mark" href="#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding" id="all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">#</a></span></h3>
<!--
Computes the shared secret using `other_public_key` as the other party's
public key and returns the computed shared secret. Supplied key is
interpreted using specified `input_encoding`, and secret is encoded using
specified `output_encoding`. Encodings can be `'binary'`, `'hex'`, or
`'base64'`. The input encoding defaults to `'binary'`.
If no output encoding is given, the input encoding is used as output encoding.
-->

<p><code>other_public_key</code> を相手側の公開鍵として共有の秘密鍵を計算して返します。
与えられた公開鍵は指定の <code>input_encoding</code> を使って解釈され、
秘密鍵は <code>output_encoding</code> で指定された方法でエンコードされます。
エンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
入力エンコーディングのデフォルトは <code>&apos;binary&apos;</code> です。
出力のエンコーディングが与えられなかった場合は、入力のエンコーディングが
出力エンコーディングとして使われます。


</p>
<h3>diffieHellman.getPrime([encoding])<span><a class="mark" href="#all_diffiehellman_getprime_encoding" id="all_diffiehellman_getprime_encoding">#</a></span></h3>
<!--
Returns the Diffie-Hellman prime in the specified encoding, which can be
`'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.
-->

<p>ディフィー・ヘルマン法の素数を指定のエンコーディングで返します。
エンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h3>diffieHellman.getGenerator([encoding])<span><a class="mark" href="#all_diffiehellman_getgenerator_encoding" id="all_diffiehellman_getgenerator_encoding">#</a></span></h3>
<!--
Returns the Diffie-Hellman prime in the specified encoding, which can be
`'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.
-->

<p>ディフィー・ヘルマン法の生成元を指定のエンコーディングで返します。
エンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h3>diffieHellman.getPublicKey([encoding])<span><a class="mark" href="#all_diffiehellman_getpublickey_encoding" id="all_diffiehellman_getpublickey_encoding">#</a></span></h3>
<!--
Returns the Diffie-Hellman public key in the specified encoding, which can
be `'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.
-->

<p>ディフィー・ヘルマン法による公開鍵を指定のエンコーディングで返します。
エンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h3>diffieHellman.getPrivateKey([encoding])<span><a class="mark" href="#all_diffiehellman_getprivatekey_encoding" id="all_diffiehellman_getprivatekey_encoding">#</a></span></h3>
<!--
Returns the Diffie-Hellman private key in the specified encoding, which can
be `'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.
-->

<p>ディフィー・ヘルマン法による秘密鍵を指定のエンコーディングで返します。
エンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h3>diffieHellman.setPublicKey(public_key, [encoding])<span><a class="mark" href="#all_diffiehellman_setpublickey_public_key_encoding" id="all_diffiehellman_setpublickey_public_key_encoding">#</a></span></h3>
<!--
Sets the Diffie-Hellman public key. Key encoding can be `'binary'`, `'hex'`,
or `'base64'`. Defaults to `'binary'`.
-->

<p>ディフィー・ヘルマン法による公開鍵を設定します。
鍵のエンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h3>diffieHellman.setPrivateKey(public_key, [encoding])<span><a class="mark" href="#all_diffiehellman_setprivatekey_public_key_encoding" id="all_diffiehellman_setprivatekey_public_key_encoding">#</a></span></h3>
<!--
Sets the Diffie-Hellman private key. Key encoding can be `'binary'`, `'hex'`,
or `'base64'`. Defaults to `'binary'`.
-->

<p>ディフィー・ヘルマン法による秘密鍵を設定します。
鍵のエンコーディングは <code>&apos;binary&apos;</code>、<code>&apos;hex&apos;</code>、または <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>&apos;binary&apos;</code> です。


</p>
<h2>crypto.pbkdf2(password, salt, iterations, keylen, callback)<span><a class="mark" href="#all_crypto_pbkdf2_password_salt_iterations_keylen_callback" id="all_crypto_pbkdf2_password_salt_iterations_keylen_callback">#</a></span></h2>
<!--
Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive
a key of given length from the given password, salt and iterations.
The callback gets two arguments `(err, derivedKey)`.
-->

<p>疑似乱数を HMAC-SHA1 関数に適用して、与えられたパスワードと salt 
(ランダムなバイト値)、および繰り返しから、指定された長さの鍵を生成する、
非同期の PBKDF2 です。
コールバック関数は二つの引数を受け取る <code>(err, derivedKey)</code> です。


</p>
<h2>crypto.randomBytes(size, [callback])<span><a class="mark" href="#all_crypto_randombytes_size_callback" id="all_crypto_randombytes_size_callback">#</a></span></h2>
<!--
Generates cryptographically strong pseudo-random data. Usage:
-->

<p>暗号学的に強い疑似乱数データを生成します。使用法:

</p>
<pre><code>// async
crypto.randomBytes(256, function(ex, buf) {
  if (ex) throw ex;
  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);
});

// sync
try {
  var buf = crypto.randomBytes(256);
  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);
} catch (ex) {
  // handle error
}</code></pre>
<h1>TLS (SSL)<span><a class="mark" href="#all_tls_ssl" id="all_tls_ssl">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
Use `require('tls')` to access this module.
-->

<p><code>require(&apos;tls&apos;)</code> でこのモジュールにアクセスします。

</p>
<!--
The `tls` module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.
-->

<p><code>tls</code> モジュールは OpenSSL を使用することで Transport Layer Security および
Secure Socket Layer: 暗号化されたストリーム通信を提供します。

</p>
<!--
TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this
-->

<p>TLS/SSL は公開／秘密鍵を基礎とします。
どのクライアントとサーバも秘密鍵が必要です。
秘密鍵は次のように作成します

</p>
<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>
<!--
All severs and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a "Certificate Signing Request" (CSR)
file. This is done with:
-->

<p>全てのサーバと一部のクライアントは証明書を必要とします。
証明書は認証局の公開鍵または自身によって署名されます。
証明書を作成する最初のステップは「証明書署名要求 (CSR)」ファイルです。
次のようにします:

</p>
<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>
<!--
To create a self-signed certificate with the CSR, do this:
-->

<p>CSR から自己署名証明書を作成するには次のようにします:

</p>
<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<!--
Alternatively you can send the CSR to a Certificate Authority for signing.
-->

<p>他に CSR を認証局に送って署名してもらうこともできます。

</p>
<!--
(TODO: docs on creating a CA, for now interested users should just look at
`test/fixtures/keys/Makefile` in the Node source code)
-->

<p>(TODO: CA を作るドキュメント、現在は興味あるユーザは Node のソースコードから
<code>test/fixtures/keys/Makefile</code> を見る必要がある)

</p>
<h2>Client-initiated renegotiation attack mitigation<span><a class="mark" href="#all_client_initiated_renegotiation_attack_mitigation" id="all_client_initiated_renegotiation_attack_mitigation">#</a></span></h2>
<!-- type=misc -->

<!--
The TLS protocol lets the client renegotiate certain aspects of the TLS session.
Unfortunately, session renegotiation requires a disproportional amount of
server-side resources, which makes it a potential vector for denial-of-service
attacks.

To mitigate this, renegotiations are limited to three times every 10 minutes. An
error is emitted on the [CleartextStream](#tls.CleartextStream) instance when
the threshold is exceeded. The limits are configurable:

  - `tls.CLIENT_RENEG_LIMIT`: renegotiation limit, default is 3.

  - `tls.CLIENT_RENEG_WINDOW`: renegotiation window in seconds, default is
                               10 minutes.

Don't change the defaults unless you know what you are doing.

To test your server, connect to it with `openssl s_client -connect address:port`
and tap `R<CR>` (that's the letter `R` followed by a carriage return) a few
times.
-->

<p>TLS では、クライアントから TLS セッションの再ネゴシエーションが可能です。

</p>
<p>残念なことに、セッションの再ネゴシエーションは過度な量のサーバサイドリソースを
要求し、それは潜在的にサービスを強制停止する攻撃となります。

</p>
<p>これを緩和するために、再ネゴシエーションは 10 分あたり 3 回までに
制限されています。この閾値を超えると、<a href="#tls.CleartextStream">CleartextStream</a>
のインスタンスで <code>&apos;error&apos;</code> が生成されます。
この制限はコンフィグレーション可能です:

</p>
<ul>
<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: 再ネゴシエーションの上限、デフォルトは 3 です。</p>
</li>
<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: 再ネゴシエーションのウィンドウサイズ (秒単位)、
デフォルトは 10 分です。</p>
</li>
</ul>
<p>あなたが何をしたいのか理解していない限り、デフォルトを変更しないでください。

</p>
<p>サーバをテストするために、<code>openssl s_client -connect address:port</code> で
接続して <code>R&lt;CR&gt;</code> (これは <code>R</code> の後に復帰改行を続けます)
を、数回試すことができます。

</p>
<h2>NPN and SNI<span><a class="mark" href="#all_npn_and_sni" id="all_npn_and_sni">#</a></span></h2>
<!-- type=misc -->

<!--
NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS
handshake extensions allowing you:
-->

<p>NPN (Next Protocol Negotitation) と SNI (Server Name Indication) は
TLS の拡張で、以下を可能にします。

</p>
<!--
  * NPN - to use one TLS server for multiple protocols (HTTP, SPDY)
  * SNI - to use one TLS server for multiple hostnames with different SSL
    certificates.
-->

<ul>
<li>NPN - 一つの TLS サーバで複数のプロトコル (HTTP、SPDY) を使用。</li>
<li>SNI - 一つの TLS サーバでホスト名の異なる複数の証明書を使用。</li>
</ul>
<h2>tls.createServer(options, [secureConnectionListener])<span><a class="mark" href="#all_tls_createserver_options_secureconnectionlistener" id="all_tls_createserver_options_secureconnectionlistener">#</a></span></h2>
<!--
Creates a new [tls.Server](#tls.Server).
The `connectionListener` argument is automatically set as a listener for the
[secureConnection](#event_secureConnection_) event.
The `options` object has these possibilities:
-->

<p>新しい <a href="#tls.Server">tls.Server</a> を作成します。
<code>connectionListener</code> は <a href="#event_secureConnection_">secureConnection</a>
イベントのリスナとして自動的に登録されます。
<code>options</code> は以下を持つことができます:


</p>
<!--
  - `key`: A string or `Buffer` containing the private key of the server in
    PEM format. (Required)

  - `passphrase`: A string of passphrase for the private key.

  - `cert`: A string or `Buffer` containing the certificate key of the server in
    PEM format. (Required)

  - `ca`: An array of strings or `Buffer`s of trusted certificates. If this is
    omitted several well known "root" CAs will be used, like VeriSign.
    These are used to authorize connections.

  - `ciphers`: A string describing the ciphers to use or exclude. Consult
    <http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT> for
    details on the format.

  - `requestCert`: If `true` the server will request a certificate from
    clients that connect and attempt to verify that certificate. Default:
    `false`.

  - `rejectUnauthorized`: If `true` the server will reject any connection
    which is not authorized with the list of supplied CAs. This option only
    has an effect if `requestCert` is `true`. Default: `false`.

  - `NPNProtocols`: An array or `Buffer` of possible NPN protocols. (Protocols
    should be ordered by their priority).

  - `SNICallback`: A function that will be called if client supports SNI TLS
    extension. Only one argument will be passed to it: `servername`. And
    `SNICallback` should return SecureContext instance.
    (You can use `crypto.createCredentials(...).context` to get proper
    SecureContext). If `SNICallback` wasn't provided - default callback with
    high-level API will be used (see below).

  - `sessionIdContext`: A string containing a opaque identifier for session
    resumption. If `requestCert` is `true`, the default is MD5 hash value
    generated from command-line. Otherwise, the default is not provided.
-->

<ul>
<li><p><code>key</code>: PEM フォーマットによるサーバの秘密鍵を持つ文字列または <code>Buffer</code> です
(必須)。</p>
</li>
<li><p><code>passphrase</code>: 秘密鍵のパスフレーズを表す文字列です。</p>
</li>
<li><p><code>cert</code>: PEM フォーマットによる証明書の鍵を持つ文字列または <code>Buffer</code> です
(必須)。</p>
</li>
<li><p><code>ca</code>: 信頼できる証明書の文字列または <code>Buffer</code> の配列です。
省略された場合、ベリサインなどのよく知られた「ルート」認証局が使われます。
これらはコネクションの認証に使われます。</p>
</li>
<li><p><code>ciphers</code>: 使用または除外する暗号を記述した文字列。
詳細は <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
を参照してください。</p>
</li>
<li><p><code>requestCert</code>: <code>true</code> の場合、サーバは接続しようとするクライアントからの
証明書を要求します。デフォルトは <code>false</code> です。</p>
</li>
<li><p><code>rejectUnauthorized</code>: <code>true</code> の場合、サーバは提供された認証局の
リストによって認証されていないコネクションを破棄します．
このオプションは <code>requestCert</code> が <code>true</code> の場合だけ効果があります。
デフォルトは <code>false</code> です。</p>
</li>
<li><p><code>NPNProtocols</code>: NPN プロトコルで使用可能な文字列または <code>Buffer</code> の配列
(プロトコルはその優先度に応じて並んでいる必要があります)。</p>
</li>
<li><p><code>SNICallback</code>: クライアントが TLS 拡張の SNI をサポートしている場合に
呼び出される関数です。
<code>servername</code> が唯一の引数として渡されます。
<code>SNICallback</code> は SecureContext のインスタンスを返す必要があります
(SecureContext を取得するために <code>crypto.createCredentials(...).context</code>
を使用することができます)。
<code>SNICallback</code> が渡されなかった場合は、デフォルトのコールバックとして
後述する高水準 API が使用されます。</p>
</li>
<li><p><code>sessionIdContext</code>: セッション再開のための識別子となる文字列です。
<code>requestCedrt</code> が <code>true</code> の場合、デフォルトはコマンドライン引数から
生成された MD5 ハッシュ値となります。
そうでない場合はデフォルトは提供されません。</p>
</li>
</ul>
<!--
Here is a simple example echo server:


    var tls = require('tls');
    var fs = require('fs');

    var options = {
      key: fs.readFileSync('server-key.pem'),
      cert: fs.readFileSync('server-cert.pem'),

      // This is necessary only if using the client certificate authentication.
      requestCert: true,

      // This is necessary only if the client uses the self-signed certificate.
      ca: [ fs.readFileSync('client-cert.pem') ]
    };

    var server = tls.createServer(options, function(cleartextStream) {
      console.log('server connected',
                  cleartextStream.authorized ? 'authorized' : 'unauthorized');
      cleartextStream.write("welcome!\n");
      cleartextStream.setEncoding('utf8');
      cleartextStream.pipe(cleartextStream);
    });
    server.listen(8000, function() {
      console.log('server bound');
    });
-->

<p>これはシンプルはエコーサーバの例です:


</p>
<pre><code>var tls = require(&apos;tls&apos;);
var fs = require(&apos;fs&apos;);

var options = {
  key: fs.readFileSync(&apos;server-key.pem&apos;),
  cert: fs.readFileSync(&apos;server-cert.pem&apos;),

  // これはクライアント証明書を用いた認証を行う場合だけ必要です
  requestCert: true,

  // これは自己署名のクライアント証明書を認証する場合だけ必要です
  ca: [ fs.readFileSync(&apos;client-cert.pem&apos;) ]
};

var server = tls.createServer(options, function(cleartextStream) {
  console.log(&apos;server connected&apos;,
              cleartextStream.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  cleartextStream.write(&quot;welcome!\n&quot;);
  cleartextStream.setEncoding(&apos;utf8&apos;);
  cleartextStream.pipe(cleartextStream);
});
server.listen(8000, function() {
  console.log(&apos;server bound&apos;);
});</code></pre>
<!--
You can test this server by connecting to it with `openssl s_client`:
-->

<p><code>openssl s_client</code> を使用してこのサーバに接続するテストを行うことができます。


</p>
<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
<h2>tls.connect(port, [host], [options], [secureConnectListener])<span><a class="mark" href="#all_tls_connect_port_host_options_secureconnectlistener" id="all_tls_connect_port_host_options_secureconnectlistener">#</a></span></h2>
<!--
Creates a new client connection to the given `port` and `host`. (If `host`
defaults to `localhost`.) `options` should be an object which specifies
-->

<p>与えられた <code>port</code> と <code>host</code> で新しいクライアントコネクションを作成します
(<code>host</code> のデフォルトは <code>localhost</code> です)。
<code>options</code> は以下を指定したオブジェクトです。

</p>
<!--
  - `key`: A string or `Buffer` containing the private key of the client in
    PEM format.

  - `passphrase`: A string of passphrase for the private key.

  - `cert`: A string or `Buffer` containing the certificate key of the client in
    PEM format.

  - `ca`: An array of strings or `Buffer`s of trusted certificates. If this is
    omitted several well known "root" CAs will be used, like VeriSign.
    These are used to authorize connections.

  - `NPNProtocols`: An array of string or `Buffer` containing supported NPN
    protocols. `Buffer` should have following format: `0x05hello0x05world`,
    where first byte is next protocol name's length. (Passing array should
    usually be much simpler: `['hello', 'world']`.)

  - `servername`: Servername for SNI (Server Name Indication) TLS extension.

  - `socket`: Establish secure connection on a given socket rather than
    creating a new socket. If this option is specified, `host` and `port`
    are ignored.  This is intended FOR INTERNAL USE ONLY.  As with all
    undocumented APIs in Node, they should not be used.
-->

<ul>
<li><p><code>key</code>: PEM フォーマットによるサーバの秘密鍵を持つ文字列または
<code>Buffer</code> です。</p>
</li>
<li><p><code>passphrase</code>: 秘密鍵のパスフレーズを表す文字列です。</p>
</li>
<li><p><code>cert</code>: PEM フォーマットによる証明書の鍵を持つ文字列または <code>Buffer</code> です。</p>
</li>
<li><p><code>ca</code>: 信頼できる証明書の文字列または <code>Buffer</code> の配列です。
省略された場合、ベリサインなどのよく知られた「ルート」認証局が使われます。
これらはコネクションの認証に使われます。</p>
</li>
<li><p><code>NPNProtocols</code>: サポートする NPN プロトコルの文字列または <code>Buffer</code> 
の配列です。
<code>Buffer</code> は次のような形式です: <code>0x05hello0x5world</code>
最初のバイトは次のプロトコル名の長さです
(通常、配列を渡す方がシンプルです: <code>[&apos;hello&apos;, &apos;world&apos;]</code>)。</p>
</li>
<li><p><code>servername</code>: TLS 拡張である SNI (Server Name Indication) のサーバ名です。</p>
</li>
<li><p><code>socket</code>: 新しいソケットを生成するのではなく、与えられたソケット上で
セキュアな接続を確立します。
このオプションが指定された場合、<code>host</code> および <code>port</code> は無視されます。
これは内部的な利用のみを意図しています。他のアンドキュメンテッドな
API と同様、これを使用すべきではありません。</p>
</li>
</ul>
<!--
The `secureConnectListener` parameter will be added as a listener for the
['secureConnect'](#event_secureConnect_) event.

`tls.connect()` returns a [CleartextStream](#tls.CleartextStream) object.

Here is an example of a client of echo server as described previously:

    var tls = require('tls');
    var fs = require('fs');

    var options = {
      // These are necessary only if using the client certificate authentication
      key: fs.readFileSync('client-key.pem'),
      cert: fs.readFileSync('client-cert.pem'),

      // This is necessary only if the server uses the self-signed certificate
      ca: [ fs.readFileSync('server-cert.pem') ]
    };

    var cleartextStream = tls.connect(8000, options, function() {
      console.log('client connected',
                  cleartextStream.authorized ? 'authorized' : 'unauthorized');
      process.stdin.pipe(cleartextStream);
      process.stdin.resume();
    });
    cleartextStream.setEncoding('utf8');
    cleartextStream.on('data', function(data) {
      console.log(data);
    });
    cleartextStream.on('end', function() {
      server.close();
    });
-->

<p><code>secureConnectLister</code> 引数は <a href="#event_secureConnect_">&apos;secureConnect&apos;</a>
イベントのリスナとして加えられます。

</p>
<p><code>tls.connect()</code> は <a href="#tls.CleartextStream">CleartextStream</a>
オブジェクトを返します。

</p>
<p>これは前述のエコーサーバに接続するクライアントの例です:

</p>
<pre><code>var tls = require(&apos;tls&apos;);
var fs = require(&apos;fs&apos;);

var options = {
  // これらはクライアント証明書による認証を行う場合だけ必要ですn
  key: fs.readFileSync(&apos;client-key.pem&apos;),
  cert: fs.readFileSync(&apos;client-cert.pem&apos;),

  // これはサーバが自己署名証明書を使う場合だけ必要です
  ca: [ fs.readFileSync(&apos;server-cert.pem&apos;) ]
};

var cleartextStream = tls.connect(8000, options, function() {
  console.log(&apos;client connected&apos;,
              cleartextStream.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  process.stdin.pipe(cleartextStream);
  process.stdin.resume();
});
cleartextStream.setEncoding(&apos;utf8&apos;);
cleartextStream.on(&apos;data&apos;, function(data) {
  console.log(data);
});
cleartextStream.on(&apos;end&apos;, function() {
  server.close();
});</code></pre>
<h2>tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])<span><a class="mark" href="#all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized" id="all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">#</a></span></h2>
<!--
Creates a new secure pair object with two streams, one of which reads/writes
encrypted data, and one reads/writes cleartext data.
Generally the encrypted one is piped to/from an incoming encrypted data stream,
and the cleartext one is used as a replacement for the initial encrypted stream.
 - `credentials`: A credentials object from crypto.createCredentials( ... )

 - `isServer`: A boolean indicating whether this tls connection should be
   opened as a server or a client.

 - `requestCert`: A boolean indicating whether a server should request a
   certificate from a connecting client. Only applies to server connections.

 - `rejectUnauthorized`: A boolean indicating whether a server should
   automatically reject clients with invalid certificates. Only applies to
   servers with `requestCert` enabled.

`tls.createSecurePair()` returns a SecurePair object with
[cleartext](#tls.CleartextStream) and `encrypted` stream properties.
-->

<p>二つのストリームを持つセキュアペアオブジェクトを作成します。
一つは暗号化されたデータを読み書きし、もう一つは平文のデータを読み書きします。
通常、暗号化されたストリームに外部からの暗号化されたデータが連結され、
暗号化されたストリームの代わりに平文のストリームが使われます。

</p>
<ul>
<li><p><code>credentials</code>: <code>crypto.createCredentials( ... )</code> で作成された
証明書オブジェクト。</p>
</li>
<li><p><code>isServer</code>: この TLS コネクションをサーバとしてオープンするかどうかを示す
ブーリアン値。</p>
</li>
<li><p><code>requestCert</code>: クライアントからの接続に対して、サーバがクライアントに
証明書を要求するかどうかを示すブーリアン値。
サーバコネクションにのみ適用されます。</p>
</li>
<li><p><code>rejectUnauthorized</code>: クライアント認証が不正だった場合に、
自動的にクライアントを破棄するかどうかを示すブーリアン値。
<code>requestCert</code> が有効なサーバにのみ適用されます。</p>
</li>
</ul>
<p><code>tls.createSequrePair()</code> は、<a href="#tls.CleartextStream">cleartext</a> と <code>encrypted</code>
をプロパティとして持つ <code>SecurePair</code> オブジェクトを返します。

</p>
<h2>Class: SecurePair<span><a class="mark" href="#all_class_securepair" id="all_class_securepair">#</a></span></h2>
<p>Returned by tls.createSecurePair.

</p>
<h3>Event: &apos;secure&apos;<span><a class="mark" href="#all_event_secure" id="all_event_secure">#</a></span></h3>
<!--
The event is emitted from the SecurePair once the pair has successfully
established a secure connection.

Similarly to the checking for the server 'secureConnection' event,
pair.cleartext.authorized should be checked to confirm whether the certificate
used properly authorized.
-->

<p>SecurePair オブジェクトのペアが安全な接続を確立した場合に発生します。

</p>
<p>サーバの <code>&apos;secureConnection&apos;</code> イベントと同様に、
<code>pari.cleartext.authorized</code> によって接続相手の証明書を承認できたかどうかを
チェックすることができます。

</p>
<h2>Class: tls.Server<span><a class="mark" href="#all_class_tls_server" id="all_class_tls_server">#</a></span></h2>
<!--
This class is a subclass of `net.Server` and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.
-->

<p>このクラスは <code>net.Server</code> のサブクラスで、同じメソッドを持っています。
生の TCP コネクションを受け入れる代わりに、
TLS または SSL を使った暗号化されたコネクションを受け付けます。


</p>
<h3>Event: &apos;secureConnection&apos;<span><a class="mark" href="#all_event_secureconnection" id="all_event_secureconnection">#</a></span></h3>
<p><code>function (cleartextStream) {}</code>

</p>
<!--
This event is emitted after a new connection has been successfully
handshaked. The argument is a instance of
[CleartextStream](#tls.CleartextStream). It has all the common stream methods
and events.
-->

<p>このイベントは、新しい接続のハンドシェークが成功した場合に生成されます。
引数は <a href="#tls.CleartextStream">CleartextStream</a> のインスタンスです。
これはストリームに共通する全てのメソッドとイベントを持っています。

</p>
<!--
`cleartextStream.authorized` is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If `cleartextStream.authorized` is false, then
`cleartextStream.authorizationError` is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.
`cleartextStream.npnProtocol` is a string containing selected NPN protocol.
`cleartextStream.servername` is a string containing servername requested with
SNI.
-->

<p><code>cleartextStream.authorized</code> は提供された認証局のいずれかによって認証されたかを示す boolean 値です。
<code>cleartextStream.authorized</code> が false の場合、
<code>cleartextStream.authorizationError</code> にはどのように認証が失敗したのかが設定されます。
暗黙的ですが言及する価値のあること:
TLS サーバの設定に依存しますが、認証されていないコネクションも受け入れられることがあります。
<code>cleartextStream.npnProtocol</code> は、選択された NPN プロトコルを持つ文字列です。
<code>cleartextStream.servername</code> は、SNI でリクエストされたサーバ名を持つ
文字列です。

</p>
<h3>Event: &apos;clientError&apos;<span><a class="mark" href="#all_event_clienterror" id="all_event_clienterror">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<!--
When a client connection emits an 'error' event before secure connection is
established - it will be forwarded here.
-->

<p>セキュアコネクションが確立される前にクライアントコネクションが
<code>&apos;error&apos;</code> イベントを発した場合 － ここに転送されます。


</p>
<h3>server.listen(port, [host], [callback])<span><a class="mark" href="#all_server_listen_port_host_callback" id="all_server_listen_port_host_callback">#</a></span></h3>
<!--
Begin accepting connections on the specified `port` and `host`.  If the
`host` is omitted, the server will accept connections directed to any
IPv4 address (`INADDR_ANY`).
-->

<p>指定の <code>port</code> と <code>host</code> で接続の受け入れを開始します。
<code>host</code> が省略されると、サーバはどんな IPv4 アドレスからのコネクションも受け入れます (<code>INADDR_ANY</code>)。

</p>
<!--
This function is asynchronous. The last parameter `callback` will be called
when the server has been bound.
-->

<p>この関数は非同期です。
最後の引数 <code>callback</code> はサーバがバインドされると呼び出されます。

</p>
<!--
See `net.Server` for more information.
-->

<p>より詳細は <code>net.Server</code> を参照してください。


</p>
<h3>server.close()<span><a class="mark" href="#all_server_close" id="all_server_close">#</a></span></h3>
<!--
Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a `'close'`
event.
-->

<p>サーバが新しい接続を受け入れることを終了します。
この関数は非同期で、サーバが最終的にクローズされるとサーバは <code>&apos;close&apos;</code> イベントを生成します。

</p>
<h3>server.address()<span><a class="mark" href="#all_server_address" id="all_server_address">#</a></span></h3>
<!--
Returns the bound address and port of the server as reported by the operating
system.
See [net.Server.address()](net.html#server.address) for more information.
-->

<p>オペレーティングシステムから報告された、
サーバにバインドされたアドレスとポートを返します。 
より詳しくは <a href="net.html#server.address">net.Server.address()</a>
を参照してください。

</p>
<h3>server.addContext(hostname, credentials)<span><a class="mark" href="#all_server_addcontext_hostname_credentials" id="all_server_addcontext_hostname_credentials">#</a></span></h3>
<!--
Add secure context that will be used if client request's SNI hostname is
matching passed `hostname` (wildcards can be used). `credentials` can contain
`key`, `cert` and `ca`.
-->

<p>クライアントが要求してきた SNI ホスト名と <code>hostname</code> (ワイルドカードを使用可能)
がマッチした場合のセキュリティコンテキストを追加します。
<code>credentials</code> は <code>key</code>、<code>cert</code>、そして <code>ca</code> を含むことができます。

</p>
<h3>server.maxConnections<span><a class="mark" href="#all_server_maxconnections" id="all_server_maxconnections">#</a></span></h3>
<!--
Set this property to reject connections when the server's connection count
gets high.
-->

<p>このプロパティを設定すると、サーバの接続数がこれを越えた場合に接続を破棄します。

</p>
<h3>server.connections<span><a class="mark" href="#all_server_connections" id="all_server_connections">#</a></span></h3>
<!--
The number of concurrent connections on the server.
-->

<p>サーバの並行コネクションの数です。

</p>
<h2>Class: tls.CleartextStream<span><a class="mark" href="#all_class_tls_cleartextstream" id="all_class_tls_cleartextstream">#</a></span></h2>
<!--
This is a stream on top of the *Encrypted* stream that makes it possible to
read/write an encrypted data as a cleartext data.

This instance implements a duplex [Stream](stream.html) interfaces.
It has all the common stream methods and events.

A ClearTextStream is the `clear` member of a SecurePair object.
-->

<p>暗号化されたストリーム上で、暗号化されたデータを平文のデータとして
読み書きすることができるストリームです。

</p>
<p>このインスタンスは双方向の <a href="stream.html#streams">Stream</a> インタフェースを
実装します。
ストリームに共通な全てのメソッドとイベントを持ちます。

</p>
<p>ClearText ストリームは SecurePair オブジェクトの <code>clear</code> メンバです。

</p>
<h3>Event: &apos;secureConnect&apos;<span><a class="mark" href="#all_event_secureconnect" id="all_event_secureconnect">#</a></span></h3>
<!--
This event is emitted after a new connection has been successfully handshaked. 
The listener will be called no matter if the server's certificate was
authorized or not. It is up to the user to test `cleartextStream.authorized`
to see if the server certificate was signed by one of the specified CAs.
If `cleartextStream.authorized === false` then the error can be found in
`cleartextStream.authorizationError`. Also if NPN was used - you can check
`cleartextStream.npnProtocol` for negotiated protocol.
-->

<p>新しいコネクションの TLS/SSL ハンドシェークが成功すると生成されます。
リスナはサーバの証明書が認証されたかどうかに関わらず呼び出されます。
サーバ証明書が指定した認証局に承認されたかチェックするために
<code>cleartextStream.authorized</code> を確認するかはユーザ次第です。
<code>cleartextStream.authorized === false</code>の場合、
<code>cleartextStream.authorizationError</code> からエラーを見つけることができます。
同様に NPN が使われている場合は <code>cleartextStream.npnProtocol</code>
から合意されたプロトコルをチェックすることが出来ます。


</p>
<h3>cleartextStream.authorized<span><a class="mark" href="#all_cleartextstream_authorized" id="all_cleartextstream_authorized">#</a></span></h3>
<!--
A boolean that is `true` if the peer certificate was signed by one of the
specified CAs, otherwise `false`
-->

<p>接続相手の証明書が CA の一つによって署名されていれば <code>true</code>、
そうでなければ <code>false</code> です。

</p>
<h3>cleartextStream.authorizationError<span><a class="mark" href="#all_cleartextstream_authorizationerror" id="all_cleartextstream_authorizationerror">#</a></span></h3>
<!--
The reason why the peer's certificate has not been verified. This property
becomes available only when `cleartextStream.authorized === false`.
-->

<p>接続相手の証明書が認証されなかった理由です。
このプロパティは <code>cleartextStream.authorized === false</code>
の場合だけ利用可能になります。

</p>
<h3>cleartextStream.getPeerCertificate()<span><a class="mark" href="#all_cleartextstream_getpeercertificate" id="all_cleartextstream_getpeercertificate">#</a></span></h3>
<!--
Returns an object representing the peer's certificate. The returned object has
some properties corresponding to the field of the certificate.
-->

<p>接続相手の証明書を表現するオブジェクトを返します。
返されるオブジェクトは証明書のフィールドに対応するプロパティを持ちます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>{ subject: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  issuer: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  valid_from: &apos;Nov 11 09:52:22 2009 GMT&apos;,
  valid_to: &apos;Nov  6 09:52:22 2029 GMT&apos;,
  fingerprint: &apos;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&apos; }</code></pre>
<!--
If the peer does not provide a certificate, it returns `null` or an empty
object.
-->

<p>接続相手が証明書を提供しなかった場合は、
<code>null</code> または空のオブジェクトを返します。

</p>
<h3>cleartextStream.address()<span><a class="mark" href="#all_cleartextstream_address" id="all_cleartextstream_address">#</a></span></h3>
<!--
Returns the bound address and port of the underlying socket as reported by the
operating system. Returns an object with two properties, e.g.
`{"address":"192.168.57.1", "port":62053}`
-->

<p>オペレーティングシステムから報告された、
ソケットにバインドされたアドレスとポートを返します。
返されるオブジェクトは二つのプロパティを持ちます。
例えば、<code>{&quot;address&quot;:&quot;192.168.57.1&quot;, &quot;port&quot;:62053}</code>

</p>
<h3>cleartextStream.remoteAddress<span><a class="mark" href="#all_cleartextstream_remoteaddress" id="all_cleartextstream_remoteaddress">#</a></span></h3>
<!--
The string representation of the remote IP address. For example,
`'74.125.127.100'` or `'2001:4860:a005::68'`.
-->

<p>リモートの IP アドレスを表現する文字列です。
例えば、<code>&apos;74.125.127.100&apos;</code> あるいは <code>&apos;2001:4860:a005::68&apos;</code>。

</p>
<h3>cleartextStream.remotePort<span><a class="mark" href="#all_cleartextstream_remoteport" id="all_cleartextstream_remoteport">#</a></span></h3>
<!--
The numeric representation of the remote port. For example, `443`.
-->

<p>リモートポートの数値表現です。
例えば、<code>443</code>。


</p>
<h1>File System<span><a class="mark" href="#all_file_system" id="all_file_system">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--name=fs-->

<!--
File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do `require('fs')`. All the methods have asynchronous and
synchronous forms.
-->

<p>File I/O は POSIX 標準の関数に対する単純なラッパーとして提供されます。
このモジュールを使用するには <code>require(&apos;fs&apos;)</code> してください。
全てのメソッドは非同期と同期の形式があります。

</p>
<!--
The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be `null` or `undefined`.

When using the synchronous form any exceptions are immediately thrown.
You can use try/catch to handle exceptions or allow them to bubble up.
-->

<p>非同期の形式は常に最後の引数として完了コールバックを受け取ります。
引数として渡される完了コールバックはメソッドに依存しますが、
最初の引数は常に例外のために予約されています。
操作が成功で完了すると最初の引数は <code>null</code> または <code>undefined</code> となります

</p>
<p>同期の形式では、全ての例外はすぐにスローされます。
例外は try/catch で捕まえることも、そのまま通過させることもできます。

</p>
<!--
Here is an example of the asynchronous version:
-->

<p>非同期バージョンの例です:

</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.unlink(&apos;/tmp/hello&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;successfully deleted /tmp/hello&apos;);
});</code></pre>
<!--
Here is the synchronous version:
-->

<p>同期バージョンです:

</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.unlinkSync(&apos;/tmp/hello&apos;)
console.log(&apos;successfully deleted /tmp/hello&apos;);</code></pre>
<!--
With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:
-->

<p>非同期メソッドでは順序の保証はありません。
以下のような傾向のエラーがあります。

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;renamed complete&apos;);
});
fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
  if (err) throw err;
  console.log(&apos;stats: &apos; + JSON.stringify(stats));
});</code></pre>
<!--
It could be that `fs.stat` is executed before `fs.rename`.
The correct way to do this is to chain the callbacks.
-->

<p><code>fs.stat</code> は <code>fs.rename</code> より先に実行される可能性がありrます。
正しい方法はコールバックをチェーンすることです。

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
    if (err) throw err;
    console.log(&apos;stats: &apos; + JSON.stringify(stats));
  });
});</code></pre>
<!--
In busy processes, the programmer is _strongly encouraged_ to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.

Relative path to filename can be used, remember however that this path will be relative
to `process.cwd()`.
-->

<p>忙しいプロセスでは、プログラマはこれらの非同期バージョンを使うことが<em>強く推奨</em>されます。
同期バージョンはそれが完了するまでプロセス全体をブロックします － 全ての接続を停止します。

</p>
<p>ファイル名には相対パスを使うことが出来ます。しかし、このパスは
<code>process.cwd()</code> からの相対パスであることを思い出してください。

</p>
<h2>fs.rename(path1, path2, [callback])<span><a class="mark" href="#all_fs_rename_path1_path2_callback" id="all_fs_rename_path1_path2_callback">#</a></span></h2>
<!--
Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の rename(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.renameSync(path1, path2)<span><a class="mark" href="#all_fs_renamesync_path1_path2" id="all_fs_renamesync_path1_path2">#</a></span></h2>
<!--
Synchronous rename(2).
-->

<p>同期の rename(2)。

</p>
<h2>fs.truncate(fd, len, [callback])<span><a class="mark" href="#all_fs_truncate_fd_len_callback" id="all_fs_truncate_fd_len_callback">#</a></span></h2>
<!--
Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.
-->

<p>非同期の ftruncate(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.truncateSync(fd, len)<span><a class="mark" href="#all_fs_truncatesync_fd_len" id="all_fs_truncatesync_fd_len">#</a></span></h2>
<!--
Synchronous ftruncate(2).
-->

<p>同期の ftruncate(2)。

</p>
<h2>fs.chown(path, uid, gid, [callback])<span><a class="mark" href="#all_fs_chown_path_uid_gid_callback" id="all_fs_chown_path_uid_gid_callback">#</a></span></h2>
<!--
Asynchronous chown(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の chown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.chownSync(path, uid, gid)<span><a class="mark" href="#all_fs_chownsync_path_uid_gid" id="all_fs_chownsync_path_uid_gid">#</a></span></h2>
<!--
Synchronous chown(2).
-->

<p>同期の chown(2)。

</p>
<h2>fs.fchown(fd, uid, gid, [callback])<span><a class="mark" href="#all_fs_fchown_fd_uid_gid_callback" id="all_fs_fchown_fd_uid_gid_callback">#</a></span></h2>
<!--
Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の fchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.fchownSync(fd, uid, gid)<span><a class="mark" href="#all_fs_fchownsync_fd_uid_gid" id="all_fs_fchownsync_fd_uid_gid">#</a></span></h2>
<!--
Synchronous fchown(2).
-->

<p>同期の fchown(2)。

</p>
<h2>fs.lchown(path, uid, gid, [callback])<span><a class="mark" href="#all_fs_lchown_path_uid_gid_callback" id="all_fs_lchown_path_uid_gid_callback">#</a></span></h2>
<!--
Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の lchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.lchownSync(path, uid, gid)<span><a class="mark" href="#all_fs_lchownsync_path_uid_gid" id="all_fs_lchownsync_path_uid_gid">#</a></span></h2>
<!--
Synchronous lchown(2).
-->

<p>同期の lchown(2)。

</p>
<h2>fs.chmod(path, mode, [callback])<span><a class="mark" href="#all_fs_chmod_path_mode_callback" id="all_fs_chmod_path_mode_callback">#</a></span></h2>
<!--
Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の chmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.chmodSync(path, mode)<span><a class="mark" href="#all_fs_chmodsync_path_mode" id="all_fs_chmodsync_path_mode">#</a></span></h2>
<!--
Synchronous chmod(2).
-->

<p>同期の chmod(2)。

</p>
<h2>fs.fchmod(fd, mode, [callback])<span><a class="mark" href="#all_fs_fchmod_fd_mode_callback" id="all_fs_fchmod_fd_mode_callback">#</a></span></h2>
<!--
Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.
-->

<p>非同期の fchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.fchmodSync(fd, mode)<span><a class="mark" href="#all_fs_fchmodsync_fd_mode" id="all_fs_fchmodsync_fd_mode">#</a></span></h2>
<!--
Synchronous fchmod(2).
-->

<p>同期の fchmod(2)。

</p>
<h2>fs.lchmod(path, mode, [callback])<span><a class="mark" href="#all_fs_lchmod_path_mode_callback" id="all_fs_lchmod_path_mode_callback">#</a></span></h2>
<!--
Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.
-->

<p>非同期の lchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.lchmodSync(path, mode)<span><a class="mark" href="#all_fs_lchmodsync_path_mode" id="all_fs_lchmodsync_path_mode">#</a></span></h2>
<!--
Synchronous lchmod(2).
-->

<p>同期の lchmod(2)。

</p>
<h2>fs.stat(path, [callback])<span><a class="mark" href="#all_fs_stat_path_callback" id="all_fs_stat_path_callback">#</a></span></h2>
<!--
Asynchronous stat(2). The callback gets two arguments `(err, stats)` where
`stats` is a [fs.Stats](#fs_class_fs_stats) object.  See the [fs.Stats](#fs_class_fs_stats)
section below for more information.
-->

<p>非同期の stat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <a href="#fs.Stats">fs.Stats</a> オブジェクトです。
詳細は <a href="#fs.Stats">fs.Stats</a> の節を参照してください。

</p>
<h2>fs.lstat(path, [callback])<span><a class="mark" href="#all_fs_lstat_path_callback" id="all_fs_lstat_path_callback">#</a></span></h2>
<!--
Asynchronous lstat(2). The callback gets two arguments `(err, stats)` where
`stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if
`path` is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.
-->

<p>非同期の lstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。
<code>lstat()</code> はパスがシンボリックリンクだった場合に、
参照先のファイルではなくそのリンク自身が調べられる点を除いて <code>stat()</code> と同じす。
</p>
<h2>fs.fstat(fd, [callback])<span><a class="mark" href="#all_fs_fstat_fd_callback" id="all_fs_fstat_fd_callback">#</a></span></h2>
<!--
Asynchronous fstat(2). The callback gets two arguments `(err, stats)` where
`stats` is a `fs.Stats` object. `fstat()` is identical to `stat()`, except that
the file to be stat-ed is specified by the file descriptor `fd`.
-->

<p>非同期の fstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code> で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。
状態を取得するファイルをファイル記述子 <code>fd</code> で指定することを除いて、
<code>fstat()</code> は <code>stat()</code> と同じです。

</p>
<h2>fs.statSync(path)<span><a class="mark" href="#all_fs_statsync_path" id="all_fs_statsync_path">#</a></span></h2>
<!--
Synchronous stat(2). Returns an instance of `fs.Stats`.
-->

<p>同期の stat(2)。<code>fs.Stats</code> のインスタンスを返します。

</p>
<h2>fs.lstatSync(path)<span><a class="mark" href="#all_fs_lstatsync_path" id="all_fs_lstatsync_path">#</a></span></h2>
<!--
Synchronous lstat(2). Returns an instance of `fs.Stats`.
-->

<p>同期の lstat(2)。<code>fs.Stats</code> のインスタンスを返します。

</p>
<h2>fs.fstatSync(fd)<span><a class="mark" href="#all_fs_fstatsync_fd" id="all_fs_fstatsync_fd">#</a></span></h2>
<!--
Synchronous fstat(2). Returns an instance of `fs.Stats`.
-->

<p>同期の fstat(2)。<code>fs.Stats</code> のインスタンスを返します。

</p>
<h2>fs.link(srcpath, dstpath, [callback])<span><a class="mark" href="#all_fs_link_srcpath_dstpath_callback" id="all_fs_link_srcpath_dstpath_callback">#</a></span></h2>
<!--
Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.
-->

<p>非同期の link(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.linkSync(srcpath, dstpath)<span><a class="mark" href="#all_fs_linksync_srcpath_dstpath" id="all_fs_linksync_srcpath_dstpath">#</a></span></h2>
<!--
Synchronous link(2).
-->

<p>同期の link(2)。

</p>
<h2>fs.symlink(linkdata, path, [type], [callback])<span><a class="mark" href="#all_fs_symlink_linkdata_path_type_callback" id="all_fs_symlink_linkdata_path_type_callback">#</a></span></h2>
<!--
Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.
`type` argument can be either `'dir'` or `'file'` (default is `'file'`).  It is only 
used on Windows (ignored on other platforms).
-->

<p>非同期の symlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。
<code>type</code> 引数は <code>&apos;dir&apos;</code> または <code>&apos;file&apos;</code> (デフォルトは <code>&apos;file&apos;</code>) です。
これは Windows でのみ使われます (他のプラットフォームでは無視されます)。

</p>
<h2>fs.symlinkSync(linkdata, path, [type])<span><a class="mark" href="#all_fs_symlinksync_linkdata_path_type" id="all_fs_symlinksync_linkdata_path_type">#</a></span></h2>
<!--
Synchronous symlink(2).
-->

<p>同期の symlink(2)。

</p>
<h2>fs.readlink(path, [callback])<span><a class="mark" href="#all_fs_readlink_path_callback" id="all_fs_readlink_path_callback">#</a></span></h2>
<!--
Asynchronous readlink(2). The callback gets two arguments `(err,
linkString)`.
-->

<p>非同期の readlink(2)。コールバックは 2 つの引数を受け取る <code>(err, linkString)</code>です。

</p>
<h2>fs.readlinkSync(path)<span><a class="mark" href="#all_fs_readlinksync_path" id="all_fs_readlinksync_path">#</a></span></h2>
<!--
Synchronous readlink(2). Returns the symbolic link's string value.
-->

<p>同期の readlink(2)。シンボリックリンクの持つ文字列値を返します。

</p>
<h2>fs.realpath(path, [callback])<span><a class="mark" href="#all_fs_realpath_path_callback" id="all_fs_realpath_path_callback">#</a></span></h2>
<!--
Asynchronous realpath(2).  The callback gets two arguments `(err,
resolvedPath)`.  May use `process.cwd` to resolve relative paths.
-->

<p>非同期の realpath(2)。コールバックは 2 つの引数を受け取る <code>(err, resolvedPath)</code>です。
相対パスを解決するために <code>process.cwd</code> を使用することができます。

</p>
<h2>fs.realpathSync(path)<span><a class="mark" href="#all_fs_realpathsync_path" id="all_fs_realpathsync_path">#</a></span></h2>
<!--
Synchronous realpath(2). Returns the resolved path.
-->

<p>同期の realpath(2)。解決されたパスを返します。

</p>
<h2>fs.unlink(path, [callback])<span><a class="mark" href="#all_fs_unlink_path_callback" id="all_fs_unlink_path_callback">#</a></span></h2>
<!--
Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の unlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.unlinkSync(path)<span><a class="mark" href="#all_fs_unlinksync_path" id="all_fs_unlinksync_path">#</a></span></h2>
<!--
Synchronous unlink(2).
-->

<p>同期の unlink(2)。

</p>
<h2>fs.rmdir(path, [callback])<span><a class="mark" href="#all_fs_rmdir_path_callback" id="all_fs_rmdir_path_callback">#</a></span></h2>
<!--
Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の rmdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.rmdirSync(path)<span><a class="mark" href="#all_fs_rmdirsync_path" id="all_fs_rmdirsync_path">#</a></span></h2>
<!--
Synchronous rmdir(2).
-->

<p>同期の rmdir(2)。

</p>
<h2>fs.mkdir(path, [mode], [callback])<span><a class="mark" href="#all_fs_mkdir_path_mode_callback" id="all_fs_mkdir_path_mode_callback">#</a></span></h2>
<!--
Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback. `mode` defaults to `0777`.
-->

<p>非同期の mkdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。
<code>mode</code> のデフォルトは <code>0777</code> です。

</p>
<h2>fs.mkdirSync(path, [mode])<span><a class="mark" href="#all_fs_mkdirsync_path_mode" id="all_fs_mkdirsync_path_mode">#</a></span></h2>
<!--
Synchronous mkdir(2).
-->

<p>同期の mkdir(2)。

</p>
<h2>fs.readdir(path, [callback])<span><a class="mark" href="#all_fs_readdir_path_callback" id="all_fs_readdir_path_callback">#</a></span></h2>
<!--
Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments `(err, files)` where `files` is an array of
the names of the files in the directory excluding `'.'` and `'..'`.
-->

<p>非同期の readdir(3)。ディレクトリの内容を読み込みます。
コールバックは 2 つの引数を受け取る <code>(err, files)</code>で、
<code>files</code> は <code>&apos;.&apos;</code> と <code>&apos;..&apos;</code> を除くディレクトリ内のファイル名の配列です。

</p>
<h2>fs.readdirSync(path)<span><a class="mark" href="#all_fs_readdirsync_path" id="all_fs_readdirsync_path">#</a></span></h2>
<!--
Synchronous readdir(3). Returns an array of filenames excluding `'.'` and
`'..'`.
-->

<p>同期の readdir(3)。<code>&apos;.&apos;</code> と <code>&apos;..&apos;</code> を除くディレクトリ内のファイル名の配列を返します。

</p>
<h2>fs.close(fd, [callback])<span><a class="mark" href="#all_fs_close_fd_callback" id="all_fs_close_fd_callback">#</a></span></h2>
<!--
Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の close(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.closeSync(fd)<span><a class="mark" href="#all_fs_closesync_fd" id="all_fs_closesync_fd">#</a></span></h2>
<!--
Synchronous close(2).
-->

<p>同期の close(2)。

</p>
<h2>fs.open(path, flags, [mode], [callback])<span><a class="mark" href="#all_fs_open_path_flags_mode_callback" id="all_fs_open_path_flags_mode_callback">#</a></span></h2>
<!--
Asynchronous file open. See open(2). `flags` can be:

* `'r'` - Open file for reading.
An exception occurs if the file does not exist.

* `'r+'` - Open file for reading and writing.
An exception occurs if the file does not exist.

* `'w'` - Open file for writing.
The file is created (if it does not exist) or truncated (if it exists).

* `'w+'` - Open file for reading and writing.
The file is created (if it does not exist) or truncated (if it exists).

* `'a'` - Open file for appending.
The file is created if it does not exist.

* `'a+'` - Open file for reading and appending.
The file is created if it does not exist.

`mode` defaults to `0666`. The callback gets two arguments `(err, fd)`.
-->

<p>非同期のファイルオープン。open(2) を参照してください。
フラグは以下になります:

</p>
<ul>
<li><p><code>&apos;r&apos;</code> - 読み込み専用でオープンします。
ファイルが存在しない場合は例外が発生します。</p>
</li>
<li><p><code>&apos;r+&apos;</code> - 読み書き両用でオープンします。
ファイルが存在しない場合は例外が発生します。</p>
</li>
<li><p><code>&apos;w&apos;</code> - 書き込み専用でオープンします。
ファイルは作成される (存在しない場合) または長さ 0 に切り詰められます
(存在する場合)。</p>
</li>
<li><p><code>&apos;r+&apos;</code> - 読み書き両用でオープンします。
ファイルは作成される (存在しない場合) または長さ 0 に切り詰められます
(存在する場合)。</p>
</li>
<li><p><code>&apos;a&apos;</code> - 追記用でオープンします。
ファイルが存在しない場合は作成されます。</p>
</li>
<li><p><code>&apos;a+&apos;</code> - 読み込みおよび追記用でオープンします。
ファイルが存在しない場合は作成されます。</p>
</li>
</ul>
<p><code>mode</code> のデフォルトは 0666 です。
コールバックは 2 つの引数を受け取る <code>(err, fd)</code>です。

</p>
<h2>fs.openSync(path, flags, [mode])<span><a class="mark" href="#all_fs_opensync_path_flags_mode" id="all_fs_opensync_path_flags_mode">#</a></span></h2>
<!--
Synchronous open(2).
-->

<p>同期の open(2)。

</p>
<h2>fs.utimes(path, atime, mtime, [callback])<span><a class="mark" href="#all_fs_utimes_path_atime_mtime_callback" id="all_fs_utimes_path_atime_mtime_callback">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a class="mark" href="#all_fs_utimessync_path_atime_mtime" id="all_fs_utimessync_path_atime_mtime">#</a></span></h2>
<!--
Change file timestamps of the file referenced by the supplied path.
-->

<p>渡されたパスが参照するファイルのタイムスタンプを変更します。

</p>
<h2>fs.futimes(fd, atime, mtime, [callback])<span><a class="mark" href="#all_fs_futimes_fd_atime_mtime_callback" id="all_fs_futimes_fd_atime_mtime_callback">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a class="mark" href="#all_fs_futimessync_fd_atime_mtime" id="all_fs_futimessync_fd_atime_mtime">#</a></span></h2>
<!--
Change the file timestamps of a file referenced by the supplied file
descriptor.
-->

<p>渡されたファイル記述子が参照するファイルのタイムスタンプを変更します。

</p>
<h2>fs.fsync(fd, [callback])<span><a class="mark" href="#all_fs_fsync_fd_callback" id="all_fs_fsync_fd_callback">#</a></span></h2>
<!--
Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の fsync(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.fsyncSync(fd)<span><a class="mark" href="#all_fs_fsyncsync_fd" id="all_fs_fsyncsync_fd">#</a></span></h2>
<!--
Synchronous fsync(2).
-->

<p>同期の fsync(2)。

</p>
<h2>fs.write(fd, buffer, offset, length, position, [callback])<span><a class="mark" href="#all_fs_write_fd_buffer_offset_length_position_callback" id="all_fs_write_fd_buffer_offset_length_position_callback">#</a></span></h2>
<!--
Write `buffer` to the file specified by `fd`.
-->

<p><code>fd</code> で指定されたファイルに <code>buffer</code> を書き込みます。

</p>
<!--
`offset` and `length` determine the part of the buffer to be written.
-->
<code>offset</code> と <code>length</code> は書き込まれるバッファの部分を決定します。

<!--
`position` refers to the offset from the beginning of the file where this data
should be written. If `position` is `null`, the data will be written at the
current position.
See pwrite(2).
-->

<p><code>position</code> はデータが書き込まれる位置をファイルの先頭からのオフセットで示します。
<code>position</code> が <code>null</code> の場合、データは現在の位置から書き込まれます。
pwrite(2) を参照してください。

</p>
<!--
The callback will be given two arguments `(err, written)` where `written`
specifies how many _bytes_ were written.
The callback will be given three arguments `(err, written, buffer)` where `written`
specifies how many _bytes_ were written from `buffer`.
-->

<p>コールバックは 3 つの引数が与えられる <code>(err, written, buffer)</code> で、
<code>written</code> は <code>buffer</code> から書き込まれた<em>バイト数</em>を示します。

</p>
<!--
Note that it is unsafe to use `fs.write` multiple times on the same file
without waiting for the callback. For this scenario,
`fs.createWriteStream` is strongly recommended.
-->

<p>同じファイルに対してコールバックされるのを待つことなく <code>fs.write()</code> を何度も呼び出すことは、安全ではないことに注意してください。
このシナリオでは、 <code>fs.createWriteStream()</code> を強く推奨します。

</p>
<h2>fs.writeSync(fd, buffer, offset, length, position)<span><a class="mark" href="#all_fs_writesync_fd_buffer_offset_length_position" id="all_fs_writesync_fd_buffer_offset_length_position">#</a></span></h2>
<!--
Synchronous version of buffer-based `fs.write()`. Returns the number of bytes
written.
-->

<p>バッファに基づく同期版の <code>fs.write()</code>。書き込まれたバイト数を返します。

</p>
<h2>fs.writeSync(fd, str, position, [encoding])<span><a class="mark" href="#all_fs_writesync_fd_str_position_encoding" id="all_fs_writesync_fd_str_position_encoding">#</a></span></h2>
<!--
Synchronous version of string-based `fs.write()`. `encoding` defaults to
`'utf8'`. Returns the number of _bytes_ written.
-->

<p>文字列に基づく同期版の <code>fs.write()</code>。
<code>encoding</code> のデフォルトは <code>&apos;utf8&apos;</code> です。
書き込まれたバイト数を返します。

</p>
<h2>fs.read(fd, buffer, offset, length, position, [callback])<span><a class="mark" href="#all_fs_read_fd_buffer_offset_length_position_callback" id="all_fs_read_fd_buffer_offset_length_position_callback">#</a></span></h2>
<!--
Read data from the file specified by `fd`.
-->

<p><code>fd</code> で指定されたファイルからデータを読み込みます。

</p>
<!--
`buffer` is the buffer that the data will be written to.
-->

<p><code>buffer</code> はデータが書き込まれるバッファです。

</p>
<!--
`offset` is offset within the buffer where writing will start.
-->

<p><code>offset</code> は書き込みを開始するバッファ内のオフセットです。

</p>
<!--
`length` is an integer specifying the number of bytes to read.
-->

<p><code>length</code> は読み込むバイト数を指定する整数です。

</p>
<!--
`position` is an integer specifying where to begin reading from in the file.
If `position` is `null`, data will be read from the current file position.
-->

<p><code>position</code> はファイルの読み込みを開始する位置を指定する整数です。
<code>position</code> が <code>null</code> の場合、データは現在の位置から読み込まれます。

</p>
<!--
The callback is given the three arguments, `(err, bytesRead, buffer)`.
-->

<p>コールバックは3つの引数が与えられる <code>(err, bytesRead, buffer)</code> です。

</p>
<h2>fs.readSync(fd, buffer, offset, length, position)<span><a class="mark" href="#all_fs_readsync_fd_buffer_offset_length_position" id="all_fs_readsync_fd_buffer_offset_length_position">#</a></span></h2>
<!--
Synchronous version of buffer-based `fs.read`. Returns the number of
`bytesRead`.
-->

<p>バッファに基づく同期版の <code>fs.read</code>。<code>bytesRead</code> の数を返します。

</p>
<h2>fs.readSync(fd, length, position, encoding)<span><a class="mark" href="#all_fs_readsync_fd_length_position_encoding" id="all_fs_readsync_fd_length_position_encoding">#</a></span></h2>
<!--
Synchronous version of string-based `fs.read`. Returns the number of
`bytesRead`.
-->

<p>文字列に基づく同期版の <code>fs.read</code>。<code>bytesRead</code> の数を返します。

</p>
<h2>fs.readFile(filename, [encoding], [callback])<span><a class="mark" href="#all_fs_readfile_filename_encoding_callback" id="all_fs_readfile_filename_encoding_callback">#</a></span></h2>
<!--
Asynchronously reads the entire contents of a file. Example:
-->

<p>ファイル全体の内容を非同期に読み込みます。例:

</p>
<pre><code>fs.readFile(&apos;/etc/passwd&apos;, function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<!--
The callback is passed two arguments `(err, data)`, where `data` is the
contents of the file.
-->

<p>コールバックは 2 つの引数が渡される <code>(err, data)</code> で、<code>data</code> はファイルの内容です。

</p>
<!--
If no encoding is specified, then the raw buffer is returned.
-->

<p>エンコーディングが指定されなければ、生のバッファが渡されます。


</p>
<h2>fs.readFileSync(filename, [encoding])<span><a class="mark" href="#all_fs_readfilesync_filename_encoding" id="all_fs_readfilesync_filename_encoding">#</a></span></h2>
<!--
Synchronous version of `fs.readFile`. Returns the contents of the `filename`.
-->

<p>同期版の <code>fs.readFile</code>。<code>filename</code> の内容を返します。

</p>
<!--
If `encoding` is specified then this function returns a string. Otherwise it
returns a buffer.
-->

<p><code>encoding</code> が指定されるとこの関数は文字列を返します。
そうでなければバッファを返します。


</p>
<h2>fs.writeFile(filename, data, [encoding], [callback])<span><a class="mark" href="#all_fs_writefile_filename_data_encoding_callback" id="all_fs_writefile_filename_data_encoding_callback">#</a></span></h2>
<!--
Asynchronously writes data to a file, replacing the file if it already exists.
`data` can be a string or a buffer. The `encoding` argument is ignored if
`data` is a buffer. It defaults to `'utf8'`.
-->

<p>非同期にデータをファイルに書き込みます。
ファイルが既に存在する場合は置き換えられます。
<code>data</code> は文字列またはバッファです。
<code>data</code> がバッファの場合、<code>encoding</code> は無視されます。
デフォルトは <code>&apos;utf8&apos;</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;It\&apos;s saved!&apos;);
});</code></pre>
<h2>fs.writeFileSync(filename, data, [encoding])<span><a class="mark" href="#all_fs_writefilesync_filename_data_encoding" id="all_fs_writefilesync_filename_data_encoding">#</a></span></h2>
<!--
The synchronous version of `fs.writeFile`.
-->

<p>同期版の <code>fs.writeFile</code>。

</p>
<h2>fs.watchFile(filename, [options], listener)<span><a class="mark" href="#all_fs_watchfile_filename_options_listener" id="all_fs_watchfile_filename_options_listener">#</a></span></h2>
<pre><code>Stability: 2 - Unstable.  Use fs.watch instead, if available.</code></pre>
<!--
Watch for changes on `filename`. The callback `listener` will be called each
time the file is accessed.
-->

<p><code>filename</code> の変更を監視します。コールバックの <code>listener</code> はファイルがアクセスされる度に呼び出されます。

</p>
<!--
The second argument is optional. The `options` if provided should be an object
containing two members a boolean, `persistent`, and `interval`. `persistent`
indicates whether the process should continue to run as long as files are
being watched. `interval` indicates how often the target should be polled,
in milliseconds. (On Linux systems with inotify, `interval` is ignored.) The
default is `{ persistent: true, interval: 0 }`.
-->

<p>第 2 引数はオプションです．
<code>options</code> が与えられる場合、それは boolean の <code>persistent</code> と <code>interval</code>
の二つのメンバを含むオブジェクトです。
<code>persistent</code> はファイルが監視されている間、
プロセスが実行し続けることを示します。
<code>interval</code> は対象をポーリングする間隔をミリ秒で示します
(inotify を備えた Linux システムでは <code>interval</code> は無視されます)。
デフォルトは <code>{ persistent: true, interval: 0}</code> です。

</p>
<!--
The `listener` gets two arguments the current stat object and the previous
stat object:
-->

<p><code>listener</code> は現在の状態オブジェクトと前の状態オブジェクトの 2 つの引数を受け取ります:

</p>
<pre><code>fs.watchFile(&apos;message.text&apos;, function (curr, prev) {
  console.log(&apos;the current mtime is: &apos; + curr.mtime);
  console.log(&apos;the previous mtime was: &apos; + prev.mtime);
});</code></pre>
<!--
These stat objects are instances of `fs.Stat`.

If you want to be notified when the file was modified, not just accessed
you need to compare `curr.mtime` and `prev.mtime`.
-->

<p>これらの状態オブジェクトは <code>fs.Stat</code> のインスタンスです。

</p>
<p>もしファイルがアクセスされただけでなく、変更された時の通知が必要であれば、<code>curr.mtime</code> と <code>prev.mtime</code> を比較する必要があります。

</p>
<h2>fs.unwatchFile(filename)<span><a class="mark" href="#all_fs_unwatchfile_filename" id="all_fs_unwatchfile_filename">#</a></span></h2>
<pre><code>Stability: 2 - Unstable.  Use fs.watch instead, if available.</code></pre>
<!--
Stop watching for changes on `filename`.
-->

<p><code>filename</code> の変更に対する監視を終了します。

</p>
<h2>fs.watch(filename, [options], listener)<span><a class="mark" href="#all_fs_watch_filename_options_listener" id="all_fs_watch_filename_options_listener">#</a></span></h2>
<pre><code>Stability: 2 - Unstable.  Not available on all platforms.</code></pre>
<!--
Watch for changes on `filename`, where `filename` is either a file or a
directory.  The returned object is a [fs.FSWatcher](#fs_class_fs_fswatcher).

The second argument is optional. The `options` if provided should be an object
containing a boolean member `persistent`, which indicates whether the process
should continue to run as long as files are being watched. The default is
`{ persistent: true }`.

The listener callback gets two arguments `(event, filename)`.  `event` is either
'rename' or 'change', and `filename` is the name of the file which triggered
the event.
-->

<p><code>filename</code> の変更を監視します。
<code>filename</code> はファイルまたはディレクトリのどちらかです。
戻り値のオブジェクトは <a href="#fs.FSWatcher">fs.FSWatcher</a> です。

</p>
<p>第 2 引数はオプションです。
もし指定されるなら、<code>options</code> は boolean の <code>persistent</code> プロパティを
持つオブジェクトであるべきです。
<code>persistent</code> はファイルが監視されている間、
プロセスが実行し続けることを示します。
デフォルトは <code>{ persistent: true }</code> です。

</p>
<p>リスナーコールバックは二つの引数 <code>(event, filename)</code> を与えられます。
<code>event</code> は <code>&apos;rename&apos;</code> または <code>&apos;change&apos;</code>、そして <code>filename</code> はイベントを
引き起こしたファイルの名前です。

</p>
<h3>Caveats<span><a class="mark" href="#all_caveats" id="all_caveats">#</a></span></h3>
<!--type=misc-->

<!--
The `fs.watch` API is not 100% consistent across platforms, and is
unavailable in some situations.
-->

<p><code>fs.watch</code> API はプラットフォーム間で 100% 完全ではありmせんし、
いくつかのシチュエーションで利用不可能です。

</p>
<h4>Availability<span><a class="mark" href="#all_availability" id="all_availability">#</a></span></h4>
<!--type=misc-->

<!--
This feature depends on the underlying operating system providing a way
to be notified of filesystem changes.

* On Linux systems, this uses `inotify`.
* On BSD systems (including OS X), this uses `kqueue`.
* On SunOS systems (including Solaris and SmartOS), this uses `event ports`.
* On Windows systems, this feature depends on `ReadDirectoryChangesW`.

If the underlying functionality is not available for some reason, then
`fs.watch` will not be able to function.  You can still use
`fs.watchFile`, which uses stat polling, but it is slower and less
reliable.
-->

<p>この機能は下層のオペレーティングシステムが提供するファイルシステム変更の
通知に依存します。

</p>
<ul>
<li>Linux システムでは <code>inotify</code> が使われます。</li>
<li>BSD システム (OS X を含みます) では <code>kqueue</code> が使われます。</li>
<li>SunOS システム (Solaris および SmartOS を含みます) では <code>event ports</code>
が使われます。</li>
<li>Windows システムでは、この機能は <code>ReadDirectoryChangesW</code> に依存します。</li>
</ul>
<p>何らかの理由で下層の機能が使えない場合、<code>fs.watch</code> は使えません。
stat をポーリングする <code>fs.watchFile</code> を使うことはできますが、
それは遅くて信頼性はより低くなります。

</p>
<h4>Filename Argument<span><a class="mark" href="#all_filename_argument" id="all_filename_argument">#</a></span></h4>
<!--type=misc-->

<p>Providing <code>filename</code> argument in the callback is not supported
on every platform (currently it&apos;s only supported on Linux and Windows).  Even
on supported platforms <code>filename</code> is not always guaranteed to be provided.
Therefore, don&apos;t assume that <code>filename</code> argument is always provided in the
callback, and have some fallback logic if it is null.
--&gt;

</p>
<p>コールバックに提供される <code>filename</code> 引数は、
全てのプラットフォームでサポートされるわけではありません
(現時点では Linux と Windows でのみサポートされます)。
サポートされるプラットフォームであっても、<code>filename</code> が常に提供されることが
保証されているわけではありません。
そのため、コールバックは <code>filename</code> 引数が常に提供されると仮定せず、
それが <code>null</code> だったときの代替手段を持つべきです。

</p>
<pre><code>fs.watch(&apos;somedir&apos;, function (event, filename) {
  console.log(&apos;event is: &apos; + event);
  if (filename) {
    console.log(&apos;filename provided: &apos; + filename);
  } else {
    console.log(&apos;filename not provided&apos;);
  }
});</code></pre>
<h2>Class: fs.Stats<span><a class="mark" href="#all_class_fs_stats" id="all_class_fs_stats">#</a></span></h2>
<!--
Objects returned from `fs.stat()`, `fs.lstat()` and `fs.fstat()` and their
synchronous counterparts are of this type.
-->

<p><code>fs.stat()</code>、<code>fs.lstat()</code>、<code>fs.fstat()</code>、そしてそれらの同期版 から返される
オブジェクトはこの型です。

</p>
<!--
 - `stats.isFile()`
 - `stats.isDirectory()`
 - `stats.isBlockDevice()`
 - `stats.isCharacterDevice()`
 - `stats.isSymbolicLink()` (only valid with  `fs.lstat()`)
 - `stats.isFIFO()`
 - `stats.isSocket()`
-->

<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (<code>fs.lstat()</code> でのみ有効)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<!--
For a regular file `util.inspect(stats)` would return a string very
similar to this:
-->

<p><code>util.inspect(stats)</code> は通常のファイルに対して次のような文字列を返します。

</p>
<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>
<!--
Please note that `atime`, `mtime` and `ctime` are instances
of [Date][MDN-Date] object and to compare the values of
these objects you should use appropriate methods. For most
general uses [getTime()][MDN-Date-getTime] will return
the number of milliseconds elapsed since _1 January 1970
00:00:00 UTC_ and this integer should be sufficient for
any comparison, however there additional methods which can
be used for displaying fuzzy information. More details can
be found in the [MDN JavaScript Reference][MDN-Date] page.
-->

<p><code>atime</code>、<code>mtime</code>、そして <code>ctime</code> は <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> オブジェクトであり、
その値を比較するには適切な方法があるということに注意してください。
もっとも一般的に使われる <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> は <em>1970 年 1 月
1 日</em>からの経過時間をミリ秒単位で返します。
それは比較には十分ですが、曖昧な情報を表示するには別の方法を使ってください。
より詳しい情報は <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> で探すことができます。

</p>
<h2>fs.createReadStream(path, [options])<span><a class="mark" href="#all_fs_createreadstream_path_options" id="all_fs_createreadstream_path_options">#</a></span></h2>
<!--
Returns a new ReadStream object (See `Readable Stream`).
-->

<p>新しい ReadStream オブジェクトを返します (<code>Readable Stream</code> を参照してください)。

</p>
<!--
`options` is an object with the following defaults:
-->

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:

</p>
<pre><code>{ flags: &apos;r&apos;,
  encoding: null,
  fd: null,
  mode: 0666,
  bufferSize: 64 * 1024
}</code></pre>
<!--
`options` can include `start` and `end` values to read a range of bytes from
the file instead of the entire file.  Both `start` and `end` are inclusive and
start at 0.
-->

<p>ファイル全体を読み込む代わりに一部の範囲を読み込むため、
<code>options</code> に <code>start</code> および <code>end</code> を含めることができます。
<code>start</code> と <code>end</code> はどちらも包含的で0から始まります。

</p>
<!--
An example to read the last 10 bytes of a file which is 100 bytes long:
-->

<p>100 バイトの長さを持つファイルの最後の 10 バイトを読み込む例:

</p>
<pre><code>fs.createReadStream(&apos;sample.txt&apos;, {start: 90, end: 99});</code></pre>
<h2>Class: fs.ReadStream<span><a class="mark" href="#all_class_fs_readstream" id="all_class_fs_readstream">#</a></span></h2>
<!--
`ReadStream` is a [Readable Stream](stream.html#stream_readable_stream).
-->

<p><code>ReadStream</code> は <a href="stream.html#stream_readable_stream">Readable Stream</a> です。

</p>
<h3>Event: &apos;open&apos;<span><a class="mark" href="#all_event_open" id="all_event_open">#</a></span></h3>
<!--
* `fd` {Integer} file descriptor used by the ReadStream.

Emitted when the ReadStream's file is opened.
-->

<ul>
<li><code>fd</code> {Integer} ReadStream で使われる ファイル記述子。</li>
</ul>
<p>ReadStream のファイルがオープンされた場合に生成されます。

</p>
<h2>fs.createWriteStream(path, [options])<span><a class="mark" href="#all_fs_createwritestream_path_options" id="all_fs_createwritestream_path_options">#</a></span></h2>
<!--
Returns a new WriteStream object (See `Writable Stream`).
-->

<p>新しい WriteStream オブジェクトを返します (<code>Writable Stream</code> を参照してください)。

</p>
<!--
`options` is an object with the following defaults:
-->

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:

</p>
<pre><code>{ flags: &apos;w&apos;,
  encoding: null,
  mode: 0666 }</code></pre>
<!--
`options` may also include a `start` option to allow writing data at
some position past the beginning of the file.  Modifying a file rather
than replacing it may require a `flags` mode of `r+` rather than the
default mode `w`.
-->

<p><code>options</code> にはデータをファイルのどの位置に書き込むかを指定する
<code>start</code> を含めることができます。
ファイルを置換するのではなく変更する場合は、 <code>flags</code> にデフォルトの
<code>w</code> ではなく <code>r+</code> が必要となります。

</p>
<h2>fs.WriteStream<span><a class="mark" href="#all_fs_writestream" id="all_fs_writestream">#</a></span></h2>
<!--
`WriteStream` is a [Writable Stream](stream.html#stream_writable_stream).
-->

<p><code>WriteStream</code> は <a href="stream.html#stream_writable_stream">Writable Stream</a> です。

</p>
<h3>Event: &apos;open&apos;<span><a class="mark" href="#all_event_open_1" id="all_event_open_1">#</a></span></h3>
<!--
* `fd` {Integer} file descriptor used by the ReadStream.

Emitted when the WriteStream's file is opened.
-->

<ul>
<li><code>fd</code> {Integer} WriteStream で使われる ファイル記述子。</li>
</ul>
<p>WriteStream のファイルがオープンされた場合に生成されます。

</p>
<h3>file.bytesWritten<span><a class="mark" href="#all_file_byteswritten" id="all_file_byteswritten">#</a></span></h3>
<!--
The number of bytes written so far. Does not include data that is still queued
for writing.
-->

<p>これまでに書き込まれたバイト数。
書き込みがキューイングされたままのデータは含まれません。

</p>
<p> <code>fd</code> is the file descriptor used by the ReadStream.

</p>
<h2>Class: fs.FSWatcher<span><a class="mark" href="#all_class_fs_fswatcher" id="all_class_fs_fswatcher">#</a></span></h2>
<!--
Objects returned from `fs.watch()` are of this type.
-->

<p><code>fs.watch()</code> が返すオブジェクトはこの型です。

</p>
<h3>watcher.close()<span><a class="mark" href="#all_watcher_close" id="all_watcher_close">#</a></span></h3>
<!--
Stop watching for changes on the given `fs.FSWatcher`.
-->

<p><code>fs.FSWatcher</code> に与えられたファイルの監視を終了します。

</p>
<h3>Event: &apos;change&apos;<span><a class="mark" href="#all_event_change" id="all_event_change">#</a></span></h3>
<!--
* `event` {String} The type of fs change
* `filename` {String} The filename that changed (if relevant/available)
-->

<ul>
<li><code>event</code> {String} 変更の種類</li>
<li><code>filename</code> {String} 変更されたファイル名 (もし可能であれば)</li>
</ul>
<!--
Emitted when something changes in a watched directory or file.
See more details in [fs.watch](#fs_fs_watch_filename_options_listener).
-->

<p>監視しているファイルまたはディレクトリに変更があると生成されます。
詳しくは <a href="#fs_fs_watch_filename_options_listener">fs.watch</a> を参照してください。

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_2" id="all_event_error_2">#</a></span></h3>
<div class="signature"><ul>
<li><code>error</code> <span class="type">Error object</span></li>
</div></ul>
<!--
Emitted when an error occurs.
-->

<p>エラーが発生すると生成されます。

</p>
<h1>Path<span><a class="mark" href="#all_path" id="all_path">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
This module contains utilities for handling and transforming file
paths.  Almost all these methods perform only string transformations.
The file system is not consulted to check whether paths are valid.

`path.exists` and `path.existsSync` are the exceptions, and should
logically be found in the fs module as they do access the file system.

Use `require('path')` to use this module.  The following methods are provided:
-->

<p>このモジュールはファイルのパスに対する処理や変換を行うユーティリティを含みます。
ほとんどのメソッドは文字列の変換だけを行います。
パスが正しいか検証するためにファイルシステムに尋ねることはありません。

</p>
<p>例外は <code>path.exists</code> および <code>path.existsSync</code> で、
これらはファイルシステムにアクセスするため、
論理的には fs モジュールにあるべきです。

</p>
<p>このモジュールを利用するには<code>require(&apos;path&apos;)</code>を呼び出してください。
このモジュールは以下のメソッドを提供します。

</p>
<h2>path.normalize(p)<span><a class="mark" href="#all_path_normalize_p" id="all_path_normalize_p">#</a></span></h2>
<!--
Normalize a string path, taking care of `'..'` and `'.'` parts.

->
文字列によるパスを正規化します。`'..'` と `'.'` の要素には注意してください。

<!--
When multiple slashes are found, they're replaced by a single one;
when the path contains a trailing slash, it is preserved.
On windows backslashes are used. 
-->

<p>複数のスラッシュが見つかると、それらは一つに置換されます;
パスの最後にスラッシュが含まれていると、それは維持されます。
Windows ではバックスラッシュが使われます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.join([path1], [path2], [...])<span><a class="mark" href="#all_path_join_path1_path2" id="all_path_join_path1_path2">#</a></span></h2>
<!--
Join all arguments together and normalize the resulting path.
Non-string arguments are ignored.
-->

<p>全ての引数を一つに結合し、結果として得られるパスを正規化します。
文字列でない引数は無視されます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;

path.join(&apos;foo&apos;, {}, &apos;bar&apos;)
// returns
&apos;foo/bar&apos;</code></pre>
<h2>path.resolve([from ...], to)<span><a class="mark" href="#all_path_resolve_from_to" id="all_path_resolve_from_to">#</a></span></h2>
<!--
Resolves `to` to an absolute path.
-->

<p><code>to</code> の絶対パスを解決します。

</p>
<!--
If `to` isn't already absolute `from` arguments are prepended in right to left
order, until an absolute path is found. If after using all `from` paths still
no absolute path is found, the current working directory is used as well. The
resulting path is normalized, and trailing slashes are removed unless the path 
gets resolved to the root directory. Non-string arguments are ignored.
-->

<p>もし <code>to</code> が既に絶対パスでなければ、絶対パスが見つかるまで <code>from</code> 引数を右から左の順で先頭に加えます。
全ての <code>from</code> を加えた後、パスがまだ絶対パスでなければ、カレントワーキングディレクトリが同様に使われます。
結果のパスは正規化され、解決されたパスがルートディレクトリでない限り末尾のスラッシュは削除されます。
文字列でない引数は無視されます。

</p>
<!--
Another way to think of it is as a sequence of `cd` commands in a shell.
-->

<p>それはシェルにおける <code>cd</code> コマンドの列だと考えることができます。

</p>
<!--
Examples:
-->

<p>例:

</p>
<pre><code>path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</code></pre>
<!--
Is similar to:
-->

<p>これは以下と同様です。

</p>
<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>
<!--
The difference is that the different paths don't need to exist and may also be
files.
-->

<p>違いは、それぞれのパスが必ずしも存在する必要がないことと、ファイルでも構わないことです。

</p>
<!--
Examples:
-->

<p>例:

</p>
<pre><code>path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)
// returns
&apos;/foo/bar/baz&apos;

path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)
// returns
&apos;/tmp/file&apos;

path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)
// if currently in /home/myself/node, it returns
&apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos;</code></pre>
<h2>path.relative(from, to)<span><a class="mark" href="#all_path_relative_from_to" id="all_path_relative_from_to">#</a></span></h2>
<!--
Solve the relative path from `from` to `to`.
-->

<p><code>from</code> から <code>to</code> への相対パスを解決します。

</p>
<!--
At times we have two absolute paths, and we need to derive the relative
path from one to the other.  This is actually the reverse transform of
`path.resolve`, which means we see that:
-->

<p>二つの絶対パスがあり、一方から他方への相対パスを得なければならない場合があります。
これは実際のところ、<code>path.resolve()</code> とは逆の変換です。
それは以下を意味します:



</p>
<pre><code>path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>
<!--
Examples:
-->

<p>例:

</p>
<pre><code>path.relative(&apos;C:\\orandea\\test\\aaa&apos;, &apos;C:\\orandea\\impl\\bbb&apos;)
// returns
&apos;..\\..\\impl\\bbb&apos;

path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;)
// returns
&apos;../../impl/bbb&apos;</code></pre>
<h2>path.dirname(p)<span><a class="mark" href="#all_path_dirname_p" id="all_path_dirname_p">#</a></span></h2>
<!--
Return the directory name of a path.  Similar to the Unix `dirname` command.
-->

<p>パスに含まれるディレクトリ名を返します。Unixの <code>dirname</code> コマンドと同様です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>path.dirname(&apos;/foo/bar/baz/asdf/quux&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.basename(p, [ext])<span><a class="mark" href="#all_path_basename_p_ext" id="all_path_basename_p_ext">#</a></span></h2>
<!--
Return the last portion of a path.  Similar to the Unix `basename` command.
-->

<p>パスの最後の要素を返します。Unixの <code>basename</code> コマンドと同様です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;)
// returns
&apos;quux.html&apos;

path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;, &apos;.html&apos;)
// returns
&apos;quux&apos;</code></pre>
<h2>path.extname(p)<span><a class="mark" href="#all_path_extname_p" id="all_path_extname_p">#</a></span></h2>
<!--
Return the extension of the path, from the last '.' to end of string
in the last portion of the path.  If there is no '.' in the last portion
of the path or the first character of it is '.', then it returns
an empty string.  Examples:
-->

<p>パスの最後の要素について、最後の &apos;.&apos; から文字列の最後までのパスの拡張子を返します。
最後の要素に &apos;.&apos; が含まれていなかった場合、もしくは &apos;.&apos; が最初の文字だった場合は、空の文字列を返します。
例:

</p>
<pre><code>path.extname(&apos;index.html&apos;)
// returns
&apos;.html&apos;

path.extname(&apos;index.&apos;)
// returns
&apos;.&apos;

path.extname(&apos;index&apos;)
// returns
&apos;&apos;</code></pre>
<h2>path.exists(p, [callback])<span><a class="mark" href="#all_path_exists_p_callback" id="all_path_exists_p_callback">#</a></span></h2>
<!--
Test whether or not the given path exists by checking with the file system.
Then call the `callback` argument with either true or false.  Example:
-->

<p>与えられたパスがファイルシステム上に存在するかどうか検査します。
そして引数の <code>callback</code> を真か偽か検査の結果とともに呼び出します。
例:

</p>
<pre><code>path.exists(&apos;/etc/passwd&apos;, function (exists) {
  util.debug(exists ? &quot;it&apos;s there&quot; : &quot;no passwd!&quot;);
});</code></pre>
<h2>path.existsSync(p)<span><a class="mark" href="#all_path_existssync_p" id="all_path_existssync_p">#</a></span></h2>
<!--
Synchronous version of `path.exists`.
-->

<p>同期版の <code>path.exists</code> です。

</p>
<h1>net<span><a class="mark" href="#all_net" id="all_net">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
The `net` module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include
this module with `require('net');`
-->

<p><code>net</code> モジュールは非同期なネットワークのラッパーを提供します。
それはサーバとクライアントの両方 (ストリームと呼ばれます) を作成するための方法を含みます。
このモジュールは<code>require(&quot;net&quot;);</code>によって取り込むことができます。

</p>
<h2>net.createServer([options], [connectionListener])<span><a class="mark" href="#all_net_createserver_options_connectionlistener" id="all_net_createserver_options_connectionlistener">#</a></span></h2>
<!--
Creates a new TCP server. The `connectionListener` argument is
automatically set as a listener for the ['connection'](#event_connection_)
event.

`options` is an object with the following defaults:
-->

<p>新しい TCP サーバを作成します。
<code>connectionListener</code> 引数は <a href="#event_connection_">&apos;connection&apos;</a>
イベントに対するリスナーとして自動的に加えられます。

</p>
<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:

</p>
<pre><code>{ allowHalfOpen: false
}</code></pre>
<!--
If `allowHalfOpen` is `true`, then the socket won't automatically send FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the `end()` method explicitly.
See ['end'](#event_end_) event for more information.
-->

<p><code>allowHalfOpen</code> が <code>true</code> だと、反対側のソケットが FIN パケットを送信してきても自動的に FIN を送信しなくなります。
ソケットは読み込み可能ではなくなりますが、書き込み可能のままです。
明示的に <code>end()</code> を呼び出す必要があります。
<a href="#event_end_">&apos;end&apos;</a> イベントにより多くの情報があります。

</p>
<!--
Here is an example of a echo server which listens for connections
on port 8124:
-->

<p>8124 番のポートへの接続を待ち受けるエコーサーバの例:

</p>
<pre><code>var net = require(&apos;net&apos;);
var server = net.createServer(function(c) { //&apos;connection&apos; listener
  console.log(&apos;server connected&apos;);
  c.on(&apos;end&apos;, function() {
    console.log(&apos;server disconnected&apos;);
  });
  c.write(&apos;hello\r\n&apos;);
  c.pipe(c);
});
server.listen(8124, function() { //&apos;listening&apos; listener
  console.log(&apos;server bound&apos;);
});</code></pre>
<!--
Test this by using `telnet`:
-->

<p><code>telnet</code> を使ってテストします:

</p>
<pre><code>telnet localhost 8124</code></pre>
<!--
To listen on the socket `/tmp/echo.sock` the third line from the last would
just be changed to
-->

<p><code>&apos;/tmp/echo.sock&apos;</code> へのソケットを待ち受けるには、最後から三行目をこのように変更します。

</p>
<pre><code>server.listen(&apos;/tmp/echo.sock&apos;, function() { //&apos;listening&apos; listener</code></pre>
<!--
Use `nc` to connect to a UNIX domain socket server:
-->

<p><code>nc</code> を使って UNIX ドメインソケットサーバへ接続します:

</p>
<pre><code>nc -U /tmp/echo.sock</code></pre>
<h2>net.connect(arguments...)<span><a class="mark" href="#all_net_connect_arguments" id="all_net_connect_arguments">#</a></span></h2>
<h2>net.createConnection(arguments...)<span><a class="mark" href="#all_net_createconnection_arguments" id="all_net_createconnection_arguments">#</a></span></h2>
<!--
Construct a new socket object and opens a socket to the given location. When
the socket is established the ['connect'](#event_connect_) event will be
emitted.
-->

<p>新しいソケットオブジェクトを構築し、与えられたロケーションへのソケットをオープンします。
ソケットが確立されると、<a href="#event_connect_">&apos;connect&apos;</a> イベントが生成されます。

</p>
<!--
The arguments for these methods change the type of connection:
-->

<p>このメソッドの引数はコネクションの種類によって変わります。

</p>
<ul>
<li><code>net.connect(port, [host], [connectListener])</code></li>
<li><code>net.createConnection(port, [host], [connectListener])</code></li>
</ul>
<!--
  Creates a TCP connection to `port` on `host`. If `host` is omitted,
  `'localhost'` will be assumed.
-->

<p>  <code>host</code> 上の <code>port</code> に対する TCP コネクションを作成します。
  <code>host</code> が省略されると <code>localhost</code> が仮定されます。

</p>
<ul>
<li><code>net.connect(path, [connectListener])</code></li>
<li><code>net.createConnection(path, [connectListener])</code></li>
</ul>
<!--
  Creates unix socket connection to `path`.
-->

<p>  <code>path</code> に対する UNIX ドメインソケットを作成します。

</p>
<!--
The `connectListener` parameter will be added as an listener for the
['connect'](#event_connect_) event.
-->

<p><code>connectListener</code> 引数は <a href="#event_connect_">&apos;connect&apos;</a>
イベントのリスナとして追加されます。

</p>
<!--
Here is an example of a client of echo server as described previously:
-->

<p>前述のエコーサーバに接続するクライアントの例:

</p>
<pre><code>var net = require(&apos;net&apos;);
var client = net.connect(8124, function() { //&apos;connect&apos; listener
  console.log(&apos;client connected&apos;);
  client.write(&apos;world!\r\n&apos;);
});
client.on(&apos;data&apos;, function(data) {
  console.log(data.toString());
  client.end();
});
client.on(&apos;end&apos;, function() {
  console.log(&apos;client disconnected&apos;);
});</code></pre>
<!--
To connect on the socket `/tmp/echo.sock` the second line would just be
changed to
-->

<p><code>&apos;/tmp/echo.sock&apos;</code> へのソケットに接続するには、2 行目をこのように変更します。

</p>
<pre><code>var client = net.connect(&apos;/tmp/echo.sock&apos;, function() { //&apos;connect&apos; listener</code></pre>
<h2>Class: net.Server<span><a class="mark" href="#all_class_net_server" id="all_class_net_server">#</a></span></h2>
<!--
This class is used to create a TCP or UNIX server.
A server is a `net.Socket` that can listen for new incoming connections.
-->

<p>このクラスは TCP または UNIX ドメインのサーバを作成するために使われます。
サーバは <code>net.Scoket</code> であり、新たに到着する接続を待ち受けることができます。

</p>
<h3>server.listen(port, [host], [listeningListener])<span><a class="mark" href="#all_server_listen_port_host_listeninglistener" id="all_server_listen_port_host_listeninglistener">#</a></span></h3>
<!--
Begin accepting connections on the specified `port` and `host`.  If the
`host` is omitted, the server will accept connections directed to any
IPv4 address (`INADDR_ANY`). A port value of zero will assign a random port.
-->

<p>指定された <code>port</code> と <code>host</code> でコネクションの受け入れを開始します。
<code>host</code> が省略されると、サーバはどんな IPv4 アドレスへの接続も受け入れます
(<code>INADDR_ANY</code>)。
ポート番号に 0 を指定すると、ランダムなポートが割り当てられます。

</p>
<!--
This function is asynchronous.  When the server has been bound,
['listening'](#event_listening_) event will be emitted.
the last parameter `listeningListener` will be added as an listener for the
['listening'](#event_listening_) event.
-->

<p>この関数は非同期です。
サーバがバインドされると、<a href="#event_listening_">&apos;listening&apos;</a>
イベントが生成されます。
最後の引数 <code>listeningListener</code> は <a href="#event_listening_">&apos;listening&apos;</a>
のリスナとして加えられます。

</p>
<!--
One issue some users run into is getting `EADDRINUSE` errors. This means that
another server is already running on the requested port. One way of handling this
would be to wait a second and then try again. This can be done with
-->

<p>一部のユーザが陥る問題の一つは、<code>EADDRINUSE</code> エラーです。
これは、他のサーバが要求されたポートを使っていることを意味します。
これに対照する方法の一つは、1秒待機してからリトライすることです。
これは次のようになります

</p>
<pre><code>server.on(&apos;error&apos;, function (e) {
  if (e.code == &apos;EADDRINUSE&apos;) {
    console.log(&apos;Address in use, retrying...&apos;);
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>
<!--
(Note: All sockets in Node set `SO_REUSEADDR` already)
-->

<p>注意: Node の全てのソケットは <code>SO_REUSEADDR</code> が設定されます)


</p>
<h3>server.listen(path, [listeningListener])<span><a class="mark" href="#all_server_listen_path_listeninglistener" id="all_server_listen_path_listeninglistener">#</a></span></h3>
<!--
Start a UNIX socket server listening for connections on the given `path`.
-->

<p>与えられた <code>path</code> へのコネクションを待ち受けるする UNIX ドメインソケットのサーバを開始します。

</p>
<!--
This function is asynchronous.  When the server has been bound,
['listening'](#event_listening_) event will be emitted.
the last parameter `listeningListener` will be added as an listener for the
['listening'](#event_listening_) event.
-->

<p>この関数は非同期です。
サーバがバインドされると、<code>&apos;listening&apos;</code> イベントが生成されます。
最後の引数 <code>listeningListener</code> は <a href="#event_listening_">&apos;listening&apos;</a>
のリスナとして加えられます。

</p>
<h3>server.close()<span><a class="mark" href="#all_server_close_1" id="all_server_close_1">#</a></span></h3>
<!--
Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a `'close'`
event.
-->

<p>サーバが新しいコネクションを受け付けるのを終了します。
この関数は非同期で、サーバは最終的に <code>&apos;close&apos;</code> イベントを生成した時にクローズされます。


</p>
<h3>server.address()<span><a class="mark" href="#all_server_address_1" id="all_server_address_1">#</a></span></h3>
<!--
Returns the bound address and port of the server as reported by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address.
Returns an object with two properties, e.g. `{"address":"127.0.0.1", "port":2121}`
-->

<p>オペレーティングシステムから報告された、サーバにバインドされたアドレスとポートを返します。
OSによって割り当てられたアドレスが渡された時に、どのポートに割り当てられたものかを調べるのに便利です。
返されるオブジェクトは二つのプロパティを持ちます。
例えば <code>{&quot;address&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:2121}</code>

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var server = net.createServer(function (socket) {
  socket.end(&quot;goodbye\n&quot;);
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log(&quot;opened server on %j&quot;, address);
});</code></pre>
<!--
Don't call `server.address()` until the `'listening'` event has been emitted.
-->

<p><code>&apos;listening&apos;</code> イベントが生成される前に <code>server.address()</code> を呼び出してはいけません。

</p>
<h3>server.maxConnections<span><a class="mark" href="#all_server_maxconnections_1" id="all_server_maxconnections_1">#</a></span></h3>
<!--
Set this property to reject connections when the server's connection count gets
high.
-->

<p>サーバの接続数が大きくなった時に接続を拒否するためにこのプロパティを設定します。
</p>
<h3>server.connections<span><a class="mark" href="#all_server_connections_1" id="all_server_connections_1">#</a></span></h3>
<!--
The number of concurrent connections on the server.
-->

<p>このサーバ上の並行コネクションの数です。

</p>
<!--
`net.Server` is an `EventEmitter` with the following events:
-->

<p><code>net.Server</code> は以下のイベントを持つ <code>EventEmitter</code> です:

</p>
<h3>Event: &apos;listening&apos;<span><a class="mark" href="#all_event_listening" id="all_event_listening">#</a></span></h3>
<!--
Emitted when the server has been bound after calling `server.listen`.
-->

<p><code>server.listen()</code> が呼ばれた後、サーバがバインドされると生成されます。

</p>
<h3>Event: &apos;connection&apos;<span><a class="mark" href="#all_event_connection" id="all_event_connection">#</a></span></h3>
<!--
* {Socket object} The connection object
-->

<ul>
<li>{Socket object} コネクションオブジェクト</li>
</ul>
<!--
Emitted when a new connection is made. `socket` is an instance of
`net.Socket`.
-->

<p>新しいコネクションが作成されると生成されます。
<code>socket</code> は <code>net.Socket</code> のインスタンスです。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_2" id="all_event_close_2">#</a></span></h3>
<!--
Emitted when the server closes.
-->

<p>サーバがクローズした時に生成されます。

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_3" id="all_event_error_3">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Error Object</span></li>
</div></ul>
<!--
Emitted when an error occurs.  The `'close'` event will be called directly
following this event.  See example in discussion of `server.listen`.
-->

<p>エラーが発生すると生成されます。
このイベントに続いて <code>&apos;close&apos;</code> イベントが直接生成される場合があります。
<code>server.listen()</code> の例を参照してください。

</p>
<h2>Class: net.Socket<span><a class="mark" href="#all_class_net_socket" id="all_class_net_socket">#</a></span></h2>
<!--
This object is an abstraction of a TCP or UNIX socket.  `net.Socket`
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with `connect()`) or they can be created by Node
and passed to the user through the `'connection'` event of a server.
-->

<p>このオブジェクトは TCP または UNIX ドメインのソケットを抽象化したものです。
<code>net.Socket</code> のインスタンスは双方向のストリームインタフェースを実装します。
それらはユーザによって (<code>connect()</code> によって) 作成されてクライアントとして使われるか、
Node によって作成されてサーバの <code>&apos;connection&apos;</code> イベントを通じてユーザに渡されます。

</p>
<h3>new net.Socket([options])<span><a class="mark" href="#all_new_net_socket_options" id="all_new_net_socket_options">#</a></span></h3>
<!--
Construct a new socket object.
-->

<p>新しいソケットオブジェクトを構築します。

</p>
<!--
`options` is an object with the following defaults:
-->

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです。

</p>
<pre><code>{ fd: null
  type: null
  allowHalfOpen: false
}</code></pre>
<!--

`fd` allows you to specify the existing file descriptor of socket. `type`
specified underlying protocol. It can be `'tcp4'`, `'tcp6'`, or `'unix'`.
About `allowHalfOpen`, refer to `createServer()` and `'end'` event.
-->

<p><code>fd</code> に既存のソケットのファイル記述子を指定することができます。
<code>type</code> にはプロトコルを指定することができます。
指定できるのは <code>&apos;tcp4&apos;</code>、<code>&apos;tcp6&apos;</code> または <code>&apos;unix&apos;</code> のいずれかです。
<code>allowHalfOpen</code> については <code>createServer()</code> および <code>&apos;end&apos;</code> イベントを参照してください。

</p>
<h3>socket.connect(port, [host], [connectListener])<span><a class="mark" href="#all_socket_connect_port_host_connectlistener" id="all_socket_connect_port_host_connectlistener">#</a></span></h3>
<h3>socket.connect(path, [connectListener])<span><a class="mark" href="#all_socket_connect_path_connectlistener" id="all_socket_connect_path_connectlistener">#</a></span></h3>
<!--
Opens the connection for a given socket. If `port` and `host` are given,
then the socket will be opened as a TCP socket, if `host` is omitted,
`localhost` will be assumed. If a `path` is given, the socket will be
opened as a unix socket to that path.
-->

<p>与えられたソケットでコネクションをオープンします。
<code>port</code> と <code>host</code> が与えられた場合、
ソケットは TCP ソケットとしてオープンされます。
<code>host</code> が省略された場合は <code>localhost</code> が仮定されます。
<code>path</code> が与えられた場合は、
ソケットはそのパスへの UNIX ドメインソケットとしてオープンされます。

</p>
<!--
Normally this method is not needed, as `net.createConnection` opens the
socket. Use this only if you are implementing a custom Socket or if a
Socket is closed and you want to reuse it to connect to another server.
-->

<p>通常このメソッドは必要なく、<code>net.createConnection</code> でソケットをオープンします。
これを使うのは、カスタマイズされたソケットを実装している場合や、
ソケットがクローズされた後にコネクションを再利用して別のサーバに接続する場合だけです。

</p>
<!--
This function is asynchronous. When the ['connect'](#event_connect_) event is
emitted the socket is established. If there is a problem connecting, the
`'connect'` event will not be emitted, the `'error'` event will be emitted with
the exception.
-->

<p>この関数は非同期です。ソケットが確立されると <a href="#event_connect_">&apos;connect&apos;</a>
イベントが生成されます。
接続で問題があった場合は <code>&apos;connect&apos;</code> イベントは生成されず、
例外とともに <code>&apos;error&apos;</code> イベントが生成されます。

</p>
<!--
The `connectListener` parameter will be added as an listener for the
['connect'](#event_connect_) event.
-->

<p><code>connectListener</code> 引数は <a href="#event_connect_">&apos;connect&apos;</a>
イベントのリスナに加えられます。


</p>
<h3>socket.bufferSize<span><a class="mark" href="#all_socket_buffersize" id="all_socket_buffersize">#</a></span></h3>
<!--
`net.Socket` has the property that `socket.write()` always works. This is to
help users get up and running quickly. The computer cannot always keep up
with the amount of data that is written to a socket - the network connection
simply might be too slow. Node will internally queue up the data written to a
socket and send it out over the wire when it is possible. (Internally it is
polling on the socket's file descriptor for being writable).

The consequence of this internal buffering is that memory may grow. This
property shows the number of characters currently buffered to be written.
(Number of characters is approximately equal to the number of bytes to be
written, but the buffer may contain strings, and the strings are lazily
encoded, so the exact number of bytes is not known.)

Users who experience large or growing `bufferSize` should attempt to
"throttle" the data flows in their program with `pause()` and `resume()`.
-->

<p><code>net.Socket</code> には、<code>socket.write()</code> と常に協調するプロパティがあります。
これはユーザが実行速度を向上させる手助けになります。
コンピュータは、ソケットに書き込まれるデータ量についていくことはできません。
- ネットワーク接続は、単純に遅すぎます。
Node は、ソケットに書き込まれるデータを内部のキューに入れ、可能になった時にワイヤ上に送信します (内部ではソケットのファイル記述子が書き込み可能になるのをポーリングします)。

</p>
<p>内部的なバッファリングの結果、メモリ消費が増大するかもしれません。
このプロパティは、現在書き込みのためにバッファリングされている文字数を示します。
(文字数は書き込まれるバイト数とほぼ同じですが、バッファが文字列を含んでいる場合、文字列は遅延的にエンコードされるため、正確なバイト数は分かっていません)

</p>
<p>大きな、あるいは増大する <code>bufferSize</code> を体験したユーザは、そのプログラムで <code>pause()</code> および <code>resume()</code> を使ってデータフローを「抑えよう」としなければなりません。

</p>
<h3>socket.setEncoding([encoding])<span><a class="mark" href="#all_socket_setencoding_encoding" id="all_socket_setencoding_encoding">#</a></span></h3>
<!--
Sets the encoding (either `'ascii'`, `'utf8'`, or `'base64'`) for data that is
received. Defaults to `null`.
-->

<p>受信したデータのエンコーディングを設定します (<code>&apos;ascii&apos;</code>、<code>&apos;utf8&apos;</code>、
あるいは <code>&apos;base64&apos;</code> のいずれかです)。デフォルトは <code>null</code> です。

</p>
<h3>socket.setSecure()<span><a class="mark" href="#all_socket_setsecure" id="all_socket_setsecure">#</a></span></h3>
<!--
This function has been removed in v0.3. It used to upgrade the connection to
SSL/TLS. See the [TLS section](tls.html#tLS_) for the new API.
-->

<p>この関数は v0.3 で削除されました。
これはコネクションを SSL/TLS にアップグレードするために使われていました。
新しい API である <a href="tls.html#tLS_">TLS の章</a> を参照してください。

</p>
<h3>socket.write(data, [encoding], [callback])<span><a class="mark" href="#all_socket_write_data_encoding_callback" id="all_socket_write_data_encoding_callback">#</a></span></h3>
<!--
Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.
-->

<p>ソケットにデータを送信します。
文字列の場合、第 2 引数はエンコーディングを指定します － デフォルトは UTF-8 です。

</p>
<!--
Returns `true` if the entire data was flushed successfully to the kernel
buffer. Returns `false` if all or part of the data was queued in user memory.
`'drain'` will be emitted when the buffer is again free.
-->

<p>データ全体のカーネルバッファへのフラッシュが成功すると <code>true</code> を返します。
データ全体または一部がユーザメモリ内のキューに入れられた場合は <code>false</code> を返します。
再びバッファが空いた場合は <code>&apos;drain&apos;</code> イベントが生成されます。

</p>
<!--
The optional `callback` parameter will be executed when the data is finally
written out - this may not be immediately.
-->

<p>オプションの <code>callback</code> 引数はデータが最終的に出力された時に実行されます
－ これはすぐには起きないでしょう。

</p>
<h3>socket.end([data], [encoding])<span><a class="mark" href="#all_socket_end_data_encoding" id="all_socket_end_data_encoding">#</a></span></h3>
<!--
Half-closes the socket. i.e., it sends a FIN packet. It is possible the
server will still send some data.
-->

<p>ソケットをハーフクローズします。例えば FIN パケットを送信します。
サーバはまだデータを送り続けてくることができます。

</p>
<!--
If `data` is specified, it is equivalent to calling
`socket.write(data, encoding)` followed by `socket.end()`.
-->

<p><code>data</code> が指定された場合は、
<code>socket.write(data, encoding)</code> に続けて <code>socket.end()</code> を呼び出すのと等価です。

</p>
<h3>socket.destroy()<span><a class="mark" href="#all_socket_destroy" id="all_socket_destroy">#</a></span></h3>
<!--
Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).
-->

<p>このソケット上でどんな I/O も起こらないことを保証します。
(パースエラーなどの) エラーの場合にだけ必要です。

</p>
<h3>socket.pause()<span><a class="mark" href="#all_socket_pause" id="all_socket_pause">#</a></span></h3>
<!--
Pauses the reading of data. That is, `'data'` events will not be emitted.
Useful to throttle back an upload.
-->

<p>データの読み込みを中断します。つまり、<code>&apos;data&apos;</code> イベントは生成されません。
アップロード速度を落とすために便利です。

</p>
<h3>socket.resume()<span><a class="mark" href="#all_socket_resume" id="all_socket_resume">#</a></span></h3>
<!--
Resumes reading after a call to `pause()`.
-->

<p><code>pause()</code> を呼び出した後で読み込みを再開します。

</p>
<h3>socket.setTimeout(timeout, [callback])<span><a class="mark" href="#all_socket_settimeout_timeout_callback" id="all_socket_settimeout_timeout_callback">#</a></span></h3>
<!--
Sets the socket to timeout after `timeout` milliseconds of inactivity on
the socket. By default `net.Socket` do not have a timeout.
-->

<p>このソケットが非アクティブになってから <code>timeout</code> ミリ秒後にタイムアウト
するように設定します。デフォルトでは <code>net.Socket</code> はタイムアウトしません。

</p>
<!--
When an idle timeout is triggered the socket will receive a `'timeout'`
event but the connection will not be severed. The user must manually `end()`
or `destroy()` the socket.
-->

<p>アイドルタイムアウトが引き起こされると、ソケットは <code>&apos;timeout&apos;</code> イベントを受信しますが、
コネクションは切断されません。
ユーザは手動で <code>end()</code> または <code>destroy()</code> を呼び出す必要があります。

</p>
<!--
If `timeout` is 0, then the existing idle timeout is disabled.
-->

<p><code>timeout</code> が 0 の場合、アイドルタイムアウトは無効にされます。

</p>
<!--
The optional `callback` parameter will be added as a one time listener for the
`'timeout'` event.
-->

<p>オプションの <code>callback</code> 引数は、<code>timeouot</code> イベントの一回限りのリスナを追加します。

</p>
<h3>socket.setNoDelay([noDelay])<span><a class="mark" href="#all_socket_setnodelay_nodelay" id="all_socket_setnodelay_nodelay">#</a></span></h3>
<!--
Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting `true` for
`noDelay` will immediately fire off data each time `socket.write()` is called.
`noDelay` defaults to `true`.
-->

<p>Nagle アルゴリズムを無効にします。
デフォルトでは TCP コネクションは Nagle アルゴリズムを使用し、データを送信する前にバッファリングします。
<code>noDelay</code> に <code>true</code> を設定すると、データは <code>socket.write()</code>
を呼び出す度に即座に送信されます。デフォルトは <code>true</code> です。

</p>
<h3>socket.setKeepAlive([enable], [initialDelay])<span><a class="mark" href="#all_socket_setkeepalive_enable_initialdelay" id="all_socket_setkeepalive_enable_initialdelay">#</a></span></h3>
<!--
Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
`enable` defaults to `false`.

Set `initialDelay` (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting. Defaults to `0`.
-->

<p>キープアライブ機能を有効/無効にします。
オプションで最初の keepalive probe がアイドルソケットに送信されるまでの初期遅延を設定します。
<code>enable</code> のデフォルトは <code>false</code> です。

</p>
<p><code>initialDelay</code> (ミリ秒) が設定されると、
最後にデータパケットを受信してから最初の keepalive probe までの遅延が設定されます。
初期遅延に 0 が設定されると、デフォルト設定から値を変更されないようにします。
デフォルトは <code>0</code> です。

</p>
<h3>socket.address()<span><a class="mark" href="#all_socket_address" id="all_socket_address">#</a></span></h3>
<!--
Returns the bound address and port of the socket as reported by the operating
system. Returns an object with two properties, e.g.
`{"address":"192.168.57.1", "port":62053}`
-->

<p>オペレーティングシステムから報告された、ソケットにバインドされたアドレスとポートを返します。
返されるオブジェクトは二つのプロパティを持ちます。
例えば <code>{&quot;address&quot;:&quot;192.168.57.1&quot;, &quot;port&quot;:62053}</code>

</p>
<h3>socket.remoteAddress<span><a class="mark" href="#all_socket_remoteaddress" id="all_socket_remoteaddress">#</a></span></h3>
<!--
The string representation of the remote IP address. For example,
`'74.125.127.100'` or `'2001:4860:a005::68'`.
-->

<p>リモートの IP アドレスを表現する文字列です。
例えば、<code>&apos;74.125.127.100&apos;</code> あるいは <code>&apos;2001:4860:a005::68&apos;</code>。

</p>
<!--
This member is only present in server-side connections.
-->

<p>このメンバはサーバサイドのコネクションにのみ与えられます。

</p>
<h3>socket.remotePort<span><a class="mark" href="#all_socket_remoteport" id="all_socket_remoteport">#</a></span></h3>
<!--
The numeric representation of the remote port. For example,
`80` or `21`.
-->

<p>リモートポートの数値表現です。
たとえば、<code>80</code> や <code>21</code>。

</p>
<h3>socket.bytesRead<span><a class="mark" href="#all_socket_bytesread" id="all_socket_bytesread">#</a></span></h3>
<!--
The amount of received bytes.
-->

<p>受信したバイトの合計です。

</p>
<h3>socket.bytesWritten<span><a class="mark" href="#all_socket_byteswritten" id="all_socket_byteswritten">#</a></span></h3>
<!--
The amount of bytes sent.
-->

<p>送信したバイトの合計です。

</p>
<!--
`net.Socket` instances are EventEmitters with the following events:
-->

<p><code>net.Socket</code> のインスタンスは以下のイベントを持つ EventEmitter です:

</p>
<h3>Event: &apos;connect&apos;<span><a class="mark" href="#all_event_connect" id="all_event_connect">#</a></span></h3>
<!--
Emitted when a socket connection is successfully established.
See `connect()`.
-->

<p>ソケットコネクションの確立が成功した場合に生成されます。
<code>connect()</code> を参照してください。

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_1" id="all_event_data_1">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Buffer object</span></li>
</div></ul>
<!--
Emitted when data is received.  The argument `data` will be a `Buffer` or
`String`.  Encoding of data is set by `socket.setEncoding()`.
(See the [Readable Stream](stream.html#readable_stream) section for more
information.)

Note that the __data will be lost__ if there is no listener when a `Socket`
emits a `'data'` event.
-->

<p>データを受信した場合に生成されます。
<code>data</code> 引数は <code>Buffer</code> または <code>String</code> です。
データのエンコーディングは <code>socket.setEncoding()</code> で設定されます。
(より詳しい情報は <a href="stream.html#readable_Stream">Readable Stream</a> を参照してください)。

</p>
<p><code>Socket</code> が <code>&apos;data&apos;</code> イベントを生成した時にリスナが存在しなければ、
<strong>データは失われる</strong>ことに注意してください。

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_1" id="all_event_end_1">#</a></span></h3>
<!--
Emitted when the other end of the socket sends a FIN packet.
-->

<p>ソケットの相手側が FIN パケットを送信した場合に生成されます。

</p>
<!--
By default (`allowHalfOpen == false`) the socket will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting `allowHalfOpen == true` the socket will not automatically `end()`
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to `end()` their side now.
-->

<p>デフォルト (<code>allowHalfOpen == false</code>) では、
保留されていた書き込みキューが出力されるとソケットはファイル識別子を破棄します。
しかし、<code>allowHalfOpen == true</code> が設定されていると、
ユーザがデータを書き込めるようにしておくために、ソケットは自動的に <code>end()</code> を呼び出さないので、
ユーザが <code>end()</code> を呼び出す必要があります。


</p>
<h3>Event: &apos;timeout&apos;<span><a class="mark" href="#all_event_timeout" id="all_event_timeout">#</a></span></h3>
<!--
Emitted if the socket times out from inactivity. This is only to notify that
the socket has been idle. The user must manually close the connection.

See also: `socket.setTimeout()`
-->

<p>ソケットがタイムアウトして非アクティブになった場合に生成されます。
これはソケットがアイドルになったことを通知するだけです。
利用者は手動でコネクションをクローズする必要があります。

</p>
<p><code>socket.setTimeout()</code> を参照してください。


</p>
<h3>Event: &apos;drain&apos;<span><a class="mark" href="#all_event_drain_1" id="all_event_drain_1">#</a></span></h3>
<!--
Emitted when the write buffer becomes empty. Can be used to throttle uploads.

See also: the return values of `socket.write()`
-->

<p>書き込みバッファが空になった場合に生成されます。アップロード速度を落とすために使うことができます。

</p>
<p><code>socket.write()</code> の戻り値を参照してください。

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_4" id="all_event_error_4">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Error object</span></li>
</div></ul>
<!--
Emitted when an error occurs.  The `'close'` event will be called directly
following this event.
-->

<p>エラーが発生した場合に生成されます。<code>&apos;close&apos;</code> イベントはこのイベントの後に直接呼び出されます。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_3" id="all_event_close_3">#</a></span></h3>
<div class="signature"><ul>
<li><code>had_error</code> <span class="type">Boolean</span> true if the socket had a transmission error</li>
</div></ul>
<!--
Emitted once the socket is fully closed. The argument `had_error` is a boolean
which says if the socket was closed due to a transmission error.
-->

<p>ソケットが完全にクローズした場合に生成されます。
引数 <code>had_error</code> は boolean で、ソケットが転送エラーでクローズされたのかどうかを示します。

</p>
<h2>net.isIP(input)<span><a class="mark" href="#all_net_isip_input" id="all_net_isip_input">#</a></span></h2>
<!--
Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.
-->

<p><code>input</code> が IP アドレスかテストします。
不正な文字列だと 0、IP バージョン 4 アドレスだと 4，IP バージョン 6
アドレスだと 6 が返されます。

</p>
<h2>net.isIPv4(input)<span><a class="mark" href="#all_net_isipv4_input" id="all_net_isipv4_input">#</a></span></h2>
<!--
Returns true if input is a version 4 IP address, otherwise returns false.
-->

<p><code>input</code> が バージョン 4 の IP アドレスなら true、そうでなければ false を返します。


</p>
<h2>net.isIPv6(input)<span><a class="mark" href="#all_net_isipv6_input" id="all_net_isipv6_input">#</a></span></h2>
<!--
Returns true if input is a version 6 IP address, otherwise returns false.
-->

<p><code>input</code> が バージョン 6 の IP アドレスなら true、そうでなければ false を返します。

</p>
<h1>UDP / Datagram Sockets<span><a class="mark" href="#all_udp_datagram_sockets" id="all_udp_datagram_sockets">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!-- name=dgram -->

<!--
Datagram sockets are available through `require('dgram')`.
-->

<p>データグラムソケットは <code>require(&apos;dgram&apos;)</code> で利用可能になります。

</p>
<h2>dgram.createSocket(type, [callback])<span><a class="mark" href="#all_dgram_createsocket_type_callback" id="all_dgram_createsocket_type_callback">#</a></span></h2>
<!--
* `type` String. Either 'udp4' or 'udp6'
* `callback` Function. Attached as a listener to `message` events.
  Optional
* Returns: Socket object
-->

<ul>
<li><code>type</code> String. &apos;udp4&apos; または &apos;udp6&apos; のいずれか</li>
<li><code>callback</code> Function. <code>&apos;message&apos;</code> イベントのリスナとして割り当てられる、
Optional</li>
<li>Returns: Socket object</li>
</ul>
<!--
Creates a datagram Socket of the specified types.  Valid types are `udp4`
and `udp6`.

Takes an optional callback which is added as a listener for `message` events.

Call `socket.bind` if you want to receive datagrams. `socket.bind()` will bind
to the "all interfaces" address on a random port (it does the right thing for
both `udp4` and `udp6` sockets). You can then retrieve the address and port
with `socket.address().address` and `socket.address().port`.
-->

<p>指定された種類のデータグラムソケットを作成します。
妥当な種類は <code>udp4</code> と <code>udp6</code>です。

</p>
<p>オプションのコールバックは <code>message</code> イベントのリスナーとして加えられます。

</p>
<p>データグラムを受信したい場合は <code>socket.bind()</code> を呼び出します。
<code>socket.bind()</code> は「全てのインタフェース」のアドレスにランダムなポート
(<code>udp4</code> と <code>udp6</code> ソケットの両方で正しいものです) をバインドします。
そのアドレスとポートは <code>socket.address().address</code> および
<code>socket.address().port</code> で取得することができます。

</p>
<h2>Class: Socket<span><a class="mark" href="#all_class_socket" id="all_class_socket">#</a></span></h2>
<!--
The dgram Socket class encapsulates the datagram functionality.  It
should be created via `dgram.createSocket(type, [callback])`.
-->

<p>dgram Scoket クラスはデータグラム機能をカプセル化します。
それは <code>dgram.createSocket(type, [callback])</code> を通じて生成されます。

</p>
<h3>Event: &apos;message&apos;<span><a class="mark" href="#all_event_message" id="all_event_message">#</a></span></h3>
<!--
* `msg` Buffer object. The message
* `rinfo` Object. Remote address information
-->

<ul>
<li><code>msg</code> Buffer object. メッセージ</li>
<li><code>rinfo</code> Object. リモートアドレスの情報</li>
</ul>
<!--
Emitted when a new datagram is available on a socket.  `msg` is a `Buffer` and `rinfo` is
an object with the sender's address information and the number of bytes in the datagram.
-->

<p>ソケット上で新しいデータグラムが到着した時に生成されます。<code>msg</code> は <code>Buffer</code> で、
<code>rinfo</code> は送信者のアドレス情報とデータグラムのバイト数を持ったオブジェクトです。

</p>
<h3>Event: &apos;listening&apos;<span><a class="mark" href="#all_event_listening_1" id="all_event_listening_1">#</a></span></h3>
<!--
Emitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets
are created.
-->

<p>ソケットでデータグラムの待ち受けを開始すると生成されます。
これは UDP ソケットが作成されるとすぐに発生します。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_4" id="all_event_close_4">#</a></span></h3>
<!--
Emitted when a socket is closed with `close()`.  No new `message` events will be emitted
on this socket.
-->

<p><code>close()</code> によってソケットがクローズすると生成されます。
このソケットでは新しい <code>message</code> イベントは生成されなくなります。

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_5" id="all_event_error_5">#</a></span></h3>
<div class="signature"><ul>
<li><code>exception</code> Error object</li>
</div></ul>
<!--
Emitted when an error occurs.
-->

<p>エラーが発生すると生成されます。

</p>
<h3>dgram.send(buf, offset, length, port, address, [callback])<span><a class="mark" href="#all_dgram_send_buf_offset_length_port_address_callback" id="all_dgram_send_buf_offset_length_port_address_callback">#</a></span></h3>
<!--
* `buf` Buffer object.  Message to be sent
* `offset` Integer. Offset in the buffer where the message starts.
* `length` Integer. Number of bytes in the message.
* `port` Integer. destination port
* `address` String. destination IP
* `callback` Function. Callback when message is done being delivered.
  Optional.
-->

<ul>
<li><code>buf</code> Buffer object.  送信されるメッセージ</li>
<li><code>offset</code> Integer. メッセージの開始位置となるバッファ内のオフセット</li>
<li><code>length</code> Integer. メッセージのバイト長</li>
<li><code>port</code> Integer. 接続先のポート番号</li>
<li><code>address</code> String. 接続先の IP</li>
<li><code>callback</code> Function. メッセージの配信が完了した後にコールバックされる、
Optional.</li>
</ul>
<!--
For UDP sockets, the destination port and IP address must be specified.  A string
may be supplied for the `address` parameter, and it will be resolved with DNS.  An
optional callback may be specified to detect any DNS errors and when `buf` may be
re-used.  Note that DNS lookups will delay the time that a send takes place, at
least until the next tick.  The only way to know for sure that a send has taken place
is to use the callback.

If the socket has not been previously bound with a call to `bind`, it's
assigned a random port number and bound to the "all interfaces" address
(0.0.0.0 for `udp4` sockets, ::0 for `udp6` sockets).
-->

<p>UDP ソケット用です。相手先のポートと IP アドレスは必ず指定しなければなりません。
<code>address</code> パラメータに文字列を提供すると、それは DNS によって解決されます。
DNS エラーと <code>buf</code> が再利用可能になった時のためにオプションのコールバックを指定することができます。
DNS ルックアップは送信を少なくとも次の機会まで遅らせることに注意してください。
送信が行われたことを確実に知る唯一の手段はコールバックを使うことです。

</p>
<p>ソケットが以前に <code>bind</code> の呼び出しによってバインドされていない場合は、
ランダムなポート番号が「全てのインタフェース」アドレスに対してバインドされます
(<code>udp4</code> ソケットでは 0.0.0.0、<code>udp6</code> では ::0)。
<!--
Example of sending a UDP packet to a random port on `localhost`;
-->

</p>
<p><code>localhost</code> の適当なポートに UDP パケットを送信する例;

</p>
<pre><code>var dgram = require(&apos;dgram&apos;);
var message = new Buffer(&quot;Some bytes&quot;);
var client = dgram.createSocket(&quot;udp4&quot;);
client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err, bytes) {
  client.close();
});</code></pre>
<!--
**A Note about UDP datagram size**

The maximum size of an `IPv4/v6` datagram depends on the `MTU` (_Maximum Transmission Unit_)
and on the `Payload Length` field size.

- The `Payload Length` field is `16 bits` wide, which means that a normal payload
  cannot be larger than 64K octets including internet header and data
  (65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header);
  this is generally true for loopback interfaces, but such long datagrams
  are impractical for most hosts and networks.

- The `MTU` is the largest size a given link layer technology can support for datagrams.
  For any link, `IPv4` mandates a minimum `MTU` of `68` octets, while the recommended `MTU`
  for IPv4 is `576` (typically recommended as the `MTU` for dial-up type applications),
  whether they arrive whole or in fragments.

  For `IPv6`, the minimum `MTU` is `1280` octets, however, the mandatory minimum
  fragment reassembly buffer size is `1500` octets.
  The value of `68` octets is very small, since most current link layer technologies have
  a minimum `MTU` of `1500` (like Ethernet).

Note that it's impossible to know in advance the MTU of each link through which
a packet might travel, and that generally sending a datagram greater than
the (receiver) `MTU` won't work (the packet gets silently dropped, without
informing the source that the data did not reach its intended recipient).
-->

<p><strong>UDP データグラムのサイズについて</strong>

</p>
<p><code>IPv4/v6</code> データグラムの最大のサイズは <code>MTU</code> (<em>Maximum Transmission Unit</em>) と、
<code>Payload Length</code> フィールドサイズに依存します。

</p>
<ul>
<li><p><code>Payload Length</code> フィールドサイズは 16bit 長で、これは通常のペイロードが
IP ヘッダとデータ含めて 64K オクテットより長くなれないことを意味します
(65,507 バイト = 65,535 − 8 バイトの UDP ヘッダ − 20 バイトの IP ヘッダ);
これは一般的にループバックインタフェースでは正しいものの、
ほとんどのホストとネットワークにとって長大なデータグラムは
現実的ではありません。</p>
</li>
<li><p><code>MTU</code> はリンク層により大きなサイズを与える技術で、
データグラムもサポートできます。
どんなリンクでも、それらが全体として到着するか断片化されるかに関わらず、
<code>IPv4</code> は最低 <code>69</code> オクテット必要で、推奨される <code>IPv4</code> の <code>MTU</code> は <code>576</code> です
(典型的なダイヤルアップ型アプリケーションの <code>MUT</code> 推奨値)。</p>
<p><code>IPv6</code> では最小の <code>MTU</code> は <code>1280</code> オクテットですが、フラグメントを再構築する
バッファサイズは最低 <code>1500</code> オクテットが必要です。
<code>68</code> オクテットはとても小さいので、もっとも現代的なリンク層技術では、
最小の <code>MTU</code> は <code>1500</code> です (イーサネットと同じです)。</p>
</li>
</ul>
<p>パケットが通過する各リンクの MTU をあらかじめ知ることは
できないこと、(受信側の) <code>MTU</code> より大きなデータグラムを送信しても
通常は動作しないことに注意してください
(パケットは送り主に知らされることなく黙って捨てられ、
意図した受信者に到達することはありません)。


</p>
<h3>dgram.bind(port, [address])<span><a class="mark" href="#all_dgram_bind_port_address" id="all_dgram_bind_port_address">#</a></span></h3>
<div class="signature"><ul>
<li><code>port</code> Integer</li>
<li><code>address</code> String, Optional</li>
</div></ul>
<!--
For UDP sockets, listen for datagrams on a named `port` and optional `address`. If
`address` is not specified, the OS will try to listen on all addresses.
-->

<p>UDP ソケット用です。<code>port</code> とオプションの <code>address</code> でデータグラムを待ち受けます。
<code>address</code> が指定されなければ、OS は全てのアドレスからの待ち受けを試みます。

</p>
<!--
Example of a UDP server listening on port 41234:
-->

<p>41234 番ポートを待ち受ける UDP サーバの例:

</p>
<pre><code>var dgram = require(&quot;dgram&quot;);

var server = dgram.createSocket(&quot;udp4&quot;);

server.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;server got: &quot; + msg + &quot; from &quot; +
    rinfo.address + &quot;:&quot; + rinfo.port);
});

server.on(&quot;listening&quot;, function () {
  var address = server.address();
  console.log(&quot;server listening &quot; +
      address.address + &quot;:&quot; + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>
<h3>dgram.close()<span><a class="mark" href="#all_dgram_close" id="all_dgram_close">#</a></span></h3>
<!--
Close the underlying socket and stop listening for data on it.
-->

<p>下層のソケットをクローズし、データの待ち受けを終了します。

</p>
<h3>dgram.address()<span><a class="mark" href="#all_dgram_address" id="all_dgram_address">#</a></span></h3>
<!--
Returns an object containing the address information for a socket.  For UDP sockets,
this object will contain `address` and `port`.
-->

<p>オブジェクトが持っているソケットのアドレス情報を返します。
このオブジェクトは <code>address</code> と <code>port</code> を持っています。

</p>
<h3>dgram.setBroadcast(flag)<span><a class="mark" href="#all_dgram_setbroadcast_flag" id="all_dgram_setbroadcast_flag">#</a></span></h3>
<div class="signature"><ul>
<li><code>flag</code> Boolean</li>
</div></ul>
<!--
Sets or clears the `SO_BROADCAST` socket option.  When this option is set, UDP packets
may be sent to a local interface's broadcast address.
-->

<p>ソケットのオプション <code>SO_BROADCAST</code> を設定またはクリアします。
このオプションが設定されると、UDP パケットはローカルインタフェースのブロードキャスト用アドレスに送信されます。

</p>
<h3>dgram.setTTL(ttl)<span><a class="mark" href="#all_dgram_setttl_ttl" id="all_dgram_setttl_ttl">#</a></span></h3>
<div class="signature"><ul>
<li><code>ttl</code> Integer</li>
</div></ul>
<!--
Sets the `IP_TTL` socket option.  TTL stands for "Time to Live," but in this context it
specifies the number of IP hops that a packet is allowed to go through.  Each router or
gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a
router, it will not be forwarded.  Changing TTL values is typically done for network
probes or when multicasting.
-->

<p>ソケットオプションの <code>IP_TTL</code> を設定します。
TTL は「生存期間」を表しますが、このコンテキストではパケットが通過を許可される IP のホップ数を指定します。
各ルータまたはゲートウェイはパケットを送出する際 TTL をデクリメントします。
ルータによって TTL がデクリメントされて 0 になるとそれは送出されません。
TTL 値の変更は通常、ネットワークの調査やマルチキャストで使われます。

</p>
<!--
The argument to `setTTL()` is a number of hops between 1 and 255.  The default on most
systems is 64.
-->

<p><code>setTTL()</code> の引数は 1 から 255 のホップ数でです。ほとんどのシステムでデフォルトは 64 です。

</p>
<h3>dgram.setMulticastTTL(ttl)<span><a class="mark" href="#all_dgram_setmulticastttl_ttl" id="all_dgram_setmulticastttl_ttl">#</a></span></h3>
<div class="signature"><ul>
<li><code>ttl</code> Integer</li>
</div></ul>
<!--
Sets the `IP_MULTICAST_TTL` socket option.  TTL stands for "Time to Live," but in this
context it specifies the number of IP hops that a packet is allowed to go through,
specifically for multicast traffic.  Each router or gateway that forwards a packet
decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.

The argument to `setMulticastTTL()` is a number of hops between 0 and 255.  The default on most
systems is 64.
-->

<p><code>IP_MULTICAST_TTL</code> ソケットオプションを設定します。
TTL は「生存期間」を表しますが、この文脈では特にマルチキャストのトラフィックにおいてパケットが通過できるIPホップの数を指定します。
それぞれのルーターまたはゲートウェイは、パケットを転送する際に TTL をデクリメントします。
TTL がルーターによって 0 までデクリメントされると、それは転送されません。
<code>setMulticastTTL()</code> の引数はホップを表す数値で、0 から 255 の間です。
ほとんどのシステムでデフォルトは 64 です。

</p>
<h3>dgram.setMulticastLoopback(flag)<span><a class="mark" href="#all_dgram_setmulticastloopback_flag" id="all_dgram_setmulticastloopback_flag">#</a></span></h3>
<div class="signature"><ul>
<li><code>flag</code> Boolean</li>
</div></ul>
<!--
Sets or clears the `IP_MULTICAST_LOOP` socket option.  When this option is set, multicast
packets will also be received on the local interface.
-->

<p><code>IP_MULTICAST_LOOP</code> ソケットオプションを設定またはクリアします。
このオプションが設定されると、マルチキャストのパケットはローカルインタフェースでも受信できるようになります。

</p>
<h3>dgram.addMembership(multicastAddress, [multicastInterface])<span><a class="mark" href="#all_dgram_addmembership_multicastaddress_multicastinterface" id="all_dgram_addmembership_multicastaddress_multicastinterface">#</a></span></h3>
<div class="signature"><ul>
<li><code>multicastAddress</code> String</li>
<li><code>multicastInterface</code> String, Optional</li>
</div></ul>
<!--
Tells the kernel to join a multicast group with `IP_ADD_MEMBERSHIP` socket option.

If `multicastInterface` is not specified, the OS will try to add membership to all valid
interfaces.
-->

<p><code>IP_ADD_MEMBERSHIP</code> ソケットオプションを設定し、マルチキャストグループに参加することをカーネルに伝えます。

</p>
<p><code>multicastInterface</code> が指定されなかった場合は、全ての妥当なインタフェースをメンバーシップに加えようとします。

</p>
<h3>dgram.dropMembership(multicastAddress, [multicastInterface])<span><a class="mark" href="#all_dgram_dropmembership_multicastaddress_multicastinterface" id="all_dgram_dropmembership_multicastaddress_multicastinterface">#</a></span></h3>
<div class="signature"><ul>
<li><code>multicastAddress</code> String</li>
<li><code>multicastInterface</code> String, Optional</li>
</div></ul>
<!--
Opposite of `addMembership` - tells the kernel to leave a multicast group with
`IP_DROP_MEMBERSHIP` socket option. This is automatically called by the kernel
when the socket is closed or process terminates, so most apps will never need to call
this.

If `multicastInterface` is not specified, the OS will try to drop membership to all valid
interfaces.
-->

<p><code>addMembership</code> の反対です - <code>IP_DROP_MEMBERSHIP</code> ソケットオプションによって、マルチキャストグループから抜けることをカーネルに伝えます。
これはソケットのクローズ時やプロセスの終了時にカーネルによって自動的に呼び出されるため、ほとんどのアプリケーションはこれを呼び出す必要がありません。

</p>
<p><code>multicastInterface</code> が指定されなかった場合は、全ての妥当なインタフェースをメンバーシップから削除しようとします。

</p>
<h1>DNS<span><a class="mark" href="#all_dns" id="all_dns">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
Use `require('dns')` to access this module. All methods in the dns module
use C-Ares except for `dns.lookup` which uses `getaddrinfo(3)` in a thread
pool. C-Ares is much faster than `getaddrinfo` but the system resolver is
more constant with how other programs operate. When a user does
`net.connect(80, 'google.com')` or `http.get({ host: 'google.com' })` the
`dns.lookup` method is used. Users who need to do a large number of look ups
quickly should use the methods that go through C-Ares.
-->

<p>このモジュールにアクセスするには <code>require(&apos;dns&apos;)</code> を使用します。
dns モジュールの全てのメソッドは C-Ares を使用します。
ただし、<code>dns.lookup</code> はスレッドプール上で <code>getaddrinfo(3)</code> を使用します。
C-Ares は <code>getaddrinfo</code> よりずっと速いものの、
他のシステムと連携するにはシステムリゾルバの方が安定しています。
ユーザが <code>net.connect(80, &apos;google.com&apos;)</code> または
<code>http.get({ host: &apos;google.com&apos; })</code> を行った時、<code>dns.lookup</code>
メソッドが使われます。
多数のルックアップを素早く実行したいユーザは、
C-Ares を呼び出すメソッドを使用すべきです。

</p>
<!--
Here is an example which resolves `'www.google.com'` then reverse
resolves the IP addresses which are returned.
-->

<p>これは <code>&apos;www.google.com&apos;</code> を解決して、返された IP アドレスを逆引きで解決する例です。

</p>
<pre><code>var dns = require(&apos;dns&apos;);

dns.resolve4(&apos;www.google.com&apos;, function (err, addresses) {
  if (err) throw err;

  console.log(&apos;addresses: &apos; + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, domains) {
      if (err) {
        console.log(&apos;reverse for &apos; + a + &apos; failed: &apos; +
          err.message);
      } else {
        console.log(&apos;reverse for &apos; + a + &apos;: &apos; +
          JSON.stringify(domains));
      }
    });
  });
});</code></pre>
<h2>dns.lookup(domain, [family], callback)<span><a class="mark" href="#all_dns_lookup_domain_family_callback" id="all_dns_lookup_domain_family_callback">#</a></span></h2>
<!--
Resolves a domain (e.g. `'google.com'`) into the first found A (IPv4) or
AAAA (IPv6) record.
The `family` can be the integer `4` or `6`. Defaults to `null` that indicates
both Ip v4 and v6 address family.
-->

<p>ドメイン (例 <code>&apos;google.com&apos;</code>) を解決して最初に見つかった
A (IPv4) または AAAA (IPv6) レコードにします。
<code>family</code> は整数の <code>4</code> または <code>6</code> を指定することができます。
デフォルトは <code>null</code> で、IP v4 と v6 の両方をアドレスファミリーを意味します。

</p>
<!--
The callback has arguments `(err, address, family)`.  The `address` argument
is a string representation of a IP v4 or v6 address. The `family` argument
is either the integer 4 or 6 and denotes the family of `address` (not
necessarily the value initially passed to `lookup`).
-->

<p>コールバックは引数 <code>(err, address, family)</code> を持ちます。
<code>address</code> 引数は IP v4 または v6 アドレスを表現する文字列です。
<code>family</code> 引数は整数の 4 または 6 で、<code>address</code> のファミリーを意味します
(この値は必ずしも最初に <code>lookup</code> に渡す必要はありません)。


</p>
<h2>dns.resolve(domain, [rrtype], callback)<span><a class="mark" href="#all_dns_resolve_domain_rrtype_callback" id="all_dns_resolve_domain_rrtype_callback">#</a></span></h2>
<!--
Resolves a domain (e.g. `'google.com'`) into an array of the record types
specified by rrtype. Valid rrtypes are `'A'` (IPV4 addresses, default),
`'AAAA'` (IPV6 addresses), `'MX'` (mail exchange records), `'TXT'` (text
records), `'SRV'` (SRV records), `'PTR'` (used for reverse IP lookups),
`'NS'` (name server records) and `'CNAME'` (canonical name records).
-->

<p>ドメイン (例 <code>&apos;google.com&apos;</code>) を解決して <code>rrtype</code> で指定されたレコードタイプの配列にします。
妥当な <code>rrtype</code> は <code>&apos;A&apos;</code> (IPV4アドレス)、<code>&apos;AAAA&apos;</code> (IPV6アドレス)、
<code>&apos;MX&apos;</code> (mail exchangeレコード), <code>&apos;TXT&apos;</code> (テキストレコード)、
<code>&apos;SRV&apos;</code> (SRVレコード)、<code>&apos;PTR&apos;</code> (IP を逆引きでルックアップするために使われる)、
<code>&apos;NS&apos;</code> (ネームサーバレコード)、そして <code>&apos;CNAME&apos;</code> (別名レコード) です。

</p>
<!--
The callback has arguments `(err, addresses)`.  The type of each item
in `addresses` is determined by the record type, and described in the
documentation for the corresponding lookup methods below.
-->

<p>コールバックは引数 <code>(err, addresses)</code> を持ちます。
<code>addresses</code> の各要素の種類はレコードの種類によって決まり、
対応する後述のルックアップメソッドで記述されます。

</p>
<!--
On error, `err` would be an instanceof `Error` object, where `err.errno` is
one of the error codes listed below and `err.message` is a string describing
the error in English.
-->

<p>エラー発生時、<code>err</code> は <code>Error</code> オブジェクトのインスタンスであり、
<code>err.errno</code> は後述するエラーコードのいずれか、
<code>err.message</code> はエラーを英語で説明する文字列となります。


</p>
<h2>dns.resolve4(domain, callback)<span><a class="mark" href="#all_dns_resolve4_domain_callback" id="all_dns_resolve4_domain_callback">#</a></span></h2>
<!--
The same as `dns.resolve()`, but only for IPv4 queries (`A` records).
`addresses` is an array of IPv4 addresses (e.g.
`['74.125.79.104', '74.125.79.105', '74.125.79.106']`).
-->

<p><code>dns.resolve()</code> と同じですが、IPv4 アドレス (<code>A</code> レコード) だけを問い合わせます。
<code>addresses</code> は IPv4 アドレスの配列です (例<br />
<code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>)

</p>
<h2>dns.resolve6(domain, callback)<span><a class="mark" href="#all_dns_resolve6_domain_callback" id="all_dns_resolve6_domain_callback">#</a></span></h2>
<!--
The same as `dns.resolve4()` except for IPv6 queries (an `AAAA` query).
-->

<p>IPv6 (<code>AAAA</code> レコード) を問い合わせることを除いて <code>dns.resolve4()</code> と同じです。


</p>
<h2>dns.resolveMx(domain, callback)<span><a class="mark" href="#all_dns_resolvemx_domain_callback" id="all_dns_resolvemx_domain_callback">#</a></span></h2>
<!--
The same as `dns.resolve()`, but only for mail exchange queries (`MX` records).
-->

<p><code>dns.resolve()</code> と同じですが、mail exchange (<code>MX</code> レコード) だけを問い合わせます。

</p>
<!--
`addresses` is an array of MX records, each with a priority and an exchange
attribute (e.g. `[{'priority': 10, 'exchange': 'mx.example.com'},...]`).
-->

<p><code>addresses</code> は MX レコードの配列で、それぞれは priority と exchange の属性を持ちます
(例 <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>)。

</p>
<h2>dns.resolveTxt(domain, callback)<span><a class="mark" href="#all_dns_resolvetxt_domain_callback" id="all_dns_resolvetxt_domain_callback">#</a></span></h2>
<!--
The same as `dns.resolve()`, but only for text queries (`TXT` records).
`addresses` is an array of the text records available for `domain` (e.g.,
`['v=spf1 ip4:0.0.0.0 ~all']`).
-->

<p><code>dns.resolve()</code> と同じですが、テキスト (<code>TXT</code> レコード) だけを問い合わせます。
<code>addresses</code> は <code>domain</code> で利用可能なテキストレコードの配列です。
(例、<code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>)

</p>
<h2>dns.resolveSrv(domain, callback)<span><a class="mark" href="#all_dns_resolvesrv_domain_callback" id="all_dns_resolvesrv_domain_callback">#</a></span></h2>
<!--
The same as `dns.resolve()`, but only for service records (`SRV` records).
`addresses` is an array of the SRV records available for `domain`. Properties
of SRV records are priority, weight, port, and name (e.g.,
`[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]`).
-->

<p><code>dns.resolve()</code> と同じですが、サービスレコード (<code>SRV</code> レコード) だけを問い合わせます。
<code>addresses</code> は <code>domain</code> で利用可能な SRV レコードの配列です。
SRV レコードのプロパティは priority、weight、port、そして name です
(例 <code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>)。

</p>
<h2>dns.reverse(ip, callback)<span><a class="mark" href="#all_dns_reverse_ip_callback" id="all_dns_reverse_ip_callback">#</a></span></h2>
<!--
Reverse resolves an ip address to an array of domain names.
-->

<p>IP アドレスからドメイン名の配列へ逆引きで解決します。

</p>
<!--
The callback has arguments `(err, domains)`.
-->

<p>コールバックは引数 <code>(err, domains)</code> を持ちます。

</p>
<h2>dns.resolveNs(domain, callback)<span><a class="mark" href="#all_dns_resolvens_domain_callback" id="all_dns_resolvens_domain_callback">#</a></span></h2>
<!--
The same as `dns.resolve()`, but only for name server records (`NS` records).
`addresses` is an array of the name server records available for `domain`
(e.g., `['ns1.example.com', 'ns2.example.com']`).
-->

<p><code>dns.resolve()</code> と同じですが、ネームサーバレコード (<code>NS</code> レコード) 
だけを問い合わせます。
<code>address</code> は <code>domain</code> で利用可能なネームサーバレコードの配列です
(例 <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>)。

</p>
<h2>dns.resolveCname(domain, callback)<span><a class="mark" href="#all_dns_resolvecname_domain_callback" id="all_dns_resolvecname_domain_callback">#</a></span></h2>
<!--
The same as `dns.resolve()`, but only for canonical name records (`CNAME`
records). `addresses` is an array of the canonical name records available for
`domain` (e.g., `['bar.example.com']`).
-->

<p><code>dns.resolve()</code> と同じですが、別名レコード (<code>CNAME</code> レコード) 
だけを問い合わせます。
<code>address</code> は <code>domain</code> で利用可能な別名レコードの配列です
<code>domain</code> (e.g., <code>[&apos;bar.example.com&apos;]</code>)。

</p>
<!--
If there an an error, `err` will be non-null and an instanceof the Error
object.
-->

<p>エラーがあった場合、<code>err</code> は非 null で Error オブジェクトのインスタンスとなります。

</p>
<!--
Each DNS query can return an error code.
-->

<p>どの DNS 問い合わせもエラーコードを返せます。

</p>
<!--
- `dns.TEMPFAIL`: timeout, SERVFAIL or similar.
- `dns.PROTOCOL`: got garbled reply.
- `dns.NXDOMAIN`: domain does not exists.
- `dns.NODATA`: domain exists but no data of reqd type.
- `dns.NOMEM`: out of memory while processing.
- `dns.BADQUERY`: the query is malformed.
-->

<ul>
<li><code>dns.TEMPFAIL</code>: タイムアウト、SERVFAIL あるいは同様のもの。</li>
<li><code>dns.PROTOCOL</code>: 応答が不正。</li>
<li><code>dns.NXDOMAIN</code>: ドメインが存在しない。</li>
<li><code>dns.NODATA</code>: ドメインは存在するが、要求された種類のデータがない。</li>
<li><code>dns.NOMEM</code>: 処理中にメモリが不足。</li>
<li><code>dns.BADQUERY</code>: 問い合わせが不正な形式。</li>
</ul>
<h1>HTTP<span><a class="mark" href="#all_http" id="all_http">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
To use the HTTP server and client one must `require('http')`.
-->

<p>HTTP サーバおよびクライアントを使用するにはいずれも <code>require(&apos;http&apos;)</code> が必要です。

</p>
<!--
The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.
-->

<p>Node の HTTP インタフェースは、
伝統的に扱いが難しかったプロトコルの多くの機能をサポートするように設計されています。
とりわけ大きくて、場合によってはチャンク化されたメッセージです。
インタフェースは決してリクエストまたはレスポンス全体をバッファリングしないように気をつけています
－ 利用者はストリームデータを使うことができます。

</p>
<!--
HTTP message headers are represented by an object like this:
-->

<p>HTTP メッセージヘッダはこのようなオブジェクトとして表現されます:

</p>
<pre><code>{ &apos;content-length&apos;: &apos;123&apos;,
  &apos;content-type&apos;: &apos;text/plain&apos;,
  &apos;connection&apos;: &apos;keep-alive&apos;,
  &apos;accept&apos;: &apos;*/*&apos; }</code></pre>
<!--
Keys are lowercased. Values are not modified.
-->

<p>キーは小文字化されます。値は変更されません。

</p>
<!--
In order to support the full spectrum of possible HTTP applications, Node's
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.
-->

<p>考えられる HTTP アプリケーションを完全にサポートするために、
Node の HTTP API はとても低水準です。それはストリームのハンドリングとメッセージの解析だけに対処します。
解析はメッセージをヘッダとボディに分けますが、実際のヘッダとボディは解析しません。


</p>
<h2>http.createServer([requestListener])<span><a class="mark" href="#all_http_createserver_requestlistener" id="all_http_createserver_requestlistener">#</a></span></h2>
<!--
Returns a new web server object.
-->

<p>新しい Web サーバオブジェクトを返します。

</p>
<!--
The `requestListener` is a function which is automatically
added to the `'request'` event.
-->

<p><code>requestListener</code> は自動的に <code>&apos;request&apos;</code> イベントに加えられる関数です。

</p>
<h2>Class: http.Server<span><a class="mark" href="#all_class_http_server" id="all_class_http_server">#</a></span></h2>
<!--
This is an `EventEmitter` with the following events:
-->

<p>これは以下のイベントを持つ <code>EventEmitter</code> です:

</p>
<h3>Event: &apos;request&apos;<span><a class="mark" href="#all_event_request" id="all_event_request">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<!--
Emitted each time there is a request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).
-->

<p>リクエストの度に生成されます。
コネクションごとに複数のリクエストがあるかもしれないことに注意してください
(Keep Alive なコネクションの場合)。

</p>
<!--
 `request` is an instance of `http.ServerRequest` and `response` is
 an instance of `http.ServerResponse`
-->

<p><code>request</code> は <code>http.ServerRequest</code> のインスタンス、
<code>response</code> は <code>http.ServerResponse</code> のインスタンスです。

</p>
<h3>Event: &apos;connection&apos;<span><a class="mark" href="#all_event_connection_1" id="all_event_connection_1">#</a></span></h3>
<p><code>function (socket) { }</code>

</p>
<!--
 When a new TCP stream is established. `socket` is an object of type
 `net.Socket`. Usually users will not want to access this event. The
 `socket` can also be accessed at `request.connection`.
-->

<p>新しい TCP ストリームが確立した時。
<code>socket</code> は <code>net.Socket</code> 型のオブジェクトです。
通常の利用者がこのイベントにアクセスしたくなることはないでしょう。
<code>socket</code> は <code>request.connection</code> からアクセスすることもできます。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_5" id="all_event_close_5">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
 Emitted when the server closes.
-->

<p>サーバがクローズした時に生成されます。

</p>
<h3>Event: &apos;checkContinue&apos;<span><a class="mark" href="#all_event_checkcontinue" id="all_event_checkcontinue">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<!--
Emitted each time a request with an http Expect: 100-continue is received.
If this event isn't listened for, the server will automatically respond
with a 100 Continue as appropriate.
-->

<p>httpの Expect: 100-continue リクエストを受信する度に生成されます。
このイベントが監視されない場合、サーバは自動的に 100 Continue を応答します。

</p>
<!--
Handling this event involves calling `response.writeContinue` if the client
should continue to send the request body, or generating an appropriate HTTP
response (e.g., 400 Bad Request) if the client should not continue to send the
request body.
-->

<p>このイベントを処理する場合、クライアントがリクエストボディを送信し続けるべきなら
<code>response.writeContinue</code> を呼び出す必要があります。
あるいは、クライアントがリクエストボディを送信し続けるべきでないなら、
適切な HTTP レスポンス (例えば 400 Bad Request) を生成します。

</p>
<!--
Note that when this event is emitted and handled, the `request` event will
not be emitted.
-->

<p>このイベントが生成されて処理された場合、<code>request</code>イベントは生成されないことに注意してください。

</p>
<h3>Event: &apos;upgrade&apos;<span><a class="mark" href="#all_event_upgrade" id="all_event_upgrade">#</a></span></h3>
<p><code>function (request, socket, head) { }</code>

</p>
<!--
Emitted each time a client requests a http upgrade. If this event isn't
listened for, then clients requesting an upgrade will have their connections
closed.
-->

<p>クライアントが HTTP のアップグレードを要求する度に生成されます。
このイベントが監視されない場合、アップグレードを要求したクライアントのコネクションはクローズされます。

</p>
<!--
* `request` is the arguments for the http request, as it is in the request event.
* `socket` is the network socket between the server and client.
* `head` is an instance of Buffer, the first packet of the upgraded stream, this may be empty.
-->

<ul>
<li><code>request</code> はリクエストイベントと同様に HTTP リクエストへの引数です。</li>
<li><code>socket</code> はサーバとクライアントの間のネットワークソケットです。</li>
<li><code>head</code> はアップグレードストリームの最初のパケットを持つ Buffer のインスタンスです。
空の場合もあります。</li>
</ul>
<!--
After this event is emitted, the request's socket will not have a `data`
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.
-->

<p>このイベントが生成された後、リクエスト元のソケットはもう <code>data</code> イベントリスナーを持ちません。
このソケットでサーバへ送られたデータを扱うためにそれをバインドしなければならないことを意味します。

</p>
<h3>Event: &apos;clientError&apos;<span><a class="mark" href="#all_event_clienterror_1" id="all_event_clienterror_1">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<!--
If a client connection emits an 'error' event - it will forwarded here.
-->

<p>クライアントコネクションが &apos;error&apos; イベントを発した場合 － ここに転送されます。

</p>
<h3>server.listen(port, [hostname], [callback])<span><a class="mark" href="#all_server_listen_port_hostname_callback" id="all_server_listen_port_hostname_callback">#</a></span></h3>
<!--
Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (`INADDR_ANY`).
-->

<p>指定されたポートとホスト名でコネクションの受け入れを開始します。
ホスト名が省略されると、サーバはどんな IPv4 アドレスへの接続も受け入れます (<code>INADDR_ANY</code>)。

</p>
<!--
To listen to a unix socket, supply a filename instead of port and hostname.
-->

<p>UNIX ドメインソケットを待ち受ける場合、ポートとホスト名ではなくファイル名を提供します。

</p>
<!--
This function is asynchronous. The last parameter `callback` will be added as
a listener for the ['listening'](net.html#event_listening_) event.
See also [net.Server.listen()](net.html#server.listen).
-->

<p>この関数は非同期です。最後の引数の <code>callback</code> は
<a href="net.html#event_listening_">&apos;listening&apos;</a> イベントのリスナとして加えられます。
詳細は <a href="net.html#server.listen">net.Server.listen()</a> を参照してください。


</p>
<h3>server.listen(path, [callback])<span><a class="mark" href="#all_server_listen_path_callback" id="all_server_listen_path_callback">#</a></span></h3>
<!--
Start a UNIX socket server listening for connections on the given `path`.
-->

<p><code>path</code> で与えられたコネクションを待ち受ける UNIX ドメインソケットのサーバを開始します。

</p>
<!--
This function is asynchronous. The last parameter `callback` will be added as
a listener for the ['listening'](net.html#event_listening_) event.
See also [net.Server.listen()](net.html#server.listen).
-->

<p>この関数は非同期です。最後の引数の <code>callback</code> は
<a href="net.html#event_listening_">&apos;listening&apos;</a> イベントのリスナとして加えられます。
詳細は <a href="net.html#server.listen">net.Server.listen()</a> を参照してください。


</p>
<h3>server.close()<span><a class="mark" href="#all_server_close_2" id="all_server_close_2">#</a></span></h3>
<!--
Stops the server from accepting new connections.
See [net.Server.close()](net.html#server.close).
-->

<p>サーバが新しいコネクションを受け付けるのを終了します。


</p>
<h2>Class: http.ServerRequest<span><a class="mark" href="#all_class_http_serverrequest" id="all_class_http_serverrequest">#</a></span></h2>
<!--
This object is created internally by a HTTP server -- not by
the user -- and passed as the first argument to a `'request'` listener.
-->

<p>このオブジェクトは HTTP サーバ内部 － ユーザではなく － で作成され、
<code>&apos;request&apos;</code> リスナーの第1引数として渡されます。

</p>
<!--
The request implements the [Readable Stream](stream.html#readable_stream)
interface. This is an `EventEmitter` with the following events:
-->

<p>リクエストは <a href="stream.html#readable_Stream">Readable Stream</a>
インタフェースを実装します。
これは以下のイベントを持つ <code>EventEmitter</code> です:

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_2" id="all_event_data_2">#</a></span></h3>
<p><code>function (chunk) { }</code>

</p>
<!--
Emitted when a piece of the message body is received. The chunk is a string if
an encoding has been set with `request.setEncoding()`, otherwise it's a
[Buffer](buffer.html).
-->

<p>メッセージボディの断片を受信した場合に生成されます。
<code>request.setEncoding()</code> によってエンコーディングが設定された場合、
<code>chunk</code> は文字列です。それ以外の場合は <a href="buffer.html">Buffer</a> です。

</p>
<!--
Example: A chunk of the body is given as the single
argument. The transfer-encoding has been decoded.  The
body chunk is a string.  The body encoding is set with
`request.setEncoding()`.

Note that the __data will be lost__ if there is no listener when a
`ServerRequest` emits a `'data'` event.
-->

<p>例: 一つの引数としてボディのチャンクが与えられます。
転送エンコーディングでデコードされます。
ボディのチャンクは文字列です。
ボディのエンコーディングは <code>request.setBodyEncoding()</code> で設定されます。

</p>
<p><code>ServerRequest</code> が <code>&apos;data&apos;</code> イベントを生成した時にリスナが存在しなければ、
<strong>データは失われる</strong>ことに注意してください。

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_2" id="all_event_end_2">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Emitted exactly once for each request. After that, no more `'data'` events
will be emitted on the request.
-->

<p>リクエストごとに厳密に一回生成されます。
その後、このリクエストで <code>&apos;data&apos;</code> イベントが生成されることはありません。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_6" id="all_event_close_6">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Indicates that the underlaying connection was terminated before
`response.end()` was called or able to flush.
-->

<p><code>response.end()</code> が呼び出されたりフラッシュされる前に、
下層の接続が切断されたことを示します。

</p>
<!--
Just like `'end'`, this event occurs only once per request, and no more `'data'`
events will fire afterwards.
-->

<p><code>&apos;end&apos;</code> と同様、このイベントはリクエスト上で一度だけ発生し、その後ではもう
<code>&apos;data&apos;</code> イベントが発生することはありません。

</p>
<!--
Note: `'close'` can fire after `'end'`, but not vice versa.
-->

<p>注意: <code>&apos;close&apos;</code> は <code>&apos;end&apos;</code> の後で発生することがあります。
その逆もあります。

</p>
<h3>request.method<span><a class="mark" href="#all_request_method" id="all_request_method">#</a></span></h3>
<!--
The request method as a string. Read only. Example:
`'GET'`, `'DELETE'`.
-->

<p>リクエストメソッドを表す文字列です。参照のみ可能です。
例: <code>&apos;GET&apos;</code>、<code>&apos;DELETE&apos;</code>


</p>
<h3>request.url<span><a class="mark" href="#all_request_url" id="all_request_url">#</a></span></h3>
<!--
Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:
-->

<p>リクエスト URL を表す文字列です。
これは実際の HTTP リクエストに存在する URL だけを含みます。
リクエストがこうなら:

</p>
<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>
<!--
Then `request.url` will be:
-->

<p>この場合の <code>request.url</code> はこうなります:

</p>
<pre><code>&apos;/status?name=ryan&apos;</code></pre>
<!--
If you would like to parse the URL into its parts, you can use
`require('url').parse(request.url)`.  Example:
-->

<p>URL の要素を解析したい場合は、
<code>require(&apos;url&apos;).parse(request.url)</code> を参照してください。例:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: &apos;name=ryan&apos;,
  pathname: &apos;/status&apos; }</code></pre>
<!--
If you would like to extract the params from the query string,
you can use the `require('querystring').parse` function, or pass
`true` as the second argument to `require('url').parse`.  Example:
-->

<p>問い合わせ文字列からパラメータを取り出したい場合は、
<code>require(&apos;querystring&apos;).parse</code> 関数を参照するか、
<code>require(&apos;url&apos;).parse</code> の第 2 引数に <code>true</code> を渡してください。例:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;, true)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: { name: &apos;ryan&apos; },
  pathname: &apos;/status&apos; }</code></pre>
<h3>request.headers<span><a class="mark" href="#all_request_headers" id="all_request_headers">#</a></span></h3>
<!--
Read only.
-->

<p>参照のみ可能です。

</p>
<h3>request.trailers<span><a class="mark" href="#all_request_trailers" id="all_request_trailers">#</a></span></h3>
<!--
Read only; HTTP trailers (if present). Only populated after the 'end' event.
-->

<p>参照のみ可能です; HTTP のトレーラです (もしあれば)。&apos;end&apos; イベントの後にだけ発生します。

</p>
<h3>request.httpVersion<span><a class="mark" href="#all_request_httpversion" id="all_request_httpversion">#</a></span></h3>
<!--
The HTTP protocol version as a string. Read only. Examples:
`'1.1'`, `'1.0'`.
Also `request.httpVersionMajor` is the first integer and
`request.httpVersionMinor` is the second.
-->

<p>HTTP プロトコルのバージョンを表す文字列です。参照のみ可能です。例:
<code>&apos;1.1&apos;</code>、<code>&apos;1.0&apos;</code>。
同様に <code>request.httpVersionMajor</code> は最初の整数、
<code>request.httpVersionMinor</code> は 2 番目の整数です。


</p>
<h3>request.setEncoding([encoding])<span><a class="mark" href="#all_request_setencoding_encoding" id="all_request_setencoding_encoding">#</a></span></h3>
<!--
Set the encoding for the request body. Either `'utf8'` or `'binary'`. Defaults
to `null`, which means that the `'data'` event will emit a `Buffer` object..
-->

<p>リクエストボディのエンコーディングを設定します。
<code>&apos;utf8&apos;</code> または <code>&apos;binary&apos;</code> のいずれかです。
デフォルトは <code>null</code> で、<code>&apos;data&apos;</code> イベントが
<code>Buffer</code> を生成することを意味します。


</p>
<h3>request.pause()<span><a class="mark" href="#all_request_pause" id="all_request_pause">#</a></span></h3>
<!--
Pauses request from emitting events.  Useful to throttle back an upload.
-->

<p>リクエストによるイベントの生成を中断します。アップロード速度を落とすのに便利です。


</p>
<h3>request.resume()<span><a class="mark" href="#all_request_resume" id="all_request_resume">#</a></span></h3>
<!--
Resumes a paused request.
-->

<p>中断されたリクエストを再開します。

</p>
<h3>request.connection<span><a class="mark" href="#all_request_connection" id="all_request_connection">#</a></span></h3>
<!--
The `net.Socket` object associated with the connection.
-->

<p>コネクションに関連づけられた <code>net.Socket</code> オブジェクトです。


</p>
<!--
With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client's
authentication details.
-->

<p>HTTPS では <code>request.connection.verifyPeer()</code> と
<code>request.connection.getPeerCertificate()</code> で
クライアントの認証の詳細を取得できます。



</p>
<h2>Class: http.ServerResponse<span><a class="mark" href="#all_class_http_serverresponse" id="all_class_http_serverresponse">#</a></span></h2>
<!--
This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the `'request'` event.

The response implements the [Writable  Stream](stream.html#writable_stream)
interface. This is an `EventEmitter` with the following events:
-->

<p>このオブジェクトは HTTP サーバ内部 － ユーザではなく － で作成されます。
<code>&apos;request&apos;</code> リスナーの第 2 引数として渡されます。

</p>
<p>レスポンスは <a href="stream.html#writable_Stream">Writable  Stream</a>
インタフェースを実装します。
これは以下のイベントを持つ <code>EventEmitter</code> です:

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_7" id="all_event_close_7">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Indicates that the underlaying connection was terminated before
`response.end()` was called or able to flush.
-->

<p><code>response.end()</code> が呼び出されたりフラッシュされる前に、
下層の接続が切断されたことを示します。

</p>
<h3>response.writeContinue()<span><a class="mark" href="#all_response_writecontinue" id="all_response_writecontinue">#</a></span></h3>
<!--
Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the [checkContinue](#event_checkContinue_) event on
`Server`.
-->

<p>HTTP/1.1 の 100 Continue メッセージをクライアントに送信し、
リクエストボディを送信してもよいことを示します。
<code>Server</code>の <a href="#event_checkContinue_">checkContinue</a> イベントを参照してください。

</p>
<h3>response.writeHead(statusCode, [reasonPhrase], [headers])<span><a class="mark" href="#all_response_writehead_statuscode_reasonphrase_headers" id="all_response_writehead_statuscode_reasonphrase_headers">#</a></span></h3>
<!--
Sends a response header to the request. The status code is a 3-digit HTTP
status code, like `404`. The last argument, `headers`, are the response headers.
Optionally one can give a human-readable `reasonPhrase` as the second
argument.
-->

<p>レスポンスヘッダを送信します。
ステータスコードは <code>404</code> のような 3 桁の数字による HTTP ステータスコードです。
最後の引数 <code>headers</code> は、レスポンスヘッダです。
オプションとして人に読める形式の <code>reasonPhrase</code> を第 2 引数で与えることができます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var body = &apos;hello world&apos;;
response.writeHead(200, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
<!--
This method must only be called once on a message and it must
be called before `response.end()` is called.

If you call `response.write()` or `response.end()` before calling this, the
implicit/mutable headers will be calculated and call this function for you.
-->

<p>このメソッドはメッセージごとに 1 回だけ呼び出されなくてはならず、
<code>response.end()</code> の前に呼び出されなければなりません。

</p>
<p>もしこのメソッドが呼び出される前に <code>response.write()</code> または <code>response.end()</code> が呼ばれると、暗黙的で可変のヘッダが算出されてこの関数が呼び出されます。

</p>
<!--
Note: that Content-Length is given in bytes not characters. The above example
works because the string `'hello world'` contains only single byte characters.
If the body contains higher coded characters then `Buffer.byteLength()`
should be used to determine the number of bytes in a given encoding.
And Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.
-->

<p>注意: <code>Content-Length</code> は文字数ではなくバイト数で与えられます。
上の例が動作するのは <code>&apos;hello world&apos;</code> という文字列が単一バイト文字だけを含むためです。
もしボディがより上位にコード化された文字を含む場合は、
指定したエンコーディングによるバイト数を得るために <code>Buffer.byteLength()</code> を使うべきです。
Node は、Content-Length と実際に送信されたレスポンスボディの長さが等しいかどうかチェックしません。

</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode" id="all_response_statuscode">#</a></span></h3>
<!--
When using implicit headers (not calling `response.writeHead()` explicitly), this property
controls the status code that will be send to the client when the headers get
flushed.
-->

<p>(<code>response.writeHead()</code> が明示的に呼ばれないために) 暗黙的なヘッダが使われる場合、このプロパティはヘッダがフラッシュされる時にクライアントへ送信されるステータスコードを制御します。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>response.statusCode = 404;</code></pre>
<!--
After response header was sent to the client, this property indicates the
status code which was sent out.
-->

<p>レスポンスヘッダがクライアントに送信された後、
このプロパティは送信されたステータスコードを示します。

</p>
<h3>response.setHeader(name, value)<span><a class="mark" href="#all_response_setheader_name_value" id="all_response_setheader_name_value">#</a></span></h3>
<!--
Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, its value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.
-->

<p>暗黙的ヘッダのヘッダ値を設定します。
送信されようとしているレスポンスヘッダにこのヘッダが既に含まれている場合、
その値は置き換えられます。
同じ名前で複数のヘッダを送信したい場合は文字列の配列を使ってください。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
<p>or

</p>
<pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
<h3>response.getHeader(name)<span><a class="mark" href="#all_response_getheader_name" id="all_response_getheader_name">#</a></span></h3>
<!--
Reads out a header that's already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.
-->

<p>すでにキューに入れられているが未送信のヘッダを読み上げます．
名前は大文字小文字を区別しないことに注意してください。
これはヘッダが暗黙的にフラッシュされる前だけ呼び出すことができます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>
<h3>response.removeHeader(name)<span><a class="mark" href="#all_response_removeheader_name" id="all_response_removeheader_name">#</a></span></h3>
<!--
Removes a header that's queued for implicit sending.
-->

<p>暗黙的に送信するためキューに入れられたヘッダを削除します。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
<h3>response.write(chunk, [encoding])<span><a class="mark" href="#all_response_write_chunk_encoding" id="all_response_write_chunk_encoding">#</a></span></h3>
<!--
If this method is called and `response.writeHead()` has not been called, it will
switch to implicit header mode and flush the implicit headers.

This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.
-->

<p>このメソッドが呼び出され、<code>response.writeHead()</code> が呼び出されなければ、
暗黙的ヘッダモードに切り替わり、暗黙的ヘッダはフラッシュされます。

</p>
<p>これはレスポンスボディのチャンクを送信します。
このメソッドはボディの連続した部分を提供するために複数回呼び出されるかもしれません。

</p>
<!--
`chunk` can be a string or a buffer. If `chunk` is a string,
the second parameter specifies how to encode it into a byte stream.
By default the `encoding` is `'utf8'`.
-->

<p><code>chunk</code> は文字列またはバッファにすることができます。
<code>chunk</code> が文字列の場合、どのエンコードでバイトストリームにするかを第 2 引数で指定します。
デフォルトの <code>encoding</code> は <code>&apos;utf8&apos;</code> です。

</p>
<!--
**Note**: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.
-->

<p><strong>注意</strong>: これは生の HTTP ボディで、
高水準のマルチパートボディエンコーディングで使われるものとは無関係です。

</p>
<!--
The first time `response.write()` is called, it will send the buffered
header information and the first body to the client. The second time
`response.write()` is called, Node assumes you're going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.
-->

<p>初めて <code>response.write()</code> が呼び出されると、
バッファリングされていたヘッダ情報と最初のボディがクライアントに送信されます。
2 回目に <code>response.write()</code> が呼ばれると、
Node はストリーミングデータを分割して送信しようとしていると仮定します。
すなわち、レスポンスはボディの最初のチャンクまでバッファリングされます。

</p>
<h3>response.addTrailers(headers)<span><a class="mark" href="#all_response_addtrailers_headers" id="all_response_addtrailers_headers">#</a></span></h3>
<!--
This method adds HTTP trailing headers (a header but at the end of the
message) to the response.
-->

<p>このメソッドは HTTP トレーラヘッダ (メッセージの最後に置かれるヘッダ) をレスポンスに追加します。

</p>
<!--
Trailers will **only** be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.
-->

<p>トレーラはレスポンスがチャンク化されたエンコーディングで<strong>のみ</strong>生成されます;
そうでなければ (例えばリクエストが HTTP/1.0)、黙って破棄されます。

</p>
<!--
Note that HTTP requires the `Trailer` header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,
-->

<p>HTTP は、トレーラを生成するならそのヘッダフィールドのリストを値として
<code>Trailer</code> ヘッダを送信することを要求していることに注意してください。

</p>
<pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,
                          &apos;Trailer&apos;: &apos;Content-MD5&apos; });
response.write(fileData);
response.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();</code></pre>
<h3>response.end([data], [encoding])<span><a class="mark" href="#all_response_end_data_encoding" id="all_response_end_data_encoding">#</a></span></h3>
<!--
This method signals to the server that all of the response headers and body
has been sent; that server should consider this message complete.
The method, `response.end()`, MUST be called on each
response.
-->

<p>このメソッドはレスポンスの全てのヘッダとボディを送信したことをサーバに伝えます;
サーバはメッセージが終了したと考えるべきです。
この <code>response.end()</code> メソッドは各レスポンスごとに呼び出さなければ<em>なりません</em>。

</p>
<!--
If `data` is specified, it is equivalent to calling `response.write(data, encoding)`
followed by `response.end()`.
-->

<p><code>data</code> が指定された場合、
<code>response.write(data, encoding)</code> に続けて <code>response.end()</code> を呼び出すのと等価です。


</p>
<h2>http.request(options, callback)<span><a class="mark" href="#all_http_request_options_callback" id="all_http_request_options_callback">#</a></span></h2>
<!--
Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.  `options` align
with [url.parse()](url.html#url.parse).
-->

<p>Node は HTTP リクエストを行うために、サーバごとにいくつかのコネクションを保持します。
この関数はその一つを使って透過的にリクエストを発行できるようにします。

</p>
<!--
Options:
-->

<p>オプション:

</p>
<!--
- `host`: A domain name or IP address of the server to issue the request to.
  Defaults to `'localhost'`.
- `hostname`: To support `url.parse()` `hostname` is preferred over `host`
- `port`: Port of remote server. Defaults to 80.
- `socketPath`: Unix Domain Socket (use one of host:port or socketPath)
- `method`: A string specifying the HTTP request method. Defaults to `'GET'`.
- `path`: Request path. Defaults to `'/'`. Should include query string if any.
  E.G. `'/index.html?page=12'`
- `headers`: An object containing request headers.
- `auth`: Basic authentication i.e. `'user:password'` to compute an
  Authorization header.
- `agent`: Controls [Agent](#http.Agent) behavior. When an Agent is used
  request will default to `Connection: keep-alive`. Possible values:
 - `undefined` (default): use [global Agent](#http.globalAgent) for this host
   and port.
 - `Agent` object: explicitly use the passed in `Agent`.
 - `false`: opts out of connection pooling with an Agent, defaults request to
   `Connection: close`.
-->

<ul>
<li><code>host</code>: リクエストを発行するサーバのドメイン名または IP アドレス。</li>
<li><code>hostname</code>: <code>url.parse()</code> サポート。<code>hostname</code> は <code>host</code> を上書きします。</li>
<li><code>port</code>: リモートサーバのポート。デフォルトは 80 です。</li>
<li><code>socketPath</code>: Unix ドメインソケット (host:port または socketPath のどちらか)</li>
<li><code>method</code>: HTTP リクエストのメソッドの文字列。デフォルトは <code>&apos;GET&apos;</code> です。</li>
<li><code>path</code>: リクエストのパス。デフォルトは <code>&apos;/&apos;</code> です。
必要なら問い合わせ文字列を含めるべきです．
例 <code>&apos;/index.html?page=12&apos;</code></li>
<li><code>headers</code>: リクエストヘッダを含むオブジェクト。</li>
<li><code>auth</code>: ベーシック認証すなわち Authorization ヘッダのための
<code>&apos;user:password&apos;</code>。</li>
<li><code>agent</code>: <code>Agent</code> の振る舞いを制御します。
エージェントが使われる場合、Connection:keep-alive がデフォルトになります。
可能な値は:<ul>
<li><code>undefined</code> (デフォルト): ホストとポートで
<a href="#http.globalAgent">グローバル Agent</a> を使用します。</li>
<li><code>Agent</code> オブジェクト: 明示的に渡された <code>Agent</code> を使用します。</li>
<li><code>false</code>: Agent によるコネクションプーリングを使用しません。
 Connection:close の場合のデフォルトです。</li>
</ul>
</li>
</ul>
<!--
`http.request()` returns an instance of the `http.ClientRequest`
class. The `ClientRequest` instance is a writable stream. If one needs to
upload a file with a POST request, then write to the `ClientRequest` object.
-->

<p><code>http.request()</code> は <code>http.ClientRequest</code> クラスのインスタンスを返します。
<code>http.ClientRequest</code> のインスタンスは書き込み可能なストリームです。
もし POST リクエストでファイルのアップロードがしたければ、
<code>http.ClientRequest</code> オブジェクトに出力してください。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/upload&apos;,
  method: &apos;POST&apos;
};

var req = http.request(options, function(res) {
  console.log(&apos;STATUS: &apos; + res.statusCode);
  console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers));
  res.setEncoding(&apos;utf8&apos;);
  res.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

req.on(&apos;error&apos;, function(e) {
  console.log(&apos;problem with request: &apos; + e.message);
});

// write data to request body
req.write(&apos;data\n&apos;);
req.write(&apos;data\n&apos;);
req.end();</code></pre>
<!--
Note that in the example `req.end()` was called. With `http.request()` one
must always call `req.end()` to signify that you're done with the request -
even if there is no data being written to the request body.
-->

<p>この例で <code>req.end()</code> が呼ばれていることに注意してください。
<code>http.request()</code> では、リクエストが終了したことを示すために、
常に <code>req.end()</code> を呼び出さなければなりません
- リクエストのボディに出力するデータがなかったとしても。

</p>
<!--
If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an `'error'` event is emitted
on the returned request object.
-->

<p>リクエスト中に何らかのエラー (DNS 解決、TCP レベルのエラー、HTTP パースエラーなど) が発生すると、戻り値のリクエストオブジェクトで <code>&apos;error&apos;</code> イベントが生成されます。


</p>
<!--
There are a few special headers that should be noted.
-->

<p>いくつかの特別なヘッダに注意が必要です。

</p>
<!--
* Sending a 'Connection: keep-alive' will notify Node that the connection to
  the server should be persisted until the next request.

* Sending a 'Content-length' header will disable the default chunked encoding.

* Sending an 'Expect' header will immediately send the request headers.
  Usually, when sending 'Expect: 100-continue', you should both set a timeout
  and listen for the `continue` event. See RFC2616 Section 8.2.3 for more
  information.

* Sending an Authorization header will override using the `auth` option
  to compute basic authentication.
-->

<ul>
<li><p>&apos;Connection: keep-alive&apos; の送信は、サーバへのコネクションを次のリクエストまで持続することを Node に通知します。</p>
</li>
<li><p>&apos;Content-length&apos; ヘッダの送信は、デフォルトのチャンクエンコーディングを無効にします。</p>
</li>
<li><p>&apos;Expect&apos; ヘッダの送信は、リクエストヘッダを即時に送信します。
通常、&apos;Expect: 100-continue&apos; を送信すると、タイムアウトと <code>continue</code> イベントを待ち受けます。詳細は RFC2616 の 8.2.3 節を参照してください。</p>
</li>
<li><p>Authorization ヘッダの送信は、<code>auth</code> オプションによるベーシック認証を
上書きします。</p>
</li>
</ul>
<h2>http.get(options, callback)<span><a class="mark" href="#all_http_get_options_callback" id="all_http_get_options_callback">#</a></span></h2>
<!--
Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and `http.request()` is
that it sets the method to GET and calls `req.end()` automatically.
-->

<p>ほとんどのリクエストは本文のない GET リクエストであるため、
Node は便利なメソッドを提供します。
このメソッドと <code>http.request()</code> の間の違いは、メソッドを GET に設定して <code>req.end()</code> を自動的に呼び出すことだけです。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/index.html&apos;
};

http.get(options, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&apos;error&apos;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});</code></pre>
<h2>Class: http.Agent<span><a class="mark" href="#all_class_http_agent" id="all_class_http_agent">#</a></span></h2>
<!--
In node 0.5.3+ there is a new implementation of the HTTP Agent which is used
for pooling sockets used in HTTP client requests.

Previously, a single agent instance help the pool for single host+port. The
current implementation now holds sockets for any number of hosts.

The current HTTP Agent also defaults client requests to using
Connection:keep-alive. If no pending HTTP requests are waiting on a socket
to become free the socket is closed. This means that node's pool has the
benefit of keep-alive when under load but still does not require developers
to manually close the HTTP clients using keep-alive.

Sockets are removed from the agent's pool when the socket emits either a
"close" event or a special "agentRemove" event. This means that if you intend
to keep one HTTP request open for a long time and don't want it to stay in the
pool you can do something along the lines of:
-->

<p>Node 0.5.3 以降には、HTTP クライアントリクエストのソケットを
プーリングするために新しい HTTP Agent の実装が存在します。

</p>
<p>以前は、エージェントの一つのインスタンスが一つのホスト + ポートのプールを
助けていましたが、現在の実装では任意の数のホストに対するソケットを
保持できるようになりました。

</p>
<p>現在の HTTP Agent では、クライアントリクエストはデフォルトで
Connection:keep-alive を使うようにもなりました。
ソケットを待ってペンディングになっている HTTP リクエストがなければ、
ソケットはクローズされます。
これは、node のプールは高負荷時に keep-alive のメリットを持ちながら、
keep-alive を使用する HTTP クライアントを開発者が手動でクローズする
必要がないことを意味します。

</p>
<p>ソケットは <code>&apos;close&apos;</code> イベントまたは特別な <code>&apos;agentRemove&apos;</code> イベントが
生成された時にエージェントのプールから削除されます。
これは、一つの HTTP リクエストを長時間オープンしたままにするために、
プールにソケットがとどまらないことを意図するなら、
以下のようにすることができることを意味します:

</p>
<pre><code>http.get(options, function(res) {
  // Do stuff
}).on(&quot;socket&quot;, function (socket) {
  socket.emit(&quot;agentRemove&quot;);
});</code></pre>
<!--
Alternatively, you could just opt out of pooling entirely using `agent:false`:
-->

<p>別の方法として、 <code>agent: false</code> を指定することで、
プーリングを使用しないこともできます:

</p>
<pre><code>http.get({host:&apos;localhost&apos;, port:80, path:&apos;/&apos;, agent:false}, function (res) {
  // Do stuff
})</code></pre>
<h3>agent.maxSockets<span><a class="mark" href="#all_agent_maxsockets" id="all_agent_maxsockets">#</a></span></h3>
<!--
By default set to 5. Determines how many concurrent sockets the agent can have 
open per host.
-->

<p>デフォルトでは 5 に設定されます。
エージェントがいくつのソケットを並行にオープンするかを決定します。

</p>
<h3>agent.sockets<span><a class="mark" href="#all_agent_sockets" id="all_agent_sockets">#</a></span></h3>
<!--
An object which contains arrays of sockets currently in use by the Agent. Do not 
modify.
-->

<p>エージェントが現在使っているソケットの配列です。
変更しないでください。

</p>
<h3>agent.requests<span><a class="mark" href="#all_agent_requests" id="all_agent_requests">#</a></span></h3>
<!--
An object which contains queues of requests that have not yet been assigned to 
sockets. Do not modify.
-->

<p>まだソケットが割り当てられていないリクエストのキューを含むオブジェクトです。
変更しないでください。

</p>
<h2>http.globalAgent<span><a class="mark" href="#all_http_globalagent" id="all_http_globalagent">#</a></span></h2>
<!--
Global instance of Agent which is used as the default for all http client
requests.
-->

<p>全ての HTTP クライアントリクエストでデフォルトとして使用される、
Agent のインスタンスです。


</p>
<h2>Class: http.ClientRequest<span><a class="mark" href="#all_class_http_clientrequest" id="all_class_http_clientrequest">#</a></span></h2>
<!--
This object is created internally and returned from `http.request()`.  It
represents an _in-progress_ request whose header has already been queued.  The
header is still mutable using the `setHeader(name, value)`, `getHeader(name)`,
`removeHeader(name)` API.  The actual header will be sent along with the first
data chunk or when closing the connection.
-->

<p>このオブジェクトは HTTP サーバ内部で作成され、<code>http.request()</code> から返されます。
それはヘッダがキューに入れられた <em>進行中</em> のリクエストを表現します。
ヘッダは <code>setHeader(name, value)</code>, <code>getHeader(name)</code>, <code>removeHeader(name)</code> API によってまだ可変のままです。
実際にヘッダが送信されるのは、最初のデータチャンクが送信される時またはコネクションがクローズされる時です。

</p>
<!--
To get the response, add a listener for `'response'` to the request object.
`'response'` will be emitted from the request object when the response
headers have been received.  The `'response'` event is executed with one
argument which is an instance of `http.ClientResponse`.
-->

<p>レスポンスを取得するには、<code>&apos;response&apos;</code> 用のリスナーをリクエストオブジェクトに加えます。
<code>&apos;response&apos;</code> イベントはレスポンスヘッダを受信するとリクエストオブジェクトによって生成されます。
<code>&apos;response&apos;</code> イベントは <code>http.ClientResponse</code> のインスタンスを唯一の引数として実行されます。

</p>
<!--
During the `'response'` event, one can add listeners to the
response object; particularly to listen for the `'data'` event. Note that
the `'response'` event is called before any part of the response body is received,
so there is no need to worry about racing to catch the first part of the
body. As long as a listener for `'data'` is added during the `'response'`
event, the entire body will be caught.
-->

<p><code>&apos;response&apos;</code> イベントの間、レスポンスオブジェクトにリスナーを加えることができます;
とりわけ <code>&apos;data&apos;</code> イベントのリスナーです。
<code>&apos;response&apos;</code> イベントはレスポンスボディのどの部分を受信するよりも前に呼び出されることに注意してください。
そのため、ボディの最初の部分の受信と競合することを心配する必要はありません。
<code>&apos;response&apos;</code> イベントの間に <code>&apos;data&apos;</code> イベントのリスナーが加えられる限り、
ボディ全体を受信することができます。


</p>
<pre><code>// Good
request.on(&apos;response&apos;, function (response) {
  response.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

// Bad - misses all or part of the body
request.on(&apos;response&apos;, function (response) {
  setTimeout(function () {
    response.on(&apos;data&apos;, function (chunk) {
      console.log(&apos;BODY: &apos; + chunk);
    });
  }, 10);
});</code></pre>
<!--
Note: Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.
-->

<p>注意: Node は Content-Length と実際に送信されたリクエストボディの長さが等しいかどうかチェックしません。

</p>
<!--
The request implements the [Writable  Stream](stream.html#writable_stream)
interface. This is an `EventEmitter` with the following events:
-->

<p>リクエストは <a href="stream.html#writable_Stream">Writable  Stream</a>
インタフェースを実装します。
これは以下のイベントを持つ <code>EventEmitter</code> です。

</p>
<h3>Event &apos;response&apos;<span><a class="mark" href="#all_event_response" id="all_event_response">#</a></span></h3>
<p><code>function (response) { }</code>

</p>
<!--
Emitted when a response is received to this request. This event is emitted only once. The
`response` argument will be an instance of `http.ClientResponse`.
-->

<p>このリクエストに対するレスポンスを受信した時に生成されます。
このイベントは一回だけ生成されます。
<code>response</code> 引数は <code>http.ClientResponse</code> のインスタンスです。

</p>
<!--
Options:
-->

<p>オプション:

</p>
<!--
- `host`: A domain name or IP address of the server to issue the request to.
- `port`: Port of remote server.
- `socketPath`: Unix Domain Socket (use one of host:port or socketPath)
-->

<ul>
<li><code>host</code>: リクエストを発行するサーバのドメイン名または IP アドレス。</li>
<li><code>port</code>: リモートサーバのポート。</li>
<li><code>soocketPath</code>: Unix ドメインソケット (host:port または socketPath のどちらか)</li>
</ul>
<h3>Event: &apos;socket&apos;<span><a class="mark" href="#all_event_socket" id="all_event_socket">#</a></span></h3>
<p><code>function (socket) { }</code>

</p>
<!--
Emitted after a socket is assigned to this request.
-->

<p>このリクエストにソケットが割り当てられた後に生成されます。

</p>
<h3>Event: &apos;upgrade&apos;<span><a class="mark" href="#all_event_upgrade_1" id="all_event_upgrade_1">#</a></span></h3>
<p><code>function (response, socket, head) { }</code>

</p>
<!--
Emitted each time a server responds to a request with an upgrade. If this
event isn't being listened for, clients receiving an upgrade header will have
their connections closed.
-->

<p>サーバがアップグレード要求に応答する度に生成されます。
このイベントが監視されていない場合、クライアントがアップグレードヘッダを受信するとそのコネクションはクローズされます。

</p>
<!--
A client server pair that show you how to listen for the `upgrade` event using `http.getAgent`:
-->

<p><code>http.getAget</code> を使ってどのように <code>upgrade</code> イベントを監視するかを示す、
クライアントとサーバのペア:

</p>
<pre><code>var http = require(&apos;http&apos;);
var net = require(&apos;net&apos;);

// Create an HTTP server
var srv = http.createServer(function (req, res) {
  res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
  res.end(&apos;okay&apos;);
});
srv.on(&apos;upgrade&apos;, function(req, socket, upgradeHead) {
  socket.write(&apos;HTTP/1.1 101 Web Socket Protocol Handshake\r\n&apos; +
               &apos;Upgrade: WebSocket\r\n&apos; +
               &apos;Connection: Upgrade\r\n&apos; +
               &apos;\r\n\r\n&apos;);

  socket.ondata = function(data, start, end) {
    socket.write(data.toString(&apos;utf8&apos;, start, end), &apos;utf8&apos;); // echo back
  };
});

// now that server is running
srv.listen(1337, &apos;127.0.0.1&apos;, function() {

  // make a request
  var options = {
    port: 1337,
    host: &apos;127.0.0.1&apos;,
    headers: {
      &apos;Connection&apos;: &apos;Upgrade&apos;,
      &apos;Upgrade&apos;: &apos;websocket&apos;
    }
  };

  var req = http.request(options);
  req.end();

  req.on(&apos;upgrade&apos;, function(res, socket, upgradeHead) {
    console.log(&apos;got upgraded!&apos;);
    socket.end();
    process.exit(0);
  });
});</code></pre>
<h3>Event: &apos;continue&apos;<span><a class="mark" href="#all_event_continue" id="all_event_continue">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Emitted when the server sends a '100 Continue' HTTP response, usually because
the request contained 'Expect: 100-continue'. This is an instruction that
the client should send the request body.
-->

<p>通常、リクエストが &apos;Expect: 100-continue&apos; を含んでいたことにより、
サーバが &apos;100 Continue&apos; HTTP レスポンスを送信することで生成されます。
これはクライアントがリクエストボディを送信すべき事を示します。

</p>
<h3>request.write(chunk, [encoding])<span><a class="mark" href="#all_request_write_chunk_encoding" id="all_request_write_chunk_encoding">#</a></span></h3>
<!--
Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
`['Transfer-Encoding', 'chunked']` header line when
creating the request.
-->

<p>ボディのチャンクを送信します。
このメソッドを何回も呼び出すと、サーバへのリクエストボディをストリーム化できます － 
このケースは <code>[&apos;Transfer-Encoding&apos;, &apos;chunked&apos;]</code> ヘッダでリクエストを生成したことを意味します。

</p>
<!--
The `chunk` argument should be a [buffer](buffer.html) or a string.
-->

<p><code>chunk</code> 引数は <a href="buffer.html">buffer</a> または文字列です。

</p>
<!--
The `encoding` argument is optional and only applies when `chunk` is a string.
Defaults to `'utf8'`.
-->

<p><code>encoding</code> 引数はオプションで、<code>chunk</code> が文字列の場合だけ適用されます。
デフォルトは <code>&apos;utf8&apos;</code> です。


</p>
<h3>request.end([data], [encoding])<span><a class="mark" href="#all_request_end_data_encoding" id="all_request_end_data_encoding">#</a></span></h3>
<!--
Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating `'0\r\n\r\n'`.
-->

<p>リクエストの送信を終了します。
ボディのいくつかの部分がまだ送信されていない場合、それはストリームにフラッシュされます。
リクエストがチャンク化されている場合、これは終端の <code>&apos;0\r\n\r\n&apos;</code> を送信します。

</p>
<!--
If `data` is specified, it is equivalent to calling
`request.write(data, encoding)` followed by `request.end()`.
-->

<p><code>data</code> が指定された場合は、
<code>request.write(data, encoding)</code> に続けて <code>request.end()</code> を呼び出すのと等価です。

</p>
<h3>request.abort()<span><a class="mark" href="#all_request_abort" id="all_request_abort">#</a></span></h3>
<!--
Aborts a request.  (New since v0.3.8.)
-->

<p>リクエストをアボートします (v0.3.8 からの新機能)

</p>
<h3>request.setTimeout(timeout, [callback])<span><a class="mark" href="#all_request_settimeout_timeout_callback" id="all_request_settimeout_timeout_callback">#</a></span></h3>
<!--
Once a socket is assigned to this request and is connected 
[socket.setTimeout(timeout, [callback])](net.html#socket.setTimeout)
will be called.
-->

<p>このリクエストにソケットが割り当てられて接続した際に、
<a href="net.html#socket.setTimeout">socket.setTimeout(timeout, [callback])</a>
が呼び出されます。

</p>
<h3>request.setNoDelay([noDelay])<span><a class="mark" href="#all_request_setnodelay_nodelay" id="all_request_setnodelay_nodelay">#</a></span></h3>
<!--
Once a socket is assigned to this request and is connected 
[socket.setNoDelay(noDelay)](net.html#socket.setNoDelay)
will be called.
-->

<p>このリクエストにソケットが割り当てられて接続した際に、
<a href="net.html#socket.setNoDelay">socket.setNoDelay(noDelay)</a>
が呼び出されます。


</p>
<h3>request.setSocketKeepAlive([enable], [initialDelay])<span><a class="mark" href="#all_request_setsocketkeepalive_enable_initialdelay" id="all_request_setsocketkeepalive_enable_initialdelay">#</a></span></h3>
<!--
Once a socket is assigned to this request and is connected 
[socket.setKeepAlive(enable, [initialDelay])](net.html#socket.setKeepAlive)
will be called.
-->

<p>このリクエストにソケットが割り当てられて接続した際に、
<a href="net.html#socket.setKeepAlive">socket.setKeepAlive(enable, [initialDelay])</a>
が呼び出されます。


</p>
<h2>http.ClientResponse<span><a class="mark" href="#all_http_clientresponse" id="all_http_clientresponse">#</a></span></h2>
<!--
This object is created when making a request with `http.request()`. It is
passed to the `'response'` event of the request object.
-->

<p>このオブジェクトは <code>http.request()</code> によってリクエストと一緒に作成されます。
これはリクエストオブジェクトの <code>&apos;response&apos;</code> イベントに渡されます。

</p>
<!--
The response implements the [Readable Stream](stream.html#readable_stream)
interface. This is an `EventEmitter` with the following events:

-->

<p>レスポンスは <a href="stream.html#readable_Stream">Readable Stream</a>
インタフェースを実装します。
これは以下のイベントを持つ <code>EventEmitter</code> です:

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_3" id="all_event_data_3">#</a></span></h3>
<p><code>function (chunk) { }</code>

</p>
<!--
Emitted when a piece of the message body is received.

Note that the __data will be lost__ if there is no listener when a
`ClientResponse` emits a `'data'` event.
-->

<p>メッセージボディの断片を受信した場合に生成されます。

</p>
<p><code>ClientResponse</code> が <code>&apos;data&apos;</code> イベントを生成した時にリスナが存在しなければ、
<strong>データは失われる</strong>ことに注意してください。

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_3" id="all_event_end_3">#</a></span></h3>
<p><code>function () { }</code>

</p>
<!--
Emitted exactly once for each message. No arguments. After
emitted no other events will be emitted on the response.
-->

<p>メッセージごとに厳密に一回だけ生成されます。
このイベントが生成された後、このレスポンスはどんなイベントも生成しません。

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_8" id="all_event_close_8">#</a></span></h3>
<p><code>function (err) { }</code>

</p>
<!--
Indicates that the underlaying connection was terminated before
`end` event was emitted.
See [http.ServerRequest](#http.ServerRequest)'s `'close'` event for more
information.
-->

<p><code>&apos;end&apos;</code> イベントが生成される前に下層の接続が切断されたことを示します。
<a href="#http.ServerRequest">http.ServerRequest</a> の <code>&apos;close&apos;</code>
イベントにより多くの情報があります。

</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode_1" id="all_response_statuscode_1">#</a></span></h3>
<!--
The 3-digit HTTP response status code. E.G. `404`.
-->

<p>3 桁の数字によるレスポンスのステータスコードです。例えば <code>404</code>。

</p>
<h3>response.httpVersion<span><a class="mark" href="#all_response_httpversion" id="all_response_httpversion">#</a></span></h3>
<!--
The HTTP version of the connected-to server. Probably either
`'1.1'` or `'1.0'`.
Also `response.httpVersionMajor` is the first integer and
`response.httpVersionMinor` is the second.
-->

<p>接続しているサーバとの HTTP のバージョンです。
おそらく <code>&apos;1.1&apos;</code> または <code>&apos;1.0&apos;</code> のどちらかです。
同様に <code>response.httpVersionMajor</code> は最初の整数、
<code>response.httpVersionMinor</code> は 2 番目の整数です。

</p>
<h3>response.headers<span><a class="mark" href="#all_response_headers" id="all_response_headers">#</a></span></h3>
<!--
The response headers object.
-->

<p>レスポンスヘッダオブジェクトです。

</p>
<h3>response.trailers<span><a class="mark" href="#all_response_trailers" id="all_response_trailers">#</a></span></h3>
<!--
The response trailers object. Only populated after the 'end' event.
-->

<p>レスポンスのトレーラオブジェクトです。
&apos;end&apos; イベントの後にだけ発生します。

</p>
<h3>response.setEncoding([encoding])<span><a class="mark" href="#all_response_setencoding_encoding" id="all_response_setencoding_encoding">#</a></span></h3>
<!--
Set the encoding for the response body. Either `'utf8'`, `'ascii'`, or
`'base64'`. Defaults to `null`, which means that the `'data'` event will emit
a `Buffer` object.
-->

<p>レスポンスボディのエンコーディングを設定します。
<code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>、あるいは <code>&apos;base64&apos;</code> のいずれかです。
デフォルトは <code>null</code> で、
<code>&apos;data&apos;</code> イベントが <code>Buffer</code> を生成することを意味します。

</p>
<h3>response.pause()<span><a class="mark" href="#all_response_pause" id="all_response_pause">#</a></span></h3>
<!--
Pauses response from emitting events.  Useful to throttle back a download.
-->

<p>イベントの生成によるレスポンスを中断します。ダウンロード速度を落とすのに便利です。

</p>
<h3>response.resume()<span><a class="mark" href="#all_response_resume" id="all_response_resume">#</a></span></h3>
<!--
Resumes a paused response.
-->

<p>中断されていたレスポンスを再開します。

</p>
<h1>HTTPS<span><a class="mark" href="#all_https" id="all_https">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a
separate module.
-->

<p>HTTPS は TLS/SSL 上の HTTP プロトコルです。
Node ではこれらは別のモジュールとして実装されています。

</p>
<h2>Class: https.Server<span><a class="mark" href="#all_class_https_server" id="all_class_https_server">#</a></span></h2>
<!--
This class is a subclass of `tls.Server` and emits events same as
`http.Server`. See `http.Server` for more information.
-->

<p>このクラスは <code>tls.Server</code> のサブクラスで、<code>http.Server</code> と同様のイベントを生成します。
より詳しくは <code>http.Server</code> を参照してください。

</p>
<h2>https.createServer(options, [requestListener])<span><a class="mark" href="#all_https_createserver_options_requestlistener" id="all_https_createserver_options_requestlistener">#</a></span></h2>
<!--
Returns a new HTTPS web server object. The `options` is similar to
`tls.createServer()`. The `requestListener` is a function which is
automatically added to the `'request'` event.
-->

<p>新しい HTTPS Web サーバオブジェクトを返します。
<code>option</code> は <code>tls.createServer()</code> と同じです。
<code>requestListener</code> は関数で、 <code>&apos;request&apos;</code> イベントに自動的に追加されます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>// curl -k https://localhost:8000/
var https = require(&apos;https&apos;);
var fs = require(&apos;fs&apos;);

var options = {
  key: fs.readFileSync(&apos;test/fixtures/keys/agent2-key.pem&apos;),
  cert: fs.readFileSync(&apos;test/fixtures/keys/agent2-cert.pem&apos;)
};

https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<h2>https.request(options, callback)<span><a class="mark" href="#all_https_request_options_callback" id="all_https_request_options_callback">#</a></span></h2>
<!--
Makes a request to a secure web server.
All options from [http.request()](http.html#http.request) are valid.
-->

<p>セキュアな Web サーバへのリクエストを作成します。
<a href="http.html#http.request">http.request()</a> の全てと同様のオプションが指定できます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var https = require(&apos;https&apos;);

var options = {
  host: &apos;encrypted.google.com&apos;,
  port: 443,
  path: &apos;/&apos;,
  method: &apos;GET&apos;
};

var req = https.request(options, function(res) {
  console.log(&quot;statusCode: &quot;, res.statusCode);
  console.log(&quot;headers: &quot;, res.headers);

  res.on(&apos;data&apos;, function(d) {
    process.stdout.write(d);
  });
});
req.end();

req.on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<!--
The options argument has the following options
-->

<p><code>options</code> 引数は以下のオプションを持ちます。

</p>
<!--
- host: IP or domain of host to make request to. Defaults to `'localhost'`.
- port: port of host to request to. Defaults to 443.
- path: Path to request. Default `'/'`.
- method: HTTP request method. Default `'GET'`.

- `host`: A domain name or IP address of the server to issue the request to.
  Defaults to `'localhost'`.
- `hostname`: To support `url.parse()` `hostname` is preferred over `host`
- `port`: Port of remote server. Defaults to 443.
- `method`: A string specifying the HTTP request method. Defaults to `'GET'`.
- `path`: Request path. Defaults to `'/'`. Should include query string if any.
  E.G. `'/index.html?page=12'`
- `headers`: An object containing request headers.
- `auth`: Basic authentication i.e. `'user:password'` to compute an
  Authorization header.
- `agent`: Controls [Agent](#https.Agent) behavior. When an Agent is
  used request will default to `Connection: keep-alive`. Possible values:
 - `undefined` (default): use [globalAgent](#https.globalAgent) for this
   host and port.
 - `Agent` object: explicitly use the passed in `Agent`.
 - `false`: opts out of connection pooling with an Agent, defaults request to
   `Connection: close`.

The following options from [tls.connect()](tls.html#tls.connect) can also be
specified. However, a [globalAgent](#https.globalAgent) silently ignores these.

- `key`: Private key to use for SSL. Default `null`.
- `passphrase`: A string of passphrase for the private key. Default `null`.
- `cert`: Public x509 certificate to use. Default `null`.
- `ca`: An authority certificate or array of authority certificates to check
  the remote host against.

In order to specify these options, use a custom `Agent`.

Example:
-->

<ul>
<li><code>host</code>: リクエストを発行するサーバのドメイン名または IP アドレス。
 デフォルトは <code>&apos;localhost&apos;</code> です。</li>
<li><code>hostname</code>: <code>url.parse()</code> サポート。<code>hostname</code> は <code>host</code> を上書きします。</li>
<li><code>port</code>: リモートサーバのポート。デフォルトは 443 です。</li>
<li><code>method</code>: HTTPS リクエストのメソッドの文字列。デフォルトは <code>&apos;GET&apos;</code> です。</li>
<li><code>path</code>: リクエストのパス。デフォルトは <code>&apos;/&apos;</code> です。
必要なら問い合わせ文字列を含めるべきです．
例 <code>&apos;/index.html?page=12&apos;</code></li>
<li><code>headers</code>: リクエストヘッダを含むオブジェクト。</li>
<li><code>auth</code>: べーしく認証すなわち Authorization ヘッダのための <code>&apos;user:password&apos;</code>。</li>
<li><code>agent</code>: <a href="#https.Agent">Agent</a> の振る舞いを制御します。
エージェントが使われる場合、<code>Connection:keep-alive</code> がデフォルトになります。
可能な値は:<ul>
<li><code>undefined</code> (デフォルト): ホストとポートで
<a href="#https.globalAgent">グローバル Agent</a> を使用します。</li>
<li><code>Agent</code> オブジェクト: 明示的に渡された <code>Agent</code> を使用します。</li>
<li><code>false</code>: Agent によるコネクションプーリングを使用しません。
<code>Connection:close</code> の場合のデフォルトです。</li>
</ul>
</li>
</ul>
<p>以下の <a href="tls.html#tls.connect">tls.connect()</a> 由来のオプションを
指定することもできますが、
グローバル <a href="http.html#http.Agent">エージェント</a> はこれらを無視します。

</p>
<ul>
<li><code>key</code>: SSLで使用する秘密鍵。デフォルトは <code>null</code> です。</li>
<li><code>passphrase</code>: 秘密鍵のパスフレーズを表す文字列。デフォルトは <code>null</code> です。</li>
<li><code>cert</code>: x509公開証明書。デフォルトは <code>null</code> です。</li>
<li><code>ca</code>: リモートホストをチェックする信頼できる認証局または認証局の配列。</li>
</ul>
<p>これらのオプションを指定するには、カスタムエージェントを使用します。

</p>
<p>例:

</p>
<pre><code>var options = {
  host: &apos;encrypted.google.com&apos;,
  port: 443,
  path: &apos;/&apos;,
  method: &apos;GET&apos;,
  key: fs.readFileSync(&apos;test/fixtures/keys/agent2-key.pem&apos;),
  cert: fs.readFileSync(&apos;test/fixtures/keys/agent2-cert.pem&apos;)
};
options.agent = new https.Agent(options);

var req = https.request(options, function(res) {
  ...
}</code></pre>
<!--
Or does not use an `Agent`.

Example:
-->

<p>あるいは、エージェントを使用しません。

</p>
<pre><code>var options = {
  host: &apos;encrypted.google.com&apos;,
  port: 443,
  path: &apos;/&apos;,
  method: &apos;GET&apos;,
  key: fs.readFileSync(&apos;test/fixtures/keys/agent2-key.pem&apos;),
  cert: fs.readFileSync(&apos;test/fixtures/keys/agent2-cert.pem&apos;),
  agent: false
};

var req = https.request(options, function(res) {
  ...
}</code></pre>
<h2>https.get(options, callback)<span><a class="mark" href="#all_https_get_options_callback" id="all_https_get_options_callback">#</a></span></h2>
<!--
Like `http.get()` but for HTTPS.
-->

<p><code>http.get()</code> と同様ですが HTTPS です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var https = require(&apos;https&apos;);

https.get({ host: &apos;encrypted.google.com&apos;, path: &apos;/&apos; }, function(res) {
  console.log(&quot;statusCode: &quot;, res.statusCode);
  console.log(&quot;headers: &quot;, res.headers);

  res.on(&apos;data&apos;, function(d) {
    process.stdout.write(d);
  });

}).on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<h2>Class: https.Agent<span><a class="mark" href="#all_class_https_agent" id="all_class_https_agent">#</a></span></h2>
<!--
An Agent object for HTTPS similar to [http.Agent](http.html#http.Agent).
See [https.request()](#https.request) for more information.
-->

<p>HTTPS 用の Agent オブジェクトで，
<a href="http.html#http.Agent">http.Agent</a> と同様です。

</p>
<h2>https.globalAgent<span><a class="mark" href="#all_https_globalagent" id="all_https_globalagent">#</a></span></h2>
<!--
Global instance of [https.Agent](#https.Agent) which is used as the default
for all HTTPS client requests.
-->

<p>全ての HTTPS クライアントリクエストでデフォルトとして使用される、
<a href="#https.Agent">https.Agent</a> のインスタンスです。

</p>
<h1>URL<span><a class="mark" href="#all_url" id="all_url">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
This module has utilities for URL resolution and parsing.
Call `require('url')` to use it.
-->

<p>このモジュールはURLの解決や解析の為のユーティリティを持ちます。
利用するには <code>require(&apos;url&apos;)</code> を呼び出してください。

</p>
<!--
Parsed URL objects have some or all of the following fields, depending on
whether or not they exist in the URL string. Any parts that are not in the URL
string will not be in the parsed object. Examples are shown for the URL
-->

<p>解析されたURLオブジェクトは、URL文字列の中に存在するかどうかに応じて
次に示すフィールドをいくつかもしくは全てを持ちます。
URL文字列に含まれないフィールドは解析結果のオブジェクトに含まれません。
次のURLで例を示します。

</p>
<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>

</p>
<!--
* `href`: The full URL that was originally parsed. Both the protocol and host are lowercased.

    Example: `'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'`

* `protocol`: The request protocol, lowercased.

    Example: `'http:'`

* `host`: The full lowercased host portion of the URL, including port
  information.

    Example: `'host.com:8080'`

* `auth`: The authentication information portion of a URL.

    Example: `'user:pass'`

* `hostname`: Just the lowercased hostname portion of the host.

    Example: `'host.com'`

* `port`: The port number portion of the host.

    Example: `'8080'`

* `pathname`: The path section of the URL, that comes after the host and
  before the query, including the initial slash if present.

    Example: `'/p/a/t/h'`

* `search`: The 'query string' portion of the URL, including the leading
  question mark.

    Example: `'?query=string'`

* `path`: Concatenation of `pathname` and `search`.

    Example: `'/p/a/t/h?query=string'`

* `query`: Either the 'params' portion of the query string, or a
  querystring-parsed object.

    Example: `'query=string'` or `{'query':'string'}`

* `hash`: The 'fragment' portion of the URL including the pound-sign.

    Example: `'#hash'`
-->

<ul>
<li><p><code>href</code>: 解析する前の完全な URL。protocol と host はどちらも小文字化されます。</p>
<p>  例: <code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code></p>
</li>
<li><p><code>protocol</code>: リクエストのプロトコル。小文字化されます。</p>
<p>  例: <code>&apos;http:&apos;</code></p>
</li>
<li><p><code>host</code>: URL の完全で小文字化されたホスト情報。認証情報を含みます。 </p>
<p>  例: <code>&apos;host.com:8080&apos;</code></p>
</li>
<li><p><code>auth</code>: URL の認証情報。</p>
<p>  例: <code>&apos;user:pass&apos;</code></p>
</li>
<li><p><code>hostname</code>: ホスト情報の中の小文字化されたホスト名。</p>
<p>  例: <code>&apos;host.com&apos;</code></p>
</li>
<li><p><code>port</code>: ホスト情報の中のポート番号。</p>
<p>  例: <code>&apos;8080&apos;</code></p>
</li>
<li><p><code>pathname</code>: URL のパス部分。ホスト情報からクエリまでの間に位置し、最初にスラッシュが存在する場合はそれも含みます。</p>
<p>  例: <code>&apos;/p/a/t/h&apos;</code></p>
</li>
<li><p><code>search</code>: URL のクエリ文字列。先頭の ? マークも含みます。</p>
<p>  例: <code>&apos;?query=string&apos;</code></p>
</li>
<li><p><code>path</code>: <code>pathname</code> と <code>search</code> を連結した文字列。</p>
<p>  例: <code>&apos;/p/a/t/h?query=string&apos;</code></p>
</li>
<li><p><code>query</code>: クエリの変数部分の文字列、もしくはクエリ文字列を解析したオブジェクト。</p>
<p>  例: <code>&apos;query=string&apos;</code> or <code>{&apos;query&apos;:&apos;string&apos;}</code></p>
</li>
<li><p><code>hash</code>: URL の # マークを含む部分。</p>
<p>  例: <code>&apos;#hash&apos;</code></p>
</li>
</ul>
<!--
The following methods are provided by the URL module:
-->

<p>以下のメソッドはURLモジュールにより提供されます:

</p>
<h2>url.parse(urlStr, [parseQueryString], [slashesDenoteHost])<span><a class="mark" href="#all_url_parse_urlstr_parsequerystring_slashesdenotehost" id="all_url_parse_urlstr_parsequerystring_slashesdenotehost">#</a></span></h2>
<!--
Take a URL string, and return an object.

Pass `true` as the second argument to also parse
the query string using the `querystring` module.
Defaults to `false`.

Pass `true` as the third argument to treat `//foo/bar` as
`{ host: 'foo', pathname: '/bar' }` rather than
`{ pathname: '//foo/bar' }`. Defaults to `false`.
-->

<p>URL文字列を引数に取り、解析結果のオブジェクトを返します。

</p>
<p><code>querystring</code> モジュールを使ってクエリ文字列も解析したい場合は、
第 2 引数に <code>true</code> を渡してください。
デフォルトは <code>false</code> です。

</p>
<p><code>//foo/bar</code> を <code>{ pathname: &apos;//foo/bar&apos; }</code> ではなく
<code>{ host: &apos;foo&apos;, pathname: &apos;/bar&apos; }</code> としたい場合は、
第 3 引数に <code>true</code> を渡してください。
デフォルトは <code>false</code> です。

</p>
<h2>url.format(urlObj)<span><a class="mark" href="#all_url_format_urlobj" id="all_url_format_urlobj">#</a></span></h2>
<!--
Take a parsed URL object, and return a formatted URL string.
-->

<p>URL オブジェクトを引数に取り、フォーマットした URL 文字列を返します。

</p>
<!--
* `href` will be ignored.
* `protocol`is treated the same with or without the trailing `:` (colon).
  * The protocols `http`, `https`, `ftp`, `gopher`, `file` will be
    postfixed with `://` (colon-slash-slash).
  * All other protocols `mailto`, `xmpp`, `aim`, `sftp`, `foo`, etc will
    be postfixed with `:` (colon)
* `auth` will be used if present.
* `hostname` will only be used if `host` is absent.
* `port` will only be used if `host` is absent.
* `host` will be used in place of `auth`, `hostname`, and `port`
* `pathname` is treated the same with or without the leading `/` (slash)
* `search` will be used in place of `query`
* `query` (object; see `querystring`) will only be used if `search` is absent.
* `search` is treated the same with or without the leading `?` (question mark)
* `hash` is treated the same with or without the leading `#` (pound sign, anchor)
-->

<ul>
<li><code>href</code> は無視されます。</li>
<li><code>protocol</code> の末尾に <code>:</code> (コロン) があってもなくても同じように扱われます。<ul>
<li><code>http</code>、<code>https</code>、<code>ftp</code>、<code>gopher</code>、<code>file</code> は末尾に
<code>://</code> (コロン、スラッシュ、スラッシュ) が付けられます。</li>
<li><code>mailto</code>、<code>xmpp</code>、<code>aim</code>、<code>sftp</code>、<code>foo</code> など、その他のプロトコルは末尾に
<code>:</code> (コロン) が付けられます。</li>
</ul>
</li>
<li><code>auth</code> は <code>host</code> が与えられなかった場合だけ使われます。</li>
<li><code>hostname</code> は <code>host</code> が与えられなかった場合だけ使われます。</li>
<li><code>port</code> は <code>host</code> が与えられなかった場合だけ使われます。</li>
<li><code>host</code> は <code>auth</code>、<code>hostname</code>、<code>port</code> の位置で使われます。</li>
<li><code>pathname</code> の先頭に <code>/</code> (スラッシュ) があってもなくても同じように扱われます。</li>
<li><code>search</code> は <code>query</code> の位置で使われます。</li>
<li><code>query</code> (文字列ではなくオブジェクトです; <code>querystring</code> を参照してください) は <code>search</code> が与えられなかった場合だけ使われます。</li>
<li><code>search</code> の先頭に <code>?</code> (クエスチョンマーク) があってもなくても同じように扱われます。</li>
<li><code>hash</code> の先頭に <code>#</code> (シャープ, アンカー) があってもなくても同じように扱われます。</li>
</ul>
<h2>url.resolve(from, to)<span><a class="mark" href="#all_url_resolve_from_to" id="all_url_resolve_from_to">#</a></span></h2>
<!--
Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.
-->

<p>ベースとなる URL と相対 URL を引数に取り、ブラウザがアンカータグに対して
行うのと同様に URL を解決します。
</p>
<h1>Query String<span><a class="mark" href="#all_query_string" id="all_query_string">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--name=querystring-->

<!--
This module provides utilities for dealing with query strings.
It provides the following methods:
-->

<p>このモジュールはクエリ文字列を処理するユーティリティを提供します。 以下のメソッドから成ります:

</p>
<h2>querystring.stringify(obj, [sep], [eq])<span><a class="mark" href="#all_querystring_stringify_obj_sep_eq" id="all_querystring_stringify_obj_sep_eq">#</a></span></h2>
<!--
Serialize an object to a query string.
Optionally override the default separator (`'&'`) and assignment (`'='`)
characters.
-->

<p>クエリオブジェクトを文字列へ直列化します。
オプションとしてデフォルトの区切り文字 (デフォルトは <code>&apos;&amp;&apos;</code>) と代入文字
(デフォルトは <code>&apos;=&apos;</code>) を上書き指定できます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>querystring.stringify({ foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; })
// returns
&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;

querystring.stringify({foo: &apos;bar&apos;, baz: &apos;qux&apos;}, &apos;;&apos;, &apos;:&apos;)
// returns
&apos;foo:bar;baz:qux&apos;</code></pre>
<h2>querystring.parse(str, [sep], [eq])<span><a class="mark" href="#all_querystring_parse_str_sep_eq" id="all_querystring_parse_str_sep_eq">#</a></span></h2>
<!--
Deserialize a query string to an object.
Optionally override the default separator (`'&'`) and assignment (`'='`)
characters.
-->

<p>クエリ文字列をオブジェクトに復元します。
オプションとしてデフォルトの区切り文字 (<code>&apos;&amp;&apos;</code>) と代入文字 (<code>&apos;=&apos;</code>)
を上書き指定できます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;)
// returns
{ foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; }</code></pre>
<h2>querystring.escape<span><a class="mark" href="#all_querystring_escape" id="all_querystring_escape">#</a></span></h2>
<!--
The escape function used by `querystring.stringify`,
provided so that it could be overridden if necessary.
-->

<p>escape 関数は <code>querystring.stringify</code> で使用されていて、必要な場合にオーバーライドできるよう提供されています。

</p>
<h2>querystring.unescape<span><a class="mark" href="#all_querystring_unescape" id="all_querystring_unescape">#</a></span></h2>
<!--
The unescape function used by `querystring.parse`,
provided so that it could be overridden if necessary.
-->

<p>unescape関数は <code>querystring.parse</code> で使用されていて、必要な場合にオーバーライドできるよう提供されています。

</p>
<h1>Readline<span><a class="mark" href="#all_readline" id="all_readline">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
To use this module, do `require('readline')`. Readline allows reading of a
stream (such as STDIN) on a line-by-line basis.
-->

<p>このモジュールを使用するには、<code>require(&apos;readline&apos;)</code> をします。
Readline はストリーム (たとえば標準入力) を行ごとに読み込むことを可能にします。

</p>
<!--
Note that once you've invoked this module, your node program will not
terminate until you've closed the interface, and the STDIN stream. Here's how
to allow your program to gracefully terminate:
-->

<p>このモジュールを一度起動すると、このインタフェースと 
(標準入力などの) ストリームをクローズするまで node
プログラムは終了しないことに注意してください。
きれいに終了する方法を以下に示します:

</p>
<pre><code>var rl = require(&apos;readline&apos;);

var i = rl.createInterface(process.stdin, process.stdout, null);
i.question(&quot;What do you think of node.js?&quot;, function(answer) {
  // TODO: Log the answer in a database
  console.log(&quot;Thank you for your valuable feedback.&quot;);

  // These two lines together allow the program to terminate. Without
  // them, it would run forever.
  i.close();
  process.stdin.destroy();
});</code></pre>
<h2>rl.createInterface(input, output, completer)<span><a class="mark" href="#all_rl_createinterface_input_output_completer" id="all_rl_createinterface_input_output_completer">#</a></span></h2>
<!--
Takes two streams and creates a readline interface. The `completer` function
is used for autocompletion. When given a substring, it returns `[[substr1,
substr2, ...], originalsubstring]`.
-->

<p>二つのストリームを受け取り、readline のインタフェースを作成します。
<code>completer</code> 関数は補完のために使われます。
それは部分文字列を与えられると、<code>[[substr1, substr2, ...], originalsubstring]</code>
を返します。

</p>
<!--
Also `completer` can be run in async mode if it accepts two arguments:
-->

<p><code>completer</code> が二つの引数を持つなら、それは非同期モードで実行されます。

</p>
<p>  function completer(linePartial, callback) {
    callback(null, [[&apos;123&apos;], linePartial]);
  }

</p>
<!--
`createInterface` is commonly used with `process.stdin` and
`process.stdout` in order to accept user input:
-->

<p><code>createInterface</code> には通常、ユーザからの入力を受け取るために <code>process.stdin</code> と
<code>process.stdout</code> が使用されます。

</p>
<pre><code>var readline = require(&apos;readline&apos;),
  rl = readline.createInterface(process.stdin, process.stdout);</code></pre>
<h2>Class: Interface<span><a class="mark" href="#all_class_interface" id="all_class_interface">#</a></span></h2>
<!--
The class that represents a readline interface with a stdin and stdout
stream.
-->

<p>標準入力と標準出力を持つ readline インタフェースを表現するクラス。

</p>
<h3>rl.setPrompt(prompt, length)<span><a class="mark" href="#all_rl_setprompt_prompt_length" id="all_rl_setprompt_prompt_length">#</a></span></h3>
<!--
Sets the prompt, for example when you run `node` on the command line, you see
`> `, which is node's prompt.
-->

<p>プロンプトを設定します。
たとえば、コマンドプロンプトで <code>node</code> コマンドを実行すると、
<code>&gt; </code> を見ることができます。これが Node のプロンプトです。

</p>
<h3>rl.prompt()<span><a class="mark" href="#all_rl_prompt" id="all_rl_prompt">#</a></span></h3>
<!--
Readies readline for input from the user, putting the current `setPrompt`
options on a new line, giving the user a new spot to write.
-->

<p>ユーザからの入力を 1 行読み込みます。
現在の <code>setPrompt()</code> の値を新しい行に出力し、
ユーザに新しい入力エリアを与えます。

</p>
<h3>rl.question(query, callback)<span><a class="mark" href="#all_rl_question_query_callback" id="all_rl_question_query_callback">#</a></span></h3>
<!--
Prepends the prompt with `query` and invokes `callback` with the user's
response. Displays the query to the user, and then invokes `callback` with the
user's response after it has been typed.
-->

<p><code>query</code> をプロンプトとして、ユーザが応答すると <code>callback</code> を起動します。
ユーザに質問を表示し、ユーザが応答をタイプすると、<code>callback</code> が起動されます。

</p>
<!--
Example usage:
-->

<p>使用例:

</p>
<pre><code>interface.question(&apos;What is your favorite food?&apos;, function(answer) {
  console.log(&apos;Oh, so your favorite food is &apos; + answer);
});</code></pre>
<h3>rl.close()<span><a class="mark" href="#all_rl_close" id="all_rl_close">#</a></span></h3>
<!--
  Closes tty.
-->

<p>tty をクローズします。

</p>
<h3>rl.pause()<span><a class="mark" href="#all_rl_pause" id="all_rl_pause">#</a></span></h3>
<!--
  Pauses tty.
-->

<p>tty からの入力を中断します。

</p>
<h3>rl.resume()<span><a class="mark" href="#all_rl_resume" id="all_rl_resume">#</a></span></h3>
<!--
  Resumes tty.
-->

<p>tty からの入力を再開します。

</p>
<h3>rl.write()<span><a class="mark" href="#all_rl_write" id="all_rl_write">#</a></span></h3>
<!--
  Writes to tty.
-->

<p>tty へ出力します。

</p>
<h3>Event: &apos;line&apos;<span><a class="mark" href="#all_event_line" id="all_event_line">#</a></span></h3>
<p><code>function (line) {}</code>

</p>
<!--
Emitted whenever the `in` stream receives a `\n`, usually received when the
user hits enter, or return. This is a good hook to listen for user input.
-->

<p><code>in</code> ストリームから <code>\n</code> を読み込むごとに生成されます。
通常、ユーザがエンターまたはリターンを打つごとに受信します。
これはユーザ入浴のよいフックとなります。

</p>
<!--
Example of listening for `line`:
-->

<p><code>line</code> を監視する例:

</p>
<pre><code>rl.on(&apos;line&apos;, function (cmd) {
  console.log(&apos;You just typed: &apos;+cmd);
});</code></pre>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_9" id="all_event_close_9">#</a></span></h3>
<p><code>function () {}</code>

</p>
<!--
Emitted whenever the `in` stream receives a `^C` or `^D`, respectively known
as `SIGINT` and `EOT`. This is a good way to know the user is finished using
your program.
-->

<p><code>in</code> ストリームから <code>^C</code> または <code>^D</code> を受信すると生成されます。
それぞれ <code>SIGINT</code> および <code>EOT</code> として知られています。
これはユーザがプログラムの使用を終わらせようとしていることを知るよい方法です。

</p>
<!--
Example of listening for `close`, and exiting the program afterward:
-->

<p><code>close</code> を監視し、その後プログラムを終了する例:

</p>
<pre><code>rl.on(&apos;close&apos;, function() {
  console.log(&apos;goodbye!&apos;);
  process.exit(0);
});</code></pre>
<!--
Here's an example of how to use all these together to craft a tiny command
line interface:
-->

<p>全てを一緒に使う、小さなコマンドラインインタフェースの例:

</p>
<pre><code>var readline = require(&apos;readline&apos;),
  rl = readline.createInterface(process.stdin, process.stdout),
  prefix = &apos;OHAI&gt; &apos;;

rl.on(&apos;line&apos;, function(line) {
  switch(line.trim()) {
    case &apos;hello&apos;:
      console.log(&apos;world!&apos;);
  break;
    default:
      console.log(&apos;Say what? I might have heard `&apos; + line.trim() + &apos;`&apos;);
      break;
  }
  rl.setPrompt(prefix, prefix.length);
  rl.prompt();
}).on(&apos;close&apos;, function() {
  console.log(&apos;Have a great day!&apos;);
  process.exit(0);
});
console.log(prefix + &apos;Good to see you. Try typing stuff.&apos;);
rl.setPrompt(prefix, prefix.length);
rl.prompt();</code></pre>
<!--
Take a look at this slightly more complicated
[example](https://gist.github.com/901104), and
[http-console](https://github.com/cloudhead/http-console) for a real-life use
case.
-->

<p>より複雑な <a href="https://gist.github.com/901104">例</a> や、実践的なユースケースとして
<a href="https://github.com/cloudhead/http-console">http-console</a>
を見ることが出来ます。

</p>
<h1>REPL<span><a class="mark" href="#all_repl" id="all_repl">#</a></span></h1>
<!--
A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily
includable in other programs.  REPL provides a way to interactively run
JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.
-->

<p>Read-Eval-Print-Loop (REPL) は単独のプログラムとしても他のプログラムに手軽に取り込む形でも利用することができます。
REPL は対話的に JavaScript を実行して結果を確認する手段を提供します。 
デバッグやテストやその他の様々なことを試す用途で利用されます。

</p>
<!--
By executing `node` without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editing.
-->

<p>コマンドラインから <code>node</code> を引数無しで実行することで、REPL プログラムに入ります。
REPL は Emacs 風の簡易な行編集機能を備えています。

</p>
<pre><code>mjr:~$ node
Type &apos;.help&apos; for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>
<!--
For advanced line-editors, start node with the environmental variable `NODE_NO_READLINE=1`.
This will start the REPL in canonical terminal settings which will allow you to use with `rlwrap`.
-->

<p>より進んだ行編集を行うには、環境変数に <code>NODE_NO_READLINE=1</code> を設定してnodeを起動してください。
これによって正規の端末設定で REPL を起動し、<code>rlwrap</code> を有効にした状態でREPLを利用することができます。

</p>
<!--
For example, you could add this to your bashrc file:
-->

<p>例として、bashrc ファイルに以下のように設定を追加します:

</p>
<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>
<h2>repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined])<span><a class="mark" href="#all_repl_start_prompt_stream_eval_useglobal_ignoreundefined" id="all_repl_start_prompt_stream_eval_useglobal_ignoreundefined">#</a></span></h2>
<!--
Starts a REPL with `prompt` as the prompt and `stream` for all I/O.  `prompt`
is optional and defaults to `> `.  `stream` is optional and defaults to
`process.stdin`. `eval` is optional too and defaults to async wrapper for
`eval()`.

If `useGlobal` is set to true, then the repl will use the global object,
instead of running scripts in a separate context. Defaults to `false`.

If `ignoreUndefined` is set to true, then the repl will not output return value
of command if it's `undefined`. Defaults to `false`.

You can use your own `eval` function if it has following signature:
-->

<p><code>prompt</code> でプロンプト記号を、 <code>stream</code> で I/O を引数に取って REPL を起動します。
<code>prompt</code> は省略可能で、 デフォルトは <code>&gt; </code> です。
<code>stream</code> は省略可能で、 デフォルトは <code>process.stdin</code> です。
<code>eval</code> も省略可能で、デフォルトは <code>eval()</code> の非同期ラッパーです。

</p>
<p><code>useGlobal</code> を <code>true</code> に指定した場合、REPL は別のコンテキストでスクリプトを
実行するのではなく、グローバルオブジェクトを使用します。
デフォルトは <code>false</code> です。

</p>
<p><code>ignoreUndefined</code> を <code>true</code> に指定した場合、REPL はコマンドの戻り値が <code>undefined</code> だった場合にそれを出力しません。デフォルトは <code>false</code> です。

</p>
<p>独自の <code>eval()</code> 関数は以下のシグネチャを持ちます。

</p>
<pre><code>function eval(cmd, callback) {
  callback(null, result);
}</code></pre>
<!--
Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.
-->

<p>複数の REPL を起動した場合、同一の node インスタンスが実行されないことがあります。
それぞれの REPL はグローバルオブジェクトを共有しますが、I/O は固有のものを持ちます。

</p>
<!--
Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:
-->

<p>REPL を標準入力、Unix ドメインソケット、TCP ソケットのもとで起動する例を示します:

</p>
<pre><code>var net = require(&quot;net&quot;),
    repl = require(&quot;repl&quot;);

connections = 0;

repl.start(&quot;node via stdin&gt; &quot;);

net.createServer(function (socket) {
  connections += 1;
  repl.start(&quot;node via Unix socket&gt; &quot;, socket);
}).listen(&quot;/tmp/node-repl-sock&quot;);

net.createServer(function (socket) {
  connections += 1;
  repl.start(&quot;node via TCP socket&gt; &quot;, socket);
}).listen(5001);</code></pre>
<!--
Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. `telnet` is useful
for connecting to TCP sockets, and `socat` can be used to connect to both Unix and
TCP sockets.
-->

<p>このプログラムをコマンドラインから実行すると、標準入力のもとで REPL が起動します。
他の REPL クライアントは Unix ドメインソケットか TCP ソケットを介して接続することができます。
<code>telnet</code> が TCP ソケットへの接続に便利です。
<code>socat</code> は Unix ドメイン /TCP 両方のソケットへの接続に利用できます。

</p>
<!--
By starting a REPL from a Unix socket-based server instead of stdin, you can
connect to a long-running node process without restarting it.
-->

<p>標準入力の代わりに Unix ドメインソケットをベースとしたサーバから REPL を起動することによって、
再起動することなく node の常駐プロセスへ接続することができます。


</p>
<h2>REPL Features<span><a class="mark" href="#all_repl_features" id="all_repl_features">#</a></span></h2>
<!-- type=misc -->

<!--
Inside the REPL, Control+D will exit.  Multi-line expressions can be input.
Tab completion is supported for both global and local variables.
-->

<p>REPL の中で Control+D を実行すると終了します。複数行に渡る式を入力とすることができます。

</p>
<!--
The special variable `_` (underscore) contains the result of the last expression.
-->

<p>特別な変数である <code>_</code> (アンダースコア) は一番最後の式の結果を保持します。

</p>
<pre><code>&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
&gt; _.length
3
&gt; _ += 1
4</code></pre>
<!--
The REPL provides access to any variables in the global scope. You can expose
a variable to the REPL explicitly by assigning it to the `context` object
associated with each `REPLServer`.  For example:
-->

<p>REPL はグローバルスコープに存在する全ての変数にアクセス可能です。
それぞれの <code>REPLServer</code> に紐づく <code>context</code> オブジェクトに変数を付与することで、
明示的に変数を公開させることが可能です。 例:

</p>
<pre><code>// repl_test.js
var repl = require(&quot;repl&quot;),
    msg = &quot;message&quot;;

repl.start().context.m = msg;</code></pre>
<!--
Things in the `context` object appear as local within the REPL:
-->

<p><code>context</code> オブジェクトに設定された変数は、REPL の中ではローカルな変数として現れます:

</p>
<pre><code>mjr:~$ node repl_test.js
&gt; m
&apos;message&apos;</code></pre>
<!--
There are a few special REPL commands:
-->

<p>特別な REPL コマンドがいくつかあります:

</p>
<!--
  - `.break` - While inputting a multi-line expression, sometimes you get lost
    or just don't care about completing it. `.break` will start over.
  - `.clear` - Resets the `context` object to an empty object and clears any
    multi-line expression.
  - `.exit` - Close the I/O stream, which will cause the REPL to exit.
  - `.help` - Show this list of special commands.
  - `.save` - Save the current REPL session to a file
    >.save ./file/to/save.js
  - `.load` - Load a file into the current REPL session.
    >.load ./file/to/load.js
-->

<ul>
<li><code>.break</code> - 複数行に渡って式を入力している間に、途中で分からなくなったり完了させなくても良くなることがあります。<code>.break</code> で最初からやり直します。</li>
<li><code>.clear</code> - <code>context</code> オブジェクトを空の状態にリセットし、複数行に入力している式をクリアします。</li>
<li><code>.exit</code> - I/Oストリームを閉じ、REPLを終了させます。</li>
<li><code>.help</code> - このコマンドの一覧を表示します。</li>
<li><code>.save</code> - 現在の REPL セッションをファイルに保存します。<blockquote>
<p>.save ./file/to/save.js</p>
</blockquote>
</li>
<li><code>.load</code> - 現在の REPL セッションにファイルをロードします。<blockquote>
<p>.load ./file/to/load.js</p>
</blockquote>
</li>
</ul>
<!--
The following key combinations in the REPL have these special effects:
-->

<p>REPL では、以下のキーコンビネーションは特別な効果を持ちます

</p>
<!--
  - `<ctrl>C` - Similar to the `.break` keyword.  Terminates the current
    command.  Press twice on a blank line to forcibly exit.
  - `<ctrl>D` - Similar to the `.exit` keyword.
-->

<ul>
<li><code>&lt;ctrl&gt;C</code> - <code>.break</code> キーワードと同様です。
現在のコマンドを終了します。
強制的に終了したければ空の行で 2 回押してください。</li>
<li><code>&lt;ctrl&gt;D</code> - <code>.exit</code> キーワードと同様です。</li>
</ul>
<h1>Executing JavaScript<span><a class="mark" href="#all_executing_javascript" id="all_executing_javascript">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--name=vm-->

<!--
You can access this module with:
-->

<p>次のようにすることで、このモジュールにアクセスすることができます:

</p>
<pre><code>var vm = require(&apos;vm&apos;);</code></pre>
<!--
JavaScript code can be compiled and run immediately or compiled, saved, and run later.
-->

<p>JavaScript コードは、コンパイルされてすぐに実行されるか、コンパイルおよび保存されて後から実行されます。


</p>
<h2>vm.runInThisContext(code, [filename])<span><a class="mark" href="#all_vm_runinthiscontext_code_filename" id="all_vm_runinthiscontext_code_filename">#</a></span></h2>
<!--
`vm.runInThisContext()` compiles `code`, runs it and returns the result. Running
code does not have access to local scope. `filename` is optional, it's used only
in stack traces.
-->

<p><code>vm.runInThisContext()</code> は <code>code</code> をコンパイルして実行し、結果を返します。
実行されるコードはローカルスコープにアクセスしません。
<code>filename</code> はオプションで、スタックトレースでのみ使用されます。

</p>
<!--
Example of using `vm.runInThisContext` and `eval` to run the same code:
-->

<p><code>vm.runInThisContext</code> と <code>eval</code> で同じコードを実行する例:

</p>
<pre><code>var localVar = 123,
    usingscript, evaled,
    vm = require(&apos;vm&apos;);

usingscript = vm.runInThisContext(&apos;localVar = 1;&apos;,
  &apos;myfile.vm&apos;);
console.log(&apos;localVar: &apos; + localVar + &apos;, usingscript: &apos; +
  usingscript);
evaled = eval(&apos;localVar = 1;&apos;);
console.log(&apos;localVar: &apos; + localVar + &apos;, evaled: &apos; +
  evaled);

// localVar: 123, usingscript: 1
// localVar: 1, evaled: 1</code></pre>
<!--
`vm.runInThisContext` does not have access to the local scope, so `localVar` is unchanged.
`eval` does have access to the local scope, so `localVar` is changed.
-->

<p><code>vm.runInThisContext</code> はローカルスコープにアクセスしないので、<code>localVar</code> は変更されません。
<code>eval</code> はローカルスコープにアクセスするので、<code>localVar</code> は変更されます。

</p>
<!--
In case of syntax error in `code`, `vm.runInThisContext` emits the syntax error to stderr
and throws an exception.
-->

<p><code>code</code> が文法エラーとなるケースでは、<code>vm.runInThisContext</code> は標準エラーに文法エラーを出力し、
例外をスローします。


</p>
<h2>vm.runInNewContext(code, [sandbox], [filename])<span><a class="mark" href="#all_vm_runinnewcontext_code_sandbox_filename" id="all_vm_runinnewcontext_code_sandbox_filename">#</a></span></h2>
<!--
`vm.runInNewContext` compiles `code`, then runs it in `sandbox` and returns the
result. Running code does not have access to local scope. The object `sandbox`
will be used as the global object for `code`.
`sandbox` and `filename` are optional, `filename` is only used in stack traces.
-->

<p><code>vm.runInNewContext</code> は <code>code</code> をコンパイルし、それを <code>sandbox</code> の中で実行して
結果を返します。
実行されるコードはローカルスコープにアクセスしません。
<code>sandbox</code> が <code>code</code> にとってのグローバルオブジェクトとして使われます。
<code>sandbox</code> および <code>filename</code> はオプションで、<code>filename</code> 
スタックトレースでのみ使用されます。

</p>
<!--
Example: compile and execute code that increments a global variable and sets a new one.
These globals are contained in the sandbox.
-->

<p>例: グローバル変数をインクリメントして新しい値をセットするコードをコンパイルおよび実行します。
これらのグローバル変数はサンドボックスに含まれます。

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    sandbox = {
      animal: &apos;cat&apos;,
      count: 2
    };

vm.runInNewContext(&apos;count += 1; name = &quot;kitty&quot;&apos;, sandbox, &apos;myfile.vm&apos;);
console.log(util.inspect(sandbox));

// { animal: &apos;cat&apos;, count: 3, name: &apos;kitty&apos; }</code></pre>
<!--
Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, `vm.runInNewContext` is quite useful, but safely running untrusted code
requires a separate process.
-->

<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。
偶然グローバル変数が漏れてしまうことを防ぐために、<code>vm.runInNewContext</code> はとても役立ちますが、
信頼できないコードを安全に実行するために別のプロセスを要求します。

</p>
<!--
In case of syntax error in `code`, `vm.runInNewContext` emits the syntax error to stderr
and throws an exception.
-->

<p><code>code</code> が文法エラーとなるケースでは、
<code>vm.runInNewContext</code> は標準エラーに文法エラーを出力し、例外をスローします。

</p>
<h2>vm.runInContext(code, context, [filename])<span><a class="mark" href="#all_vm_runincontext_code_context_filename" id="all_vm_runincontext_code_context_filename">#</a></span></h2>
<!--
`vm.runInContext` compiles `code`, then runs it in `context` and returns the
result. A (V8) context comprises a global object, together with a set of
built-in objects and functions. Running code does not have access to local scope
and the global object held within `context` will be used as the global object
for `code`.
`filename` is optional, it's used only in stack traces.

Example: compile and execute code in a existing context.
-->

<p><code>vm.runInContext</code> は <code>code</code> をコンパイルして、
<code>context</code> をコンテキストとして実行し、その結果を返します。
(V8 の) コンテキストは組み込みのオブジェクトと関数と共に、
グローバルオブジェクトを含みます。
実行されるコードはローカルスコープにアクセスせず、
<code>context</code> が <code>code</code> にとってのグローバルオブジェクトとして使われます。
<code>filename</code> はオプションで、スタックトレースでのみ使用されます。

</p>
<p>例: コードをコンパイルして既存のコンテキストで実行します。

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    initSandbox = {
      animal: &apos;cat&apos;,
      count: 2
    },
    context = vm.createContext(initSandbox);

vm.runInContext(&apos;count += 1; name = &quot;CATT&quot;&apos;, context, &apos;myfile.vm&apos;);
console.log(util.inspect(context));

// { animal: &apos;cat&apos;, count: 3, name: &apos;CATT&apos; }</code></pre>
<!--
Note that `createContext` will perform a shallow clone of the supplied sandbox object in order to
initialise the global object of the freshly constructed context.

Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, `vm.runInContext` is quite useful, but safely running untrusted code
requires a separate process.

In case of syntax error in `code`, `vm.runInContext` emits the syntax error to stderr
and throws an exception.
-->

<p><code>createContext</code> は、新たに構築されたコンテキストのグローバルオブジェクトを
初期化するために、与えられた <code>context</code> オブジェクトの浅いクローンを
作成することに注意してください。

</p>
<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。
偶然グローバル変数が漏れてしまうことを防ぐために、<code>vm.runInContext</code> はとても役立ちますが、
信頼できないコードを安全に実行するために別のプロセスを要求します。


</p>
<h2>vm.createContext([initSandbox])<span><a class="mark" href="#all_vm_createcontext_initsandbox" id="all_vm_createcontext_initsandbox">#</a></span></h2>
<!--
`vm.createContext` creates a new context which is suitable for use as the 2nd argument of a subsequent
call to `vm.runInContext`. A (V8) context comprises a global object together with a set of
build-in objects and functions. The optional argument `initSandbox` will be shallow-copied
to seed the initial contents of the global object used by the context.
-->

<p><code>vm.createContext</code> は、続けて呼び出される <code>vm.runInContext</code> の第 2 引数として
使用するのに適した新しいコンテキストを作成します。
(V8 の) コンテキストは組み込みのオブジェクトと関数と共に、
グローバルオブジェクトを含みます。
オプションの引数 <code>initSandbox</code> は、このコンテキストで使用される
グローバルオブジェクトの初期値としてシャローコピーされます。

</p>
<h2>vm.createScript(code, [filename])<span><a class="mark" href="#all_vm_createscript_code_filename" id="all_vm_createscript_code_filename">#</a></span></h2>
<!--
`createScript` compiles `code` but does not run it. Instead, it returns a
`vm.Script` object representing this compiled code. This script can be run
later many times using methods below. The returned script is not bound to any
global object. It is bound before each run, just for that run. `filename` is
optional, it's only used in stack traces.
-->

<p><code>createScript</code> は <code>code</code> をコンパイルしますが、実行はしません。
代わりに、コンパイルされたコードを表現する <code>vm.Script</code> オブジェクトを返します。
このスクリプトは後述のメソッドを使って後から何度でも実行することができます。
返されるスクリプトはどのグローバルオブジェクトとも結びつけられていません。
それぞれの実行前に結びつけることで、そのとおりに実行されます。
<code>filename</code> はオプションで、スタックトレースでのみ使用されます。

</p>
<!--
In case of syntax error in `code`, `createScript` prints the syntax error to stderr
and throws an exception.
-->

<p><code>code</code> が文法エラーとなるケースでは、
<code>createScript</code> は標準エラーに文法エラーを出力して例外をスローします。


</p>
<h2>Class: Script<span><a class="mark" href="#all_class_script" id="all_class_script">#</a></span></h2>
<!--
A class for running scripts.  Returned by vm.createScript.
-->

<p>スクリプトを実行するクラスです。<code>vm.createScript()</code> によって返されます。

</p>
<h3>script.runInThisContext()<span><a class="mark" href="#all_script_runinthiscontext" id="all_script_runinthiscontext">#</a></span></h3>
<!--
Similar to `vm.runInThisContext` but a method of a precompiled `Script` object.
`script.runInThisContext` runs the code of `script` and returns the result.
Running code does not have access to local scope, but does have access to the `global` object
(v8: in actual context).
-->

<p><code>vm.runInThisContext</code> と同様ですが、
こちらはプリコンパイル済みの <code>Script</code> オブジェクトのメソッドです。
<code>script.runInThisContext</code> は <code>script</code> のコードを実行してその結果を返します。
実行されるコードはローカルスコープにアクセスしませんが、
<code>global</code> オブジェクト (v8: 実際のコンテキスト) にはアクセスします。

</p>
<!--
Example of using `script.runInThisContext` to compile code once and run it multiple times:
-->

<p><code>script.runInThisContext</code> を使ってコードを一度だけコンパイルし、複数回実行する例:

</p>
<pre><code>var vm = require(&apos;vm&apos;);

globalVar = 0;

var script = vm.createScript(&apos;globalVar += 1&apos;, &apos;myfile.vm&apos;);

for (var i = 0; i &lt; 1000 ; i += 1) {
  script.runInThisContext();
}

console.log(globalVar);

// 1000</code></pre>
<h3>script.runInNewContext([sandbox])<span><a class="mark" href="#all_script_runinnewcontext_sandbox" id="all_script_runinnewcontext_sandbox">#</a></span></h3>
<!--
Similar to `vm.runInNewContext` a method of a precompiled `Script` object.
`script.runInNewContext` runs the code of `script` with `sandbox` as the global object and returns the result.
Running code does not have access to local scope. `sandbox` is optional.
-->

<p><code>vm.runInNewContext</code> と同様ですが、
こちらはプリコンパイル済みの <code>Script</code> オブジェクトのメソッドです。
<code>script.runInNewContext</code> は <code>sandbox</code> がグローバルオブジェクトであるかのように
<code>script</code> のコードを実行してその結果を返します。
実行されるコードはローカルスコープにアクセスしません。
<code>sandbox</code> はオプションです。

</p>
<!--
Example: compile code that increments a global variable and sets one, then execute this code multiple times.
These globals are contained in the sandbox.
-->

<p>例: グローバル変数をインクリメントしてセットするコードをコンパイルして、このコードを複数回実行します。
これらのグローバル変数はサンドボックスに含まれます。

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    sandbox = {
      animal: &apos;cat&apos;,
      count: 2
    };

var script = vm.createScript(&apos;count += 1; name = &quot;kitty&quot;&apos;, &apos;myfile.vm&apos;);

for (var i = 0; i &lt; 10 ; i += 1) {
  script.runInNewContext(sandbox);
}

console.log(util.inspect(sandbox));

// { animal: &apos;cat&apos;, count: 12, name: &apos;kitty&apos; }</code></pre>
<!--
Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, `script.runInNewContext` is quite useful, but safely running untrusted code
requires a separate process.
-->

<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。
偶然グローバル変数が漏れてしまうことを防ぐために、<code>script.runInNewContext</code> はとても役立ちますが、
信頼できないコードを安全に実行するために別のプロセスを要求します。

</p>
<h1>Child Process<span><a class="mark" href="#all_child_process" id="all_child_process">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
Node provides a tri-directional `popen(3)` facility through the
`child_process` module.
-->

<p>Nodeは <code>child_process</code> モジュールを通じて、3 方向の <code>popen(3)</code>
機能を提供します。

</p>
<!--
It is possible to stream data through a child's `stdin`, `stdout`, and
`stderr` in a fully non-blocking way.
-->

<p>これは完全にノンブロッキングな方法で子プロセスの <code>stdin</code>、<code>stdout</code>、
そして <code>stderr</code> を通じたデータストリームを実現します。

</p>
<!--
To create a child process use `require('child_process').spawn()`.
To create a child process use `require('child_process').spawn()` or
`require('child_process').fork()`.  The semantics of each are slightly
different, and explained below.
-->

<p>子プロセスの生成は <code>require(&apos;child_process&apos;).spawn()</code> または
<code>require(&apos;child_process&apos;).fork()</code> を使います。
それぞれの意味論は以下で説明するようにわずかに異なります。

</p>
<h2>Class: ChildProcess<span><a class="mark" href="#all_class_childprocess" id="all_class_childprocess">#</a></span></h2>
<!--
`ChildProcess` is an `EventEmitter`.
-->

<p><code>ChildProcess</code> は <code>EventEmitter</code> です。

</p>
<!--
Child processes always have three streams associated with them. `child.stdin`,
`child.stdout`, and `child.stderr`.  These may be shared with the stdio
streams of the parent process, or they may be separate stream objects
which can be piped to and from.

The ChildProcess class is not intended to be used directly.  Use the
`spawn()` or `fork()` methods to create a Child Process instance.
-->

<p>子プロセスは常に 3 本のストリームと関連づけられています。
<code>child.stdin</code>、<code>child.stdout</code>、そして <code>child.stderr</code> です。
それらは親プロセスの標準入出力ストリームを共有するかもしれませんし、
独立したストリームオブジェクトにパイプでつながれているかもしれません。

</p>
<h3>Event:  &apos;exit&apos;<span><a class="mark" href="#all_event_exit_1" id="all_event_exit_1">#</a></span></h3>
<!--
* `code` {Number} the exit code, if it exited normally.
* `signal` {String} the signal passed to kill the child process, if it
  was killed by the parent.
-->

<ul>
<li><code>code</code> {Number} 通常に終了した場合は終了コード。</li>
<li><code>signal</code> {String} 親プロセスによって終了させられた場合は、
子プロセスを終了するために送られたシグナル。</li>
</ul>
<!--
This event is emitted after the child process ends. If the process terminated
normally, `code` is the final exit code of the process, otherwise `null`. If
the process terminated due to receipt of a signal, `signal` is the string name
of the signal, otherwise `null`.
-->

<p>このイベントは子プロセスが終了した後で生成されます。
プロセスが普通に終了した場合、<code>code</code> はプロセスの終了コードです。
それ以外の場合は <code>null</code> です。
プロセスがシグナルを受け取って終了した場合、<code>signal</code> は文字列によるシグナルの名前です。
それ以外の場合は <code>null</code> です。

</p>
<!--
See `waitpid(2)`.
-->

<p><code>waitpid(2)</code> を参照してください。

</p>
<h3>child.stdin<span><a class="mark" href="#all_child_stdin" id="all_child_stdin">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<!--
A `Writable Stream` that represents the child process's `stdin`.
Closing this stream via `end()` often causes the child process to terminate.

If the child stdio streams are shared with the parent, then this will
not be set.
-->

<p>子プロセスの <code>stdin</code> を表現する <code>Writable Stream</code> です。
多くの場合、<code>end()</code> を通じてこのストリームを閉じると子プロセスが終了する原因となります。

</p>
<p>子プロセスの標準入出力が親プロセスと共有されている場合は設定されません。

</p>
<h3>child.stdout<span><a class="mark" href="#all_child_stdout" id="all_child_stdout">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<!--
A `Readable Stream` that represents the child process's `stdout`.

If the child stdio streams are shared with the parent, then this will
not be set.
-->

<p>子プロセスの <code>stdout</code> を表現する <code>Readable Stream</code> です。

</p>
<p>子プロセスの標準入出力が親プロセスと共有されている場合は設定されません。

</p>
<h3>child.stderr<span><a class="mark" href="#all_child_stderr" id="all_child_stderr">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<!--
A `Readable Stream` that represents the child process's `stderr`.

If the child stdio streams are shared with the parent, then this will
not be set.
-->

<p>子プロセスの <code>stderr</code> を表現する <code>Readable Stream</code> です。

</p>
<p>子プロセスの標準入出力が親プロセスと共有されている場合は設定されません。

</p>
<h3>child.pid<span><a class="mark" href="#all_child_pid" id="all_child_pid">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Integer</span></li>
</div></ul>
<!--
The PID of the child process.
-->

<p>子プロセスの PID です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

console.log(&apos;Spawned child pid: &apos; + grep.pid);
grep.stdin.end();</code></pre>
<h3>child.kill([signal])<span><a class="mark" href="#all_child_kill_signal" id="all_child_kill_signal">#</a></span></h3>
<div class="signature"><ul>
<li><code>signal</code> <span class="type">String</span></li>
</div></ul>
<!--
Send a signal to the child process. If no argument is given, the process will
be sent `'SIGTERM'`. See `signal(7)` for a list of available signals.
-->

<p>子プロセスにシグナルを送ります。
引数が与えられない場合、子プロセスには <code>&apos;SIGTERM&apos;</code> が送られます。
利用可能なシグナルの一覧は <code>signal(7)</code> を参照してください。


</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

grep.on(&apos;exit&apos;, function (code, signal) {
  console.log(&apos;child process terminated due to receipt of signal &apos;+signal);
});

// send SIGHUP to process
grep.kill(&apos;SIGHUP&apos;);</code></pre>
<!--
Note that while the function is called `kill`, the signal delivered to the child
process may not actually kill it.  `kill` really just sends a signal to a process.
-->

<p>この関数は <code>kill</code> と呼ばれるものの、
子プロセスに届けられるシグナルが実際には子プロセスを殺さないかもしれないことに注意してください。
<code>kill</code> はただプロセスにシグナルを送るだけです。

</p>
<!--
See `kill(2)`
-->

<p><code>kill(2)</code> を参照してください。

</p>
<h3>child.send(message, [sendHandle])<span><a class="mark" href="#all_child_send_message_sendhandle" id="all_child_send_message_sendhandle">#</a></span></h3>
<div class="signature"><ul>
<li><code>message</code> <span class="type">Object</span></li>
<li><code>sendHandle</code> <span class="type">Handle object</span></li>
</div></ul>
<!--
Send a message (and, optionally, a handle object) to a child process.

See `child_process.fork()` for details.
-->

<p>子プロセスにメッセージ (もしあれば、オプションのハンドルオブジェクト)
を送ります。詳細は <code>child_process.fork()</code> を参照してください。

</p>
<h2>child_process.spawn(command, [args], [options])<span><a class="mark" href="#all_child_process_spawn_command_args_options" id="all_child_process_spawn_command_args_options">#</a></span></h2>
<!--
* `command` {String} The command to run
* `args` {Array} List of string arguments
* `options` {Object}
  * `cwd` {String} Current working directory of the child process
  * `customFds` {Array} **Deprecated** File descriptors for the child to use
    for stdio.  (See below)
  * `env` {Object} Environment key-value pairs
  * `setsid` {Boolean}
* return: {ChildProcess object}
-->

<ul>
<li><code>command</code> {String} 実行するコマンド</li>
<li><code>args</code> {Array} 文字列による引数の配列</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>
<li><code>customFds</code> {Array} <strong>Deprecated</strong> 子プロセスが標準入出力として使用する
ファイル記述子の配列 (後述)</li>
<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>
<li><code>setsid</code> {Boolean}</li>
</ul>
</li>
<li>return: {ChildProcess object}</li>
</ul>
<!--
Launches a new process with the given `command`, with  command line arguments in `args`.
If omitted, `args` defaults to an empty Array.
-->

<p><code>args</code> をコマンドライン引数として、与えられた <code>command</code> で新しいプロセスを起動します。
<code>args</code> が省略された場合、空の配列がデフォルトとなります。

</p>
<!--
The third argument is used to specify additional options, which defaults to:
-->

<p>第 3 引数は追加のオプションを指定するために使われ、そのデフォルトは:

</p>
<pre><code>{ cwd: undefined,
  env: process.env
}</code></pre>
<!--
`cwd` allows you to specify the working directory from which the process is spawned.
Use `env` to specify environment variables that will be visible to the new process.
-->

<p><code>cwd</code> で起動されたプロセスのワーキングディレクトリを指定することができます。
<code>env</code> は新しいプロセスに見える環境変数を指定するために使います。

</p>
<!--
Example of running `ls -lh /usr`, capturing `stdout`, `stderr`, and the exit code:
-->

<p>ls -lh /usr<code> を実行して </code>stdout<code>、</code>stderr`、および終了コードを取得する例:

</p>
<pre><code>var util  = require(&apos;util&apos;),
    spawn = require(&apos;child_process&apos;).spawn,
    ls    = spawn(&apos;ls&apos;, [&apos;-lh&apos;, &apos;/usr&apos;]);

ls.stdout.on(&apos;data&apos;, function (data) {
  console.log(&apos;stdout: &apos; + data);
});

ls.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;stderr: &apos; + data);
});

ls.on(&apos;exit&apos;, function (code) {
  console.log(&apos;child process exited with code &apos; + code);
});</code></pre>
<!--
Example: A very elaborate way to run 'ps ax | grep ssh'
-->

<p>とても手の込んだ方法で実行する &apos;ps ax | grep ssh&apos; の例:

</p>
<pre><code>var util  = require(&apos;util&apos;),
    spawn = require(&apos;child_process&apos;).spawn,
    ps    = spawn(&apos;ps&apos;, [&apos;ax&apos;]),
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

ps.stdout.on(&apos;data&apos;, function (data) {
  grep.stdin.write(data);
});

ps.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;ps stderr: &apos; + data);
});

ps.on(&apos;exit&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;ps process exited with code &apos; + code);
  }
  grep.stdin.end();
});

grep.stdout.on(&apos;data&apos;, function (data) {
  console.log(data);
});

grep.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;grep stderr: &apos; + data);
});

grep.on(&apos;exit&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;grep process exited with code &apos; + code);
  }
});</code></pre>
<!--
Example of checking for failed exec:
-->

<p>exec の失敗をチェックする例:

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    child = spawn(&apos;bad_command&apos;);

child.stderr.setEncoding(&apos;utf8&apos;);
child.stderr.on(&apos;data&apos;, function (data) {
  if (/^execvp\(\)/.test(data)) {
    console.log(&apos;Failed to start child process.&apos;);
  }
});</code></pre>
<!--
Note that if spawn receives an empty options object, it will result in
spawning the process with an empty environment rather than using
`process.env`. This due to backwards compatibility issues with a deprecated
API.
-->

<p><code>spawn()</code> は空の <code>options</code> オブジェクトを受け取ると、
<code>process.env</code> を使うのではなく，空の環境変数で子プロセスを起動します。
これは廃止された API との互換性のためです。

</p>
<!--
There is a deprecated option called `customFds` which allows one to specify
specific file descriptors for the stdio of the child process. This API was
not portable to all platforms and therefore removed.
With `customFds` it was possible to hook up the new process' `[stdin, stdout,
stderr]` to existing streams; `-1` meant that a new stream should be created.
Use at your own risk.

There are several internal options. In particular `stdinStream`,
`stdoutStream`, `stderrStream`. They are for INTERNAL USE ONLY. As with all
undocumented APIs in Node, they should not be used.

See also: `child_process.exec()` and `child_process.fork()`
-->

<p>指定のファイル記述子を子プロセスの標準入出力に指定することを可能にする、
<code>customFds</code> と呼ばれる廃止されたオプションがありました。
この API は全てのプラットフォームに移植可能ではないために削除されました。
<code>customFds</code> は新しいプロセスの <code>[stdin, stdout, stderr]</code> を既存のストリームに接続することを可能にしました;
<code>-1</code> は新しいストリームが作られなければならないことを意味していました。
使用する場合は自己責任で。

</p>
<p>よく似た内部的なオプションがあります。
具体的には <code>stdinStream</code>、<code>stdoutStream</code>、<code>stderrStream</code> です。
これらは <strong>内部用途</strong>です。
Node のドキュメント化されていない API と同様に、
これらを使用すべきではありません。

</p>
<p>関連項目: <code>child_process.exec()</code> および <code>child_process.fork()</code>

</p>
<h2>child_process.exec(command, [options], callback)<span><a class="mark" href="#all_child_process_exec_command_options_callback" id="all_child_process_exec_command_options_callback">#</a></span></h2>
<!--
* `command` {String} The command to run, with space-separated arguments
* `options` {Object}
  * `cwd` {String} Current working directory of the child process
  * `customFds` {Array} **Deprecated** File descriptors for the child to use
    for stdio.  (See below)
  * `env` {Object} Environment key-value pairs
  * `setsid` {Boolean}
  * `encoding` {String} (Default: 'utf8')
  * `timeout` {Number} (Default: 0)
  * `maxBuffer` {Number} (Default: 200*1024)
  * `killSignal` {String} (Default: 'SIGTERM')
* `callback` {Function} called with the output when process terminates
  * `code` {Integer} Exit code
  * `stdout` {Buffer}
  * `stderr` {Buffer}
* Return: ChildProcess object
-->

<ul>
<li><code>command</code> {String} 実行するコマンド、空白で区切られた引数を持ちます</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>
<li><code>customFds</code> {Array} <strong>Deprecated</strong> 子プロセスが標準入出力として使用する
ファイル記述子の配列 (後述)</li>
<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>
<li><code>setsid</code> {Boolean}</li>
<li><code>encoding</code> {String} (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> {Number} (Default: 0)</li>
<li><code>maxBuffer</code> {Number} (Default: 200*1024)</li>
<li><code>killSignal</code> {String} (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> {Function} プロセスが終了するとその出力を伴って呼び出されます<ul>
<li><code>code</code> {Integer} 終了コード</li>
<li><code>stdout</code> {Buffer}</li>
<li><code>stderr</code> {Buffer}</li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</ul>
<!--
Runs a command in a shell and buffers the output.
-->

<p>コマンドをシェルで実行し、その出力をバッファに格納します。

</p>
<pre><code>var util = require(&apos;util&apos;),
    exec = require(&apos;child_process&apos;).exec,
    child;

child = exec(&apos;cat *.js bad_file | wc -l&apos;,
  function (error, stdout, stderr) {
    console.log(&apos;stdout: &apos; + stdout);
    console.log(&apos;stderr: &apos; + stderr);
    if (error !== null) {
      console.log(&apos;exec error: &apos; + error);
    }
});</code></pre>
<!--
The callback gets the arguments `(error, stdout, stderr)`. On success, `error`
will be `null`.  On error, `error` will be an instance of `Error` and `err.code`
will be the exit code of the child process, and `err.signal` will be set to the
signal that terminated the process.
-->

<p>コールバックは引数 <code>(error, stdout, stderr)</code> を得ます。
成功すると、<code>error</code> は <code>null</code> になります。
エラーだと、<code>error</code> は <code>Error</code> のインスタンスとなり、
<code>err.code</code> は子プロセスの終了コード、
<code>err.signal</code> はプロセスを終了させたシグナルとなります。

</p>
<!--
There is a second optional argument to specify several options. The
default options are
-->

<p>任意の第 2 引数でいくつかのオプションを指定することができます。
オプションのデフォルトは

</p>
<pre><code>{ encoding: &apos;utf8&apos;,
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: &apos;SIGTERM&apos;,
  cwd: null,
  env: null }</code></pre>
<!--
If `timeout` is greater than 0, then it will kill the child process
if it runs longer than `timeout` milliseconds. The child process is killed with
`killSignal` (default: `'SIGTERM'`). `maxBuffer` specifies the largest
amount of data allowed on stdout or stderr - if this value is exceeded then
the child process is killed.
-->

<p>もし <code>timeout</code> が 0 より大きいと、
子プロセスは実行時間が <code>timeout</code> ミリ秒よりも長くなると kill されます。
子プロセスは <code>killSignal</code> で kill されます (デフォルト: <code>&apos;SIGTERM&apos;</code>)。
<code>maxBuffer</code> は標準出力と標準エラーの最大のデータ量を指定します － この値を超えると子プロセスは kill されます。


</p>
<h2>child_process.execFile(file, args, options, callback)<span><a class="mark" href="#all_child_process_execfile_file_args_options_callback" id="all_child_process_execfile_file_args_options_callback">#</a></span></h2>
<!--
* `file` {String} The filename of the program to run
* `args` {Array} List of string arguments
* `options` {Object}
  * `cwd` {String} Current working directory of the child process
  * `customFds` {Array} **Deprecated** File descriptors for the child to use
    for stdio.  (See below)
  * `env` {Object} Environment key-value pairs
  * `setsid` {Boolean}
  * `encoding` {String} (Default: 'utf8')
  * `timeout` {Number} (Default: 0)
  * `maxBuffer` {Number} (Default: 200*1024)
  * `killSignal` {String} (Default: 'SIGTERM')
* `callback` {Function} called with the output when process terminates
  * `code` {Integer} Exit code
  * `stdout` {Buffer}
  * `stderr` {Buffer}
* Return: ChildProcess object
-->

<ul>
<li><code>file</code> {String} 実行するプログラムのファイル名</li>
<li><code>args</code> {Array} 文字列による引数の配列</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>
<li><code>customFds</code> {Array} <strong>Deprecated</strong> 子プロセスが標準入出力として使用する
ファイル記述子の配列 (後述)</li>
<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>
<li><code>setsid</code> {Boolean}</li>
<li><code>encoding</code> {String} (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> {Number} (Default: 0)</li>
<li><code>maxBuffer</code> {Number} (Default: 200*1024)</li>
<li><code>killSignal</code> {String} (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> {Function} プロセスが終了するとその出力を伴って呼び出されます<ul>
<li><code>code</code> {Integer} 終了コード</li>
<li><code>stdout</code> {Buffer}</li>
<li><code>stderr</code> {Buffer}</li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</ul>
<!--
This is similar to `child_process.exec()` except it does not execute a
subshell but rather the specified file directly. This makes it slightly
leaner than `child_process.exec`. It has the same options.
-->

<p>子シェルで実行する代わりに指定されたファイルを直接実行することを除いて
<code>child_process.exec()</code> と同様です。
これは <code>child_process.exec</code> より若干効率的で、同じオプションを持ちます。


</p>
<h2>child_process.fork(modulePath, [args], [options])<span><a class="mark" href="#all_child_process_fork_modulepath_args_options" id="all_child_process_fork_modulepath_args_options">#</a></span></h2>
<!--
* `modulePath` {String} The module to run in the child
* `args` {Array} List of string arguments
* `options` {Object}
  * `cwd` {String} Current working directory of the child process
  * `customFds` {Array} **Deprecated** File descriptors for the child to use
    for stdio.  (See below)
  * `env` {Object} Environment key-value pairs
  * `setsid` {Boolean}
  * `encoding` {String} (Default: 'utf8')
  * `timeout` {Number} (Default: 0)
* Return: ChildProcess object
-->

<ul>
<li><code>modulePath</code> {String} 子プロセスで実行するモジュール</li>
<li><code>args</code> {Array} 文字列による引数の配列</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>
<li><code>customFds</code> {Array} <strong>Deprecated</strong> 子プロセスが標準入出力として使用する
ファイル記述子の配列 (後述)</li>
<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>
<li><code>setsid</code> {Boolean}</li>
<li><code>encoding</code> {String} (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> {Number} (Default: 0)</li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</ul>
<!--
This is a special case of the `spawn()` functionality for spawning Node
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. The
channel is written to with `child.send(message, [sendHandle])` and messages
are received by a `'message'` event on the child.
-->

<p>これは <code>spawn()</code> の特別版で、Node プロセスを起動します。
返されるオブジェクトは通常の ChildProcess の全てのメソッドに加えて、
組み込みの通信チャネルを持ちます。
チャネルは <code>child.send(message, [sendHandle])</code> によって書き込まれ、
メッセージを受信すると <code>child</code> 上で <code>&apos;message&apos;</code> イベントが生成されます。

</p>
<!--
For example:
-->

<p>例:

</p>
<pre><code>var cp = require(&apos;child_process&apos;);

var n = cp.fork(__dirname + &apos;/sub.js&apos;);

n.on(&apos;message&apos;, function(m) {
  console.log(&apos;PARENT got message:&apos;, m);
});

n.send({ hello: &apos;world&apos; });</code></pre>
<!--
And then the child script, `'sub.js'` might look like this:
-->

<p>そして子スクリプトの <code>&apos;sub.js&apos;</code> は次のようになります:

</p>
<pre><code>process.on(&apos;message&apos;, function(m) {
  console.log(&apos;CHILD got message:&apos;, m);
});

process.send({ foo: &apos;bar&apos; });</code></pre>
<!--
In the child the `process` object will have a `send()` method, and `process`
will emit objects each time it receives a message on its channel.
-->

<p>子供の <code>process</code> オブジェクトは <code>send()</code> メソッドを持ち、
<code>process</code> はチャネルでメッセージを受信するたびにイベントを生成します。

</p>
<!--
By default the spawned Node process will have the stdin, stdout, stderr
associated with the parent's.
-->

<p>デフォルトでは、起動された Node プロセスは親プロセスに関連づけられた標準入力、
標準出力、標準エラー出力を持ちます。

</p>
<!--
These child Nodes are still whole new instances of V8. Assume at least 30ms
startup and 10mb memory for each new Node. That is, you cannot create many
thousands of them.
-->

<p>これらの子 Node は、やはり V8 の新しいインスタンスです。
新しい Node ごとに少なくとも 30 ミリ秒の起動時間と 
10MB のメモリを前提としてください。
つまり、数千の子プロセスを作ることは出来ません。

</p>
<!--
The `sendHandle` option to `child.send()` is for sending a handle object to
another process. Child will receive the handle as as second argument to the
`message` event. Here is an example of sending a handle:
-->

<p><code>child.send()</code> の <code>sendHandle</code> オプションはハンドルオブジェクトを別プロセスに
送ります。
子プロセスはそのハンドルを <code>message</code> イベントの第2引数として受け取ります。
これはハンドルを送信するサンプルです。


</p>
<pre><code>var server = require(&apos;net&apos;).createServer();
var child = require(&apos;child_process&apos;).fork(__dirname + &apos;/child.js&apos;);
// Open up the server object and send the handle.
server.listen(1337, function() {
  child.send({ server: true }, server._handle);
});</code></pre>
<!--
Here is an example of receiving the server handle and sharing it between
processes:
-->

<p>これはサーバのハンドルを受信してプロセス間で共有するサンプルです。


</p>
<pre><code>process.on(&apos;message&apos;, function(m, serverHandle) {
  if (serverHandle) {
    var server = require(&apos;net&apos;).createServer();
    server.listen(serverHandle);
  }
});</code></pre>
<h1>Assert<span><a class="mark" href="#all_assert" id="all_assert">#</a></span></h1>
<pre><code>Stability: 5 - Locked</code></pre>
<!--
This module is used for writing unit tests for your applications, you can
access it with `require('assert')`.
-->

<p>このモジュールはアプリケーションの単体テストを記述するために使用され、
<code>require(&apos;assert&apos;)</code> でアクセスできます。

</p>
<h2>assert.fail(actual, expected, message, operator)<span><a class="mark" href="#all_assert_fail_actual_expected_message_operator" id="all_assert_fail_actual_expected_message_operator">#</a></span></h2>
<!--
Throws an exception that displays the values for `actual` and `expected` separated by the provided operator.
-->

<p><code>actual</code> と <code>expected</code> を <code>operator</code> で区切ったメッセージを持つ例外を
スローします。

</p>
<h2>assert(value, message), assert.ok(value, [message])<span><a class="mark" href="#all_assert_value_message_assert_ok_value_message" id="all_assert_value_message_assert_ok_value_message">#</a></span></h2>
<!--
Tests if value is a `true` value, it is equivalent to `assert.equal(true, value, message);`
-->

<p><code>value</code> が <code>true</code> かテストします、
これは <code>assert.equal(true, value, message);</code> と等価です。

</p>
<h2>assert.equal(actual, expected, [message])<span><a class="mark" href="#all_assert_equal_actual_expected_message" id="all_assert_equal_actual_expected_message">#</a></span></h2>
<!--
Tests shallow, coercive equality with the equal comparison operator ( `==` ).
-->

<p><code>==</code> 演算子を強制して浅い同値性をテストします。

</p>
<h2>assert.notEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notequal_actual_expected_message" id="all_assert_notequal_actual_expected_message">#</a></span></h2>
<!--
Tests shallow, coercive non-equality with the not equal comparison operator ( `!=` ).
-->

<p><code>==</code> 演算子を強制して浅い非同値性をテストします。

</p>
<h2>assert.deepEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_deepequal_actual_expected_message" id="all_assert_deepequal_actual_expected_message">#</a></span></h2>
<!--
Tests for deep equality.
-->

<p>深い同値性をテストします。

</p>
<h2>assert.notDeepEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notdeepequal_actual_expected_message" id="all_assert_notdeepequal_actual_expected_message">#</a></span></h2>
<!--
Tests for any deep inequality.
-->

<p>深い非同値性をテストします。

</p>
<h2>assert.strictEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_strictequal_actual_expected_message" id="all_assert_strictequal_actual_expected_message">#</a></span></h2>
<!--
Tests strict equality, as determined by the strict equality operator ( `===` )
-->

<p><code>===</code> 演算子で厳密な同値性をテストします。

</p>
<h2>assert.notStrictEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notstrictequal_actual_expected_message" id="all_assert_notstrictequal_actual_expected_message">#</a></span></h2>
<!--
Tests strict non-equality, as determined by the strict not equal operator ( `!==` )
-->

<p><code>!==</code> 演算子で厳密な非同値性をテストします。

</p>
<h2>assert.throws(block, [error], [message])<span><a class="mark" href="#all_assert_throws_block_error_message" id="all_assert_throws_block_error_message">#</a></span></h2>
<!--
Expects `block` to throw an error. `error` can be constructor, regexp or 
validation function.
-->

<p><code>block</code> がエラーをスローすることを期待します。
<code>error</code> はコンストラクタ、正規表現、または検証関数にすることができます。

</p>
<!--
Validate instanceof using constructor:
-->

<p>コンストラクタを使って instanceof で検証:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  Error
);</code></pre>
<!--
Validate error message using RegExp:
-->

<p>正規表現を使ってエラーメッセージを検証:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  /value/
);</code></pre>
<!--
Custom error validation:
-->

<p>独自のエラー検証:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  &quot;unexpected error&quot;
);</code></pre>
<h2>assert.doesNotThrow(block, [error], [message])<span><a class="mark" href="#all_assert_doesnotthrow_block_error_message" id="all_assert_doesnotthrow_block_error_message">#</a></span></h2>
<!--
Expects `block` not to throw an error, see assert.throws for details.
-->

<p><code>block</code> がエラーをスローしないことを期待します。
詳細は assert.throws を参照してください。

</p>
<h2>assert.ifError(value)<span><a class="mark" href="#all_assert_iferror_value" id="all_assert_iferror_value">#</a></span></h2>
<!--
Tests if value is not a false value, throws if it is a true value. Useful when
testing the first argument, `error` in callbacks.
-->

<p><code>value</code> が false でないことをテストし、true だったらそれをスローします。
コールバックの第 1 引数である <code>error</code> をテストするのに便利です。

</p>
<h1>TTY<span><a class="mark" href="#all_tty" id="all_tty">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
Use `require('tty')` to access this module.
-->

<p><code>require(&apos;tty&apos;)</code> でこのモジュールにアクセスします。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var tty = require(&apos;tty&apos;);
process.stdin.resume();
tty.setRawMode(true);
process.stdin.on(&apos;keypress&apos;, function(char, key) {
  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == &apos;c&apos;) {
    console.log(&apos;graceful exit&apos;);
    process.exit()
  }
});</code></pre>
<h2>tty.isatty(fd)<span><a class="mark" href="#all_tty_isatty_fd" id="all_tty_isatty_fd">#</a></span></h2>
<!--
Returns `true` or `false` depending on if the `fd` is associated with a
terminal.
-->

<p><code>fd</code> が端末に関連づけられているかどうかを <code>true</code> または <code>false</code> で返します。


</p>
<h2>tty.setRawMode(mode)<span><a class="mark" href="#all_tty_setrawmode_mode" id="all_tty_setrawmode_mode">#</a></span></h2>
<!--
`mode` should be `true` or `false`. This sets the properties of the current
process's stdin fd to act either as a raw device or default.
-->

<p><code>mode</code> は <code>true</code> または <code>false</code> です。
これは現在のプロセスの標準入力ファイル記述子をローデバイスまたはデフォルトに振る舞うよう設定します。


</p>
<h1>Zlib<span><a class="mark" href="#all_zlib" id="all_zlib">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--
You can access this module with:
-->

<p>このモジュールは次のようにアクセスできます。

</p>
<pre><code>var zlib = require(&apos;zlib&apos;);</code></pre>
<!--
This provides bindings to Gzip/Gunzip, Deflate/Inflate, and
DeflateRaw/InflateRaw classes.  Each class takes the same options, and
is a readable/writable Stream.
-->

<p>これは Gzip/Gunzip、Deflate/Inflate、そして DeflateRaw/InflateRaw
へバインディングするクラスを提供します。
どのクラスも同じオプションを持つ、読み込みと書き込みが可能なストリームです。

</p>
<h2>Examples<span><a class="mark" href="#all_examples" id="all_examples">#</a></span></h2>
<!--
Compressing or decompressing a file can be done by piping an
fs.ReadStream into a zlib stream, then into an fs.WriteStream.
-->

<p>ファイルを圧縮および解凍するには、fs.ReadStream から zlib へ、
そして fs.WriteStream へパイプをつなぐだけです。

</p>
<pre><code>var gzip = zlib.createGzip();
var fs = require(&apos;fs&apos;);
var inp = fs.createReadStream(&apos;input.txt&apos;);
var out = fs.createWriteStream(&apos;input.txt.gz&apos;);

inp.pipe(gzip).pipe(out);</code></pre>
<!--
Compressing or decompressing data in one step can be done by using
the convenience methods.
-->

<p>データの圧縮または解凍は <a href="#convenience_Methods">簡易メソッド</a>
を使うことにより、ワンステップで行うことができます。

</p>
<pre><code>var input = &apos;.................................&apos;;
zlib.deflate(input, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString(&apos;base64&apos;));
  }
});

var buffer = new Buffer(&apos;eJzT0yMAAGTvBe8=&apos;, &apos;base64&apos;);
zlib.unzip(buffer, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString());
  }
});</code></pre>
<!--
To use this module in an HTTP client or server, use the
[accept-encoding](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3)
on requests, and the
[content-encoding](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11)
header on responses.

**Note: these examples are drastically simplified to show
the basic concept.**  Zlib encoding can be expensive, and the results
ought to be cached.  See [Memory Usage Tuning](#memory_Usage_Tuning)
below for more information on the speed/memory/compression
tradeoffs involved in zlib usage.
-->

<p>このモジュールを HTTP クライアントとサーバで使うには、リクエストに
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a>
ヘッダを、レスポンスに
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a>
ヘッダを使用します。

</p>
<p><strong>注意:
これらのサンプルは基本コンセプトを見せるためにとても単純化されています。</strong>
Zlib エンコーディングは高価なので、結果はキャッシュされるべきです。
zlibの使い方に関する速度／メモリ／圧縮率のトレードオフについてより詳しくは、
後述の <a href="#memory_Usage_Tuning">Memory Usage Tuning</a> を参照してください。

</p>
<pre><code>// client request example
var zlib = require(&apos;zlib&apos;);
var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
var request = http.get({ host: &apos;izs.me&apos;,
                         path: &apos;/&apos;,
                         port: 80,
                         headers: { &apos;accept-encoding&apos;: &apos;gzip,deflate&apos; } });
request.on(&apos;response&apos;, function(response) {
  var output = fs.createWriteStream(&apos;izs.me_index.html&apos;);

  switch (response.headers[&apos;content-encoding&apos;]) {
    // or, just use zlib.createUnzip() to handle both cases
    case &apos;gzip&apos;:
      response.pipe(zlib.createGunzip()).pipe(output);
      break;
    case &apos;deflate&apos;:
      response.pipe(zlib.createInflate()).pipe(output);
      break;
    default:
      response.pipe(output);
      break;
  }
});

// server example
// Running a gzip operation on every request is quite expensive.
// It would be much more efficient to cache the compressed buffer.
var zlib = require(&apos;zlib&apos;);
var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
http.createServer(function(request, response) {
  var raw = fs.createReadStream(&apos;index.html&apos;);
  var acceptEncoding = request.headers[&apos;accept-encoding&apos;];
  if (!acceptEncoding) {
    acceptEncoding = &apos;&apos;;
  }

  // Note: this is not a conformant accept-encoding parser.
  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
  if (acceptEncoding.match(/\bdeflate\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;deflate&apos; });
    raw.pipe(zlib.createDeflate()).pipe(response);
  } else if (acceptEncoding.match(/\bgzip\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;gzip&apos; });
    raw.pipe(zlib.createGzip()).pipe(response);
  } else {
    response.writeHead(200, {});
    raw.pipe(response);
  }
}).listen(1337);</code></pre>
<h2>Constants<span><a class="mark" href="#all_constants" id="all_constants">#</a></span></h2>
<!--type=misc-->

<!--
All of the constants defined in zlib.h are also defined on
`require('zlib')`.  They are described in more detail in the zlib
documentation.  See <http://zlib.net/manual.html#Constants>
for more details.
-->

<p>zlib.h に定義された定数は <code>require(&apos;zlib&apos;)</code> でも定義されます。
それらは zlib のドキュメントでより詳しく説明されます。
詳細は <a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a> を参照してください。

</p>
<h2>zlib.createGzip([options])<span><a class="mark" href="#all_zlib_creategzip_options" id="all_zlib_creategzip_options">#</a></span></h2>
<!--
Returns a new [Gzip](#zlib.Gzip) object with an [options](#options).
-->

<p><a href="#options">options</a> によって作られた新しい <a href="#zlib.Gzip">Gzip</a>
オブジェクトを返します。

</p>
<h2>zlib.createGunzip([options])<span><a class="mark" href="#all_zlib_creategunzip_options" id="all_zlib_creategunzip_options">#</a></span></h2>
<!--
Returns a new [Gunzip](#zlib.Gunzip) object with an [options](#options).
-->

<p><a href="#options">options</a> によって作られた新しい <a href="#zlib.Gunzip">Gunzip</a>
オブジェクトを返します。

</p>
<h2>zlib.createDeflate([options])<span><a class="mark" href="#all_zlib_createdeflate_options" id="all_zlib_createdeflate_options">#</a></span></h2>
<!--
Returns a new [Deflate](#zlib.Deflate) object with an [options](#options).
-->

<p><a href="#options">options</a> によって作られた新しい <a href="#zlib.Deflate">Deflate</a>
オブジェクトを返します。

</p>
<h2>zlib.createInflate([options])<span><a class="mark" href="#all_zlib_createinflate_options" id="all_zlib_createinflate_options">#</a></span></h2>
<!--
Returns a new [Inflate](#zlib.Inflate) object with an [options](#options).
-->

<p><a href="#options">options</a> によって作られた新しい <a href="#zlib.Inflate">Inflate</a>
オブジェクトを返します。

</p>
<h2>zlib.createDeflateRaw([options])<span><a class="mark" href="#all_zlib_createdeflateraw_options" id="all_zlib_createdeflateraw_options">#</a></span></h2>
<!--
Returns a new [DeflateRaw](#zlib.DeflateRaw) object with an [options](#options).
-->

<p><a href="#options">options</a> によって作られた新しい <a href="#zlib.DeflateRaw">DeflateRaw</a>
オブジェクトを返します。

</p>
<h2>zlib.createInflateRaw([options])<span><a class="mark" href="#all_zlib_createinflateraw_options" id="all_zlib_createinflateraw_options">#</a></span></h2>
<!--
Returns a new [InflateRaw](#zlib.InflateRaw) object with an [options](#options).
-->

<p><a href="#options">options</a> によって作られた新しい <a href="#zlib.InflateRaw">InflateRaw</a>
オブジェクトを返します。

</p>
<h2>zlib.createUnzip([options])<span><a class="mark" href="#all_zlib_createunzip_options" id="all_zlib_createunzip_options">#</a></span></h2>
<!--
Returns a new [Unzip](#zlib.Unzip) object with an [options](#options).
-->

<p><a href="#options">options</a> によって作られた新しい <a href="#zlib.Unzip">Unzip</a>
オブジェクトを返します。


</p>
<h2>Class: zlib.Gzip<span><a class="mark" href="#all_class_zlib_gzip" id="all_class_zlib_gzip">#</a></span></h2>
<!--
Compress data using gzip.
-->

<p>gzip を使ってデータを圧縮します。

</p>
<h2>Class: zlib.Gunzip<span><a class="mark" href="#all_class_zlib_gunzip" id="all_class_zlib_gunzip">#</a></span></h2>
<!--
Decompress a gzip stream.
-->

<p>gzip ストリームを解凍します。

</p>
<h2>Class: zlib.Deflate<span><a class="mark" href="#all_class_zlib_deflate" id="all_class_zlib_deflate">#</a></span></h2>
<!--
Compress data using deflate.
-->

<p>deflate を使ってデータを圧縮します。

</p>
<h2>Class: zlib.Inflate<span><a class="mark" href="#all_class_zlib_inflate" id="all_class_zlib_inflate">#</a></span></h2>
<!--
Decompress a deflate stream.
-->

<p>deflate ストリームを解凍します。

</p>
<h2>Class: zlib.DeflateRaw<span><a class="mark" href="#all_class_zlib_deflateraw" id="all_class_zlib_deflateraw">#</a></span></h2>
<!--
Compress data using deflate, and do not append a zlib header.
-->

<p>deflate を使ってデータを圧縮しますが、zlib ヘッダを付加しません。

</p>
<h2>Class: zlib.InflateRaw<span><a class="mark" href="#all_class_zlib_inflateraw" id="all_class_zlib_inflateraw">#</a></span></h2>
<!--
Decompress a raw deflate stream.
-->

<p>生の deflate ストリームを解凍します。

</p>
<h2>Class: zlib.Unzip<span><a class="mark" href="#all_class_zlib_unzip" id="all_class_zlib_unzip">#</a></span></h2>
<!--
Decompress either a Gzip- or Deflate-compressed stream by auto-detecting
the header.
-->

<p>Gzip または Deflate で圧縮されたストリームをヘッダで自動判別して解凍します。

</p>
<h2>Convenience Methods<span><a class="mark" href="#all_convenience_methods" id="all_convenience_methods">#</a></span></h2>
<!--type=misc-->

<!--
All of these take a string or buffer as the first argument, and call the
supplied callback with `callback(error, result)`.  The
compression/decompression engine is created using the default settings
in all convenience methods.  To supply different options, use the
zlib classes directly.
-->

<p>これらは全て第 1 引数として文字列またはバッファを受け取り、
与えられたコールバック <code>callback(error, result)</code> を呼び出します。
全ての簡易メソッドで、圧縮・解凍エンジンはデフォルトの設定で作成されます。
異なったオプションを与えるには、zlib のクラスを直接使用してください。

</p>
<h2>zlib.deflate(buf, callback)<span><a class="mark" href="#all_zlib_deflate_buf_callback" id="all_zlib_deflate_buf_callback">#</a></span></h2>
<!--
Compress a string with Deflate.
-->

<p>Deflate で文字列を圧縮します。

</p>
<h2>zlib.deflateRaw(buf, callback)<span><a class="mark" href="#all_zlib_deflateraw_buf_callback" id="all_zlib_deflateraw_buf_callback">#</a></span></h2>
<!--
Compress a string with DeflateRaw.
-->

<p>DeflateRaw で文字列を圧縮します。

</p>
<h2>zlib.gzip(buf, callback)<span><a class="mark" href="#all_zlib_gzip_buf_callback" id="all_zlib_gzip_buf_callback">#</a></span></h2>
<!--
Compress a string with Gzip.
-->

<p>Gzip で文字列を圧縮します。

</p>
<h2>zlib.gunzip(buf, callback)<span><a class="mark" href="#all_zlib_gunzip_buf_callback" id="all_zlib_gunzip_buf_callback">#</a></span></h2>
<!--
Decompress a raw Buffer with Gunzip.
-->

<p>Gunzip で生のバッファを解凍します。

</p>
<h2>zlib.inflate(buf, callback)<span><a class="mark" href="#all_zlib_inflate_buf_callback" id="all_zlib_inflate_buf_callback">#</a></span></h2>
<!--
Decompress a raw Buffer with Inflate.
-->

<p>Infrate で生のバッファを解凍します。

</p>
<h2>zlib.inflateRaw(buf, callback)<span><a class="mark" href="#all_zlib_inflateraw_buf_callback" id="all_zlib_inflateraw_buf_callback">#</a></span></h2>
<!--
Decompress a raw Buffer with InflateRaw.
-->

<p>InflateRaw で生のバッファを解凍します。

</p>
<h2>zlib.unzip(buf, callback)<span><a class="mark" href="#all_zlib_unzip_buf_callback" id="all_zlib_unzip_buf_callback">#</a></span></h2>
<!--
Decompress a raw Buffer with Unzip.
-->

<p>Unzip で生のバッファを解凍します。

</p>
<h2>Options<span><a class="mark" href="#all_options" id="all_options">#</a></span></h2>
<!--type=misc-->

<!--
Each class takes an options object.  All options are optional.  (The
convenience methods use the default settings for all options.)

Note that some options are only
relevant when compressing, and are ignored by the decompression classes.

* chunkSize (default: 16*1024)
* windowBits
* level (compression only)
* memLevel (compression only)
* strategy (compression only)

See the description of `deflateInit2` and `inflateInit2` at
<http://zlib.net/manual.html#Advanced> for more information on these.
-->

<p>どのクラスもオプションオブジェクトを受け取ります。
全てのオプションは任意です
(簡易メソッドは全てのオプションでデフォルト値を使用します)。

</p>
<p>いくつかのオプションは圧縮にだけ関連し、
解凍するクラスでは無視されることに注意してください。

</p>
<ul>
<li>chunkSize (デフォルト: 16*1024)</li>
<li>windowBits</li>
<li>level (圧縮のみ)</li>
<li>memLevel (圧縮のみ)</li>
<li>strategy (圧縮のみ)</li>
</ul>
<p>これらの詳細は <a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> の
<code>deflateInit2</code> および <code>inflateInit2</code> の説明を参照してください。

</p>
<h2>Memory Usage Tuning<span><a class="mark" href="#all_memory_usage_tuning" id="all_memory_usage_tuning">#</a></span></h2>
<!--type=misc-->

<!--
From `zlib/zconf.h`, modified to node's usage:

The memory requirements for deflate are (in bytes):
-->

<p>node は <code>zlib/zconf.h</code> を変更して使っています:

</p>
<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>
<!--
that is: 128K for windowBits=15  +  128K for memLevel = 8
(default values) plus a few kilobytes for small objects.

For example, if you want to reduce
the default memory requirements from 256K to 128K, set the options to:
-->

<p>すなわち: windowBits = 15 の場合 128K + 
memLevel = 8 の場合 128K (デフォルト値) に加えて数キロバイトが
小さなオブジェクトのために使われます。

</p>
<p>たとえば、デフォルトで要求されるメモリを 256K から 128K へ縮小したければ、
次のオプションを設定します:

</p>
<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>
<!--
Of course this will generally degrade compression (there's no free lunch).

The memory requirements for inflate are (in bytes)
-->

<p>もちろん、これは圧縮率を悪化します (ただ飯ははありません)。


</p>
<pre><code>1 &lt;&lt; windowBits</code></pre>
<!--
that is, 32K for windowBits=15 (default value) plus a few kilobytes
for small objects.

This is in addition to a single internal output slab buffer of size
`chunkSize`, which defaults to 16K.

The speed of zlib compression is affected most dramatically by the
`level` setting.  A higher level will result in better compression, but
will take longer to complete.  A lower level will result in less
compression, but will be much faster.

In general, greater memory usage options will mean that node has to make
fewer calls to zlib, since it'll be able to process more data in a
single `write` operation.  So, this is another factor that affects the
speed, at the cost of memory usage.
-->

<p>この場合、windowBits=15 (デフォルト値) の場合 32K に加えて数キロバイトが
小さなオブジェクトのために使われます。

</p>
<p>これは、デフォルト値 16K の <code>chunkSize</code> で指定されたサイズの内部バッファに加えられます。

</p>
<p>zlib の圧縮速度は <code>level</code> の設定で劇的に変化します
高レベルにするとより圧縮できますが、完了までの時間が長くなります。
低レベルにするとあまり圧縮されませんが、高速になります。

</p>
<p>一般的に、メモリをより多く使うオプションにすると node が zlib を呼び出す回数が
少なくなることを意味し、
一回の <code>write</code> 操作でより多くのデータを処理できることになります。
これはあスピードに影響するもう一つのファクタで、メモリ使用量を犠牲にします。

</p>
<h1>os<span><a class="mark" href="#all_os" id="all_os">#</a></span></h1>
<pre><code>Stability: 4 - API Frozen</code></pre>
<p>Provides a few basic operating-system related utility functions.

</p>
<!--
Use `require('os')` to access this module.
-->

<p><code>require(&apos;os&apos;)</code> によってこのモジュールにアクセスします。

</p>
<h2>os.hostname()<span><a class="mark" href="#all_os_hostname" id="all_os_hostname">#</a></span></h2>
<!--
Returns the hostname of the operating system.
-->

<p>オペレーティングシステムのホスト名を返します。

</p>
<h2>os.type()<span><a class="mark" href="#all_os_type" id="all_os_type">#</a></span></h2>
<!--
Returns the operating system name.
-->

<p>オペレーティングシステムの名前を返します。

</p>
<h2>os.platform()<span><a class="mark" href="#all_os_platform" id="all_os_platform">#</a></span></h2>
<!--
Returns the operating system platform.
-->

<p>プラットフォームのオペレーティングシステムを返します。

</p>
<h2>os.arch()<span><a class="mark" href="#all_os_arch" id="all_os_arch">#</a></span></h2>
<!--
Returns the operating system CPU architecture.
-->

<p>オペレーティングシステムの CPU アーキテクチャを返します。

</p>
<h2>os.release()<span><a class="mark" href="#all_os_release" id="all_os_release">#</a></span></h2>
<!--
Returns the operating system release.
-->

<p>オペレーティングシステムのリリースを返します。

</p>
<h2>os.uptime()<span><a class="mark" href="#all_os_uptime" id="all_os_uptime">#</a></span></h2>
<!--
Returns the system uptime in seconds.
-->

<p>システムが起動してからの秒数を返します。

</p>
<h2>os.loadavg()<span><a class="mark" href="#all_os_loadavg" id="all_os_loadavg">#</a></span></h2>
<!--
Returns an array containing the 1, 5, and 15 minute load averages.
-->

<p>1 分、5 分、15 分間のロードアベレージを含んだ配列を返します。

</p>
<h2>os.totalmem()<span><a class="mark" href="#all_os_totalmem" id="all_os_totalmem">#</a></span></h2>
<!--
Returns the total amount of system memory in bytes.
-->

<p>システム全体が使用しているメモリのバイト数を返します。

</p>
<h2>os.freemem()<span><a class="mark" href="#all_os_freemem" id="all_os_freemem">#</a></span></h2>
<!--
Returns the amount of free system memory in bytes.
-->

<p>システム全体で空いているメモリのバイト数を返します。

</p>
<h2>os.cpus()<span><a class="mark" href="#all_os_cpus" id="all_os_cpus">#</a></span></h2>
<!--
Returns an array of objects containing information about each CPU/core installed: model, speed (in MHz), and times (an object containing the number of CPU ticks spent in: user, nice, sys, idle, and irq).
-->

<p>インストールされている CPU/ コアごとの情報を含んだオブジェクトの配列を返します。
情報はモデル、スピード (MHz)、そして時間 (CPU が使用した user, nice, sys, idle, irq 時間を含んだオブジェクト) です。

</p>
<!--
Example inspection of os.cpus:
-->

<p>os.cpus の例:

</p>
<pre><code>[ { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>
<h2>os.networkInterfaces()<span><a class="mark" href="#all_os_networkinterfaces" id="all_os_networkinterfaces">#</a></span></h2>
<!--
Get a list of network interfaces:
-->

<p>ネットワークインタフェースの一覧を取得します。

</p>
<pre><code>{ lo0: 
   [ { address: &apos;::1&apos;, family: &apos;IPv6&apos;, internal: true },
     { address: &apos;fe80::1&apos;, family: &apos;IPv6&apos;, internal: true },
     { address: &apos;127.0.0.1&apos;, family: &apos;IPv4&apos;, internal: true } ],
  en1: 
   [ { address: &apos;fe80::cabc:c8ff:feef:f996&apos;, family: &apos;IPv6&apos;,
       internal: false },
     { address: &apos;10.0.1.123&apos;, family: &apos;IPv4&apos;, internal: false } ],
  vmnet1: [ { address: &apos;10.99.99.254&apos;, family: &apos;IPv4&apos;, internal: false } ],
  vmnet8: [ { address: &apos;10.88.88.1&apos;, family: &apos;IPv4&apos;, internal: false } ],
  ppp0: [ { address: &apos;10.2.0.231&apos;, family: &apos;IPv4&apos;, internal: false } ] }</code></pre>
<h1>Debugger<span><a class="mark" href="#all_debugger" id="all_debugger">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!-- type=misc -->

<!--
V8 comes with an extensive debugger which is accessible out-of-process via a
simple [TCP protocol](http://code.google.com/p/v8/wiki/DebuggerProtocol).
Node has a built-in client for this debugger. To use this, start Node with the
`debug` argument; a prompt will appear:
-->

<p>V8は外部プロセスから <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP プロトコル</a>経由で接続可能なデバッガを備えています。
Node にはこのデバッガへのクライアントが組み込まれています。
これを使うには、 <code>debug</code> 引数を指定して Node を起動します。
次のようになります:

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt;</code></pre>
<!--
Node's debugger client doesn't support the full range of commands, but
simple step and inspection is possible. By putting the statement `debugger;`
into the source code of your script, you will enable a breakpoint.
-->

<p>Node のデバッガクライアントはあらゆるコマンドを完全にサポートしているわけではありませんが、
単純なステップ実行やインスペクションが可能です。
スクリプトのソースコードに <code>debugger;</code> 文を挿入すると、
ブレークポイントが有効になります。

</p>
<!--
For example, suppose `myscript.js` looked like this:
-->

<p>例えば、<code>myscript.js</code> が次のようだとします:

</p>
<pre><code>// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log(&quot;world&quot;);
}, 1000);
console.log(&quot;hello&quot;);</code></pre>
<!--
Then once the debugger is run, it will break on line 4.
-->

<p>ひとたびデバッガを実行すると、4行目で中断します。

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt; cont
&lt; hello
break in /home/indutny/Code/git/indutny/myscript.js:3
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
debug&gt; next
break in /home/indutny/Code/git/indutny/myscript.js:4
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
debug&gt; repl
Press Ctrl + C to leave debug repl
&gt; x
5
&gt; 2+2
4
debug&gt; next
&lt; world
break in /home/indutny/Code/git/indutny/myscript.js:5
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
  7
debug&gt; quit
%</code></pre>
<!--
The `repl` command allows you to evaluate code remotely. The `next` command
steps over to the next line. There are a few other commands available and more
to come. Type `help` to see others.
-->

<p><code>repl</code> コマンドはコードをリモートで評価します。
<code>next</code> コマンドは次の行にステップオーバーします。
他にもいくつかのコマンドを利用することができます。
その他については <code>help</code> をタイプしてください。

</p>
<h2>Watchers<span><a class="mark" href="#all_watchers" id="all_watchers">#</a></span></h2>
<!--
You can watch expression and variable values while debugging your code.
On every breakpoint each expression from the watchers list will be evaluated
in the current context and displayed just before the breakpoint's source code
listing.
-->

<p>デバッグ中に式や変数の値をウォッチすることができます。
全てのブレークポイントにおいて、ウォッチリストのそれぞれの式は
現在のコンテキストで評価され、ブレークポイントのソースコードの前に
表示されます。

</p>
<!--
To start watching an expression, type `watch("my_expression")`. `watchers`
prints the active watchers. To remove a watcher, type
`unwatch("my_expression")`.
-->

<p>式のウォッチを開始するには、<code>watch(&quot;my_expression&quot;)</code> をタイプします。
<code>watchers</code> はアクティブなウォッチの一覧を表示します。
ウォッチを解除するには、<code>unwatch(&quot;my_expression&quot;)</code> とタイプします。

</p>
<h2>Commands reference<span><a class="mark" href="#all_commands_reference" id="all_commands_reference">#</a></span></h2>
<h3>Stepping<span><a class="mark" href="#all_stepping" id="all_stepping">#</a></span></h3>
<!--
* `cont`, `c` - Continue execution
* `next`, `n` - Step next
* `step`, `s` - Step in
* `out`, `o` - Step out
-->

<ul>
<li><code>cont</code>, <code>c</code> - 実行を継続します。</li>
<li><code>next</code>, <code>n</code> - 次の行へステップオーバーします。</li>
<li><code>step</code>, <code>s</code> - ステップインします。</li>
<li><code>out</code>, <code>o</code> - ステップアウトします。</li>
</ul>
<h3>Breakpoints<span><a class="mark" href="#all_breakpoints" id="all_breakpoints">#</a></span></h3>
<!--
* `setBreakpoint()`, `sb()` - Set breakpoint on current line
* `setBreakpoint('fn()')`, `sb(...)` - Set breakpoint on a first statement in
functions body
* `setBreakpoint('script.js', 1)`, `sb(...)` - Set breakpoint on first line of
script.js
* `clearBreakpoint`, `cb(...)` - Clear breakpoint
-->

<ul>
<li><code>setBreakpoint()</code>, <code>sb()</code> - 現在行にブレークポイントを設定します。</li>
<li><code>setBreakpoint(&apos;fn()&apos;)</code>, <code>sb(...)</code> - 指定した関数の先頭行にブレークポイントを設定します</li>
<li><code>setBreakpoint(&apos;script.js&apos;, 1)</code>, <code>sb(...)</code> - 指定したスクリプトファイルの指定した行にブレークポイントを設定します。</li>
<li><code>clearBreakpoint</code>, <code>cb(...)</code> - ブレークポイントを削除します。</li>
</ul>
<h3>Info<span><a class="mark" href="#all_info" id="all_info">#</a></span></h3>
<!--
* `backtrace`, `bt` - Print backtrace of current execution frame
* `list(5)` - List scripts source code with 5 line context (5 lines before and
after)
* `watch(expr)` - Add expression to watch list
* `unwatch(expr)` - Remove expression from watch list
* `watchers` - List all watchers and their values (automatically listed on each
breakpoint)
* `repl` - Open debugger's repl for evaluation in debugging script's context
-->

<ul>
<li><code>backtrace</code>, <code>bt</code> - 現在の実行フレームのバックトレースを表示します。</li>
<li><code>list(5)</code> - 現在の行の前後のソースコードを表示します (例では前後とも 5 行が表示されます)。</li>
<li><code>watch(expr)</code> - 式をウォッチリストに追加します。</li>
<li><code>unwatch(expr)</code> - 式をウォッチリストから削除します。</li>
<li><code>watchers</code> - ウォッチしている全ての式とその値を表示します (各ブレークポイントで自動的に表示されます)。</li>
<li><code>repl</code> - デバッグしているスクリプトをコンテキストとする REPL を開きます。</li>
</ul>
<h3>Execution control<span><a class="mark" href="#all_execution_control" id="all_execution_control">#</a></span></h3>
<!--
* `run` - Run script (automatically runs on debugger's start)
* `restart` - Restart script
* `kill` - Kill script
-->

<ul>
<li><code>run</code> - スクリプトを実行します (デバッガを開始すると自動的に実行します)。</li>
<li><code>restart</code> - スクリプトを再実行します。</li>
<li><code>kill</code> - スクリプトを終了します。</li>
</ul>
<h3>Various<span><a class="mark" href="#all_various" id="all_various">#</a></span></h3>
<!--
* `scripts` - List all loaded scripts
* `version` - Display v8's version
-->

<ul>
<li><code>scripts</code> - ロードされている全スクリプトの一覧を表示します。</li>
<li><code>version</code> - v8 のバージョンを表示します。</li>
</ul>
<h2>Advanced Usage<span><a class="mark" href="#all_advanced_usage" id="all_advanced_usage">#</a></span></h2>
<!--
The V8 debugger can be enabled and accessed either by starting Node with
the `--debug` command-line flag or by signaling an existing Node process
with `SIGUSR1`.
-->

<p>V8 デバッガは Node をコマンドラインの <code>--debug</code> フラグで起動したり、起動済みの Node プロセスに <code>SIGUSR1</code> シグナルを送ることでも有効にできます。

</p>
<h1>Cluster<span><a class="mark" href="#all_cluster" id="all_cluster">#</a></span></h1>
<pre><code>Stability: 1 Experimental - Drastic changes in future versions</code></pre>
<!--
A single instance of Node runs in a single thread. To take advantage of
multi-core systems the user will sometimes want to launch a cluster of Node
processes to handle the load.
-->

<p>一つの Node インスタンスは一つのスレッドで実行されます。
マルチコアシステムのメリットを生かすために、
ユーザは時々 Node プロセスのクラスを起動して負荷を分散したくなります。

</p>
<!--
The cluster module allows you to easily create a network of processes that
all share server ports.
-->

<p>クラスタモジュールは、サーバポートを共有するプロセスのネットワークを
簡単に構築することを可能にします。

</p>
<pre><code>var cluster = require(&apos;cluster&apos;);
var http = require(&apos;http&apos;);
var numCPUs = require(&apos;os&apos;).cpus().length;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on(&apos;death&apos;, function(worker) {
    console.log(&apos;worker &apos; + worker.pid + &apos; died&apos;);
  });
} else {
  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
  }).listen(8000);
}</code></pre>
<!--
Running node will now share port 8000 between the workers:
-->

<p>Node は 8000 番ポートをワーカ間で共有します。

</p>
<pre><code>% node server.js
Worker 2438 online
Worker 2437 online</code></pre>
<!--
The difference between `cluster.fork()` and `child_process.fork()` is simply
that cluster allows TCP servers to be shared between workers. `cluster.fork`
is implemented on top of `child_process.fork`. The message passing API that
is available with `child_process.fork` is available with `cluster` as well.
As an example, here is a cluster which keeps count of the number of requests
in the master process via message passing:
-->

<p><code>cluster.fork()</code> と <code>child_process.fork()</code> の違いは単純で、
クラスタはワーカ間で共有する TCP サーバを実現できることです。
<code>cluster.fork()</code> は <code>child_process.fork()</code> 上に実装されています。
<code>child_process.fork()</code> によって実現されるメッセージパッシング API は
<code>cluseter</code> でも同様に利用できます。
以下のクラスタの例は、メッセージパッシングを通じてマスタプロセスで
リクエスト数をカウントします。

</p>
<pre><code>var cluster = require(&apos;cluster&apos;);
var http = require(&apos;http&apos;);
var numReqs = 0;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; 2; i++) {
    var worker = cluster.fork();

    worker.on(&apos;message&apos;, function(msg) {
      if (msg.cmd &amp;&amp; msg.cmd == &apos;notifyRequest&apos;) {
        numReqs++;
      }
    });
  }

  setInterval(function() {
    console.log(&quot;numReqs =&quot;, numReqs);
  }, 1000);
} else {
  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
    // Send message to master process
    process.send({ cmd: &apos;notifyRequest&apos; });
  }).listen(8000);
}</code></pre>
<h2>cluster.fork()<span><a class="mark" href="#all_cluster_fork" id="all_cluster_fork">#</a></span></h2>
<!--
Spawn a new worker process. This can only be called from the master process.
-->

<p>新しいワーカプロセスを起動します。
マスタプロセスから飲み呼び出すことができます。

</p>
<h2>cluster.isMaster<span><a class="mark" href="#all_cluster_ismaster" id="all_cluster_ismaster">#</a></span></h2>
<h2>cluster.isWorker<span><a class="mark" href="#all_cluster_isworker" id="all_cluster_isworker">#</a></span></h2>
<!--
Boolean flags to determine if the current process is a master or a worker
process in a cluster. A process `isMaster` if `process.env.NODE_WORKER_ID`
is undefined.
-->

<p>現在のプロセスがクラスタ内でマスタかワーカかを決定することができる
Boolean 値です。
<code>isMaster</code> は <code>process.env.NODE_WORKER_ID</code> が未定義かどうかです。


</p>
<h2>Event: &apos;death&apos;<span><a class="mark" href="#all_event_death" id="all_event_death">#</a></span></h2>
<!--
When any of the workers die the cluster module will emit the 'death' event.
This can be used to restart the worker by calling `fork()` again.
-->

<p>ワーカが死ぬとクラスタモジュールは <code>&apos;deth&apos;</code> イベントを生成します。
これはワーカを再起動するために再び <code>fork()</code>
を呼び出すことに使うことができます。

</p>
<pre><code>cluster.on(&apos;death&apos;, function(worker) {
  console.log(&apos;worker &apos; + worker.pid + &apos; died. restart...&apos;);
  cluster.fork();
});</code></pre>
<!--
Different techniques can be used to restart the worker depending on the
application.
-->

<p>アプリケーションによっては、ワーカを再起動するために
別のテクニックを使うこともできます。

</p>
<h1>Appendix 1 - Third Party Modules<span><a class="mark" href="#all_appendix_1_third_party_modules" id="all_appendix_1_third_party_modules">#</a></span></h1>
<!--
There are many third party modules for Node. At the time of writing, August
2010, the master repository of modules is
[the wiki page](https://github.com/joyent/node/wiki/modules).
-->

<p>Node 向けにサードパーティ製のモジュールが数多くあります。
執筆時点 (2010 年 8 月) では、モジュールのマスタリポジトリは
<a href="http://github.com/ry/node/wiki/modules">wiki ページ</a> です。

</p>
<!--
This appendix is intended as a SMALL guide to new-comers to help them
quickly find what are considered to be quality modules. It is not intended
to be a complete list.  There may be better more complete modules found
elsewhere.
-->

<p>この付録は、良質だと考えられているモジュールを初心者が素早く見つけることを手助けする「小さな」ガイドを意図しています。
これは完全なリストは意図していません。
どこかでより完全なモジュールが見つかるかもしれません。

</p>
<ul>
<li><p>Module Installer: <a href="https://github.com/isaacs/npm">npm</a></p>
</li>
<li><p>HTTP Middleware: <a href="https://github.com/senchalabs/connect">Connect</a></p>
</li>
<li><p>Web Framework: <a href="https://github.com/visionmedia/express">Express</a></p>
</li>
<li><p>Web Sockets: <a href="https://github.com/learnboost/socket.io">Socket.IO</a></p>
</li>
<li><p>HTML Parsing: <a href="https://github.com/aredridel/html5">HTML5</a></p>
</li>
<li><p><a href="https://github.com/agnat/node_mdns">mDNS/Zeroconf/Bonjour</a></p>
</li>
<li><p><a href="https://github.com/postwait/node-amqp">RabbitMQ, AMQP</a></p>
</li>
<li><p><a href="https://github.com/felixge/node-mysql">mysql</a></p>
</li>
<li><p>Serialization: <a href="https://github.com/pgriess/node-msgpack">msgpack</a></p>
</li>
<li><p>Scraping: <a href="https://github.com/silentrob/Apricot">Apricot</a></p>
</li>
<li><p>Debugger: <a href="https://github.com/smtlaissezfaire/ndb">ndb</a> is a CLI debugger
<a href="https://github.com/dannycoates/node-inspector">inspector</a> is a web based
tool.</p>
</li>
<li><p><a href="https://github.com/mranney/node_pcap">pcap binding</a></p>
</li>
<li><p><a href="https://github.com/mscdex/node-ncurses">ncurses</a></p>
</li>
<li><p>Testing/TDD/BDD: <a href="http://vowsjs.org/">vows</a>,
<a href="https://github.com/visionmedia/mocha">mocha</a>,
<a href="https://github.com/tmpvar/mjsunit.runner">mjsunit.runner</a></p>
</li>
</ul>
<!--
Patches to this list are welcome.
-->

<p>このリストへのパッチを歓迎します。

</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <ul class="clearfix">
            <!--
            <li><a href="/">Node.js</a></li>
            <li><a href="/#download">Download</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="http://search.npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/logos/">Logos</a></li>
            -->
            <li><a href="../">Node.js</a></li>
            <li><a href="../#download">ダウンロード</a></li>
            <li><a href="../about/">概要</a></li>
            <li><a href="http://search.npmjs.org/">npm レジストリ</a></li>
            <li><a href="../api/index.html">ドキュメント</a></li>
            <li><a href="http://blog.nodejs.org">ブログ</a></li>
            <li><a href="../community/">コミュニティ</a></li>
            <li><a href="../logos/">ロゴ</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.6.16/LICENSE">license</a>.</p>
    </div>

  <script src="../sh_main.js"></script>
  <script src="../sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <script>
    var gaJsHost = (("https:" == document.location.protocol) ?
    "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script>
    try {
      var pageTracker = _gat._getTracker("UA-10874194-2");
      pageTracker._trackPageview();
      } catch(err) {}</script>
</body>
</html>

