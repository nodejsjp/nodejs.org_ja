<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>dgram - Node.js v0.6.4 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css" />
  <link rel="stylesheet" href="assets/sh.css" />
  <link rel="canonical" href="http://nodejs.org/docs/latest/api/dgram.html"/>
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js v0.6.4 Manual &amp; Documentation</h1>
      <div id="gtoc">
        <p><a href="index.html">Index</a> | <a href="all.html">View on single page</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Table Of Contents</h2><ul><li><a href="#uDP_Datagram_Sockets">UDP / Datagram Sockets</a><ul><li><a href="#event_message_">Event: 'message'</a></li><li><a href="#event_listening_">Event: 'listening'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#event_error_">Event: 'error'</a></li><li><a href="#dgram.createSocket">dgram.createSocket(type, [callback])</a></li><li><a href="#dgram.send">dgram.send(buf, offset, length, port, address, [callback])</a></li><li><a href="#dgram.bind">dgram.bind(port, [address])</a></li><li><a href="#dgram.close">dgram.close()</a></li><li><a href="#dgram.address">dgram.address()</a></li><li><a href="#dgram.setBroadcast">dgram.setBroadcast(flag)</a></li><li><a href="#dgram.setTTL">dgram.setTTL(ttl)</a></li><li><a href="#dgram.setMulticastTTL">dgram.setMulticastTTL(ttl)</a></li><li><a href="#dgram.setMulticastLoopback">dgram.setMulticastLoopback(flag)</a></li><li><a href="#dgram.addMembership">dgram.addMembership(multicastAddress, [multicastInterface])</a></li><li><a href="#dgram.dropMembership">dgram.dropMembership(multicastAddress, [multicastInterface])</a></li></ul></li></ul><hr /></div>
<h2 id="uDP_Datagram_Sockets">UDP / Datagram Sockets</h2>

<p>データグラムソケットは <code>require('dgram')</code> で利用可能になります。</p>

<h3 id="event_message_">Event: 'message' <a href="#event_message_">#</a></h3>

<p><code>function (msg, rinfo) { }</code></p>

<p>ソケット上で新しいデータグラムが到着した時に生成されます。<code>msg</code> は <code>Buffer</code> で、
<code>rinfo</code> は送信者のアドレス情報とデータグラムのバイト数を持ったオブジェクトです。</p>

<h3 id="event_listening_">Event: 'listening' <a href="#event_listening_">#</a></h3>

<p><code>function () { }</code></p>

<p>ソケットでデータグラムの待ち受けを開始すると生成されます。
これは UDP ソケットが作成されるとすぐに発生します。</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () { }</code></p>

<p><code>close()</code> によってソケットがクローズすると生成されます。
このソケットでは新しい <code>message</code> イベントは生成されなくなります。</p>

<h3 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h3>

<p><code>function (exception) {}</code></p>

<p>エラーが発生すると生成されます。</p>

<hr />

<h3 id="dgram.createSocket">dgram.createSocket(type, [callback]) <a href="#dgram.createSocket">#</a></h3>

<p>指定された種類のデータグラムソケットを作成します。
妥当な種類は <code>udp4</code> と <code>udp6</code>です。</p>

<p>オプションのコールバックは <code>message</code> イベントのリスナーとして加えられます。</p>

<p>データグラムを受信したい場合は <code>socket.bind()</code> を呼び出します。
<code>socket.bind()</code> は「全てのインタフェース」のアドレスにランダムなポート
(<code>udp4</code> と <code>udp6</code> ソケットの両方で正しいものです) をバインドします。
そのアドレスとポートは <code>socket.address().address</code> および
<code>socket.address().port</code> で取得することができます。</p>

<h3 id="dgram.send">dgram.send(buf, offset, length, port, address, [callback]) <a href="#dgram.send">#</a></h3>

<p>UDP ソケット用です。相手先のポートと IP アドレスは必ず指定しなければなりません。
<code>address</code> パラメータに文字列を提供すると、それは DNS によって解決されます。
DNS エラーと <code>buf</code> が再利用可能になった時のためにオプションのコールバックを指定することができます。
DNS ルックアップは送信を少なくとも次の機会まで遅らせることに注意してください。
送信が行われたことを確実に知る唯一の手段はコールバックを使うことです。</p>

<p>ソケットが以前に <code>bind</code> の呼び出しによってバインドされていない場合は、
ランダムなポート番号が「全てのインタフェース」アドレスに対してバインドされます
(<code>udp4</code> ソケットでは 0.0.0.0、<code>udp6</code> では ::0)。</p>

<p><code>localhost</code> の適当なポートに UDP パケットを送信する例;</p>

<pre><code>var dgram = require('dgram');
var message = new Buffer("Some bytes");
var client = dgram.createSocket("udp4");
client.send(message, 0, message.length, 41234, "localhost", function(err, bytes) {
  client.close();
});</code></pre>

<p><strong>UDP データグラムのサイズについて</strong></p>

<p><code>IPv4/v6</code> データグラムの最大のサイズは <code>MTU</code> (<em>Maximum Transmission Unit</em>) と、
<code>Payload Length</code> フィールドサイズに依存します。</p>

<ul><li><p><code>Payload Length</code> フィールドサイズは 16bit 長で、これは通常のペイロードが
IP ヘッダとデータ含めて 64K オクテットより長くなれないことを意味します
(65,507 バイト = 65,535 − 8 バイトの UDP ヘッダ − 20 バイトの IP ヘッダ);
これは一般的にループバックインタフェースでは正しいものの、
ほとんどのホストとネットワークにとって長大なデータグラムは
現実的ではありません。</p></li><li><p><code>MTU</code> はリンク層により大きなサイズを与える技術で、
データグラムもサポートできます。
どんなリンクでも、それらが全体として到着するか断片化されるかに関わらず、
<code>IPv4</code> は最低 <code>69</code> オクテット必要で、推奨される <code>IPv4</code> の <code>MTU</code> は <code>576</code> です
(典型的なダイヤルアップ型アプリケーションの <code>MUT</code> 推奨値)。</p><p><code>IPv6</code> では最小の <code>MTU</code> は <code>1280</code> オクテットですが、フラグメントを再構築する
バッファサイズは最低 <code>1500</code> オクテットが必要です。
<code>68</code> オクテットはとても小さいので、もっとも現代的なリンク層技術では、
最小の <code>MTU</code> は <code>1500</code> です (イーサネットと同じです)。</p></li></ul>

<p>パケットが通過する各リンクの MTU をあらかじめ知ることは
できないこと、(受信側の) <code>MTU</code> より大きなデータグラムを送信しても
通常は動作しないことに注意してください
(パケットは送り主に知らされることなく黙って捨てられ、
意図した受信者に到達することはありません)。</p>

<h3 id="dgram.bind">dgram.bind(port, [address]) <a href="#dgram.bind">#</a></h3>

<p>UDP ソケット用です。<code>port</code> とオプションの <code>address</code> でデータグラムを待ち受けます。
<code>address</code> が指定されなければ、OS は全てのアドレスからの待ち受けを試みます。</p>

<p>41234 番ポートを待ち受ける UDP サーバの例:</p>

<pre><code>var dgram = require("dgram");

var server = dgram.createSocket("udp4");

server.on("message", function (msg, rinfo) {
  console.log("server got: " + msg + " from " +
    rinfo.address + ":" + rinfo.port);
});

server.on("listening", function () {
  var address = server.address();
  console.log("server listening " +
      address.address + ":" + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>

<h3 id="dgram.close">dgram.close() <a href="#dgram.close">#</a></h3>

<p>下層のソケットをクローズし、データの待ち受けを終了します。</p>

<h3 id="dgram.address">dgram.address() <a href="#dgram.address">#</a></h3>

<p>オブジェクトが持っているソケットのアドレス情報を返します。
このオブジェクトは <code>address</code> と <code>port</code> を持っています。</p>

<h3 id="dgram.setBroadcast">dgram.setBroadcast(flag) <a href="#dgram.setBroadcast">#</a></h3>

<p>ソケットのオプション <code>SO_BROADCAST</code> を設定またはクリアします。
このオプションが設定されると、UDP パケットはローカルインタフェースのブロードキャスト用アドレスに送信されます。</p>

<h3 id="dgram.setTTL">dgram.setTTL(ttl) <a href="#dgram.setTTL">#</a></h3>

<p>ソケットオプションの <code>IP_TTL</code> を設定します。
TTL は「生存期間」を表しますが、このコンテキストではパケットが通過を許可される IP のホップ数を指定します。
各ルータまたはゲートウェイはパケットを送出する際 TTL をデクリメントします。
ルータによって TTL がデクリメントされて 0 になるとそれは送出されません。
TTL 値の変更は通常、ネットワークの調査やマルチキャストで使われます。</p>

<p><code>setTTL()</code> の引数は 1 から 255 のホップ数でです。ほとんどのシステムでデフォルトは 64 です。</p>

<h3 id="dgram.setMulticastTTL">dgram.setMulticastTTL(ttl) <a href="#dgram.setMulticastTTL">#</a></h3>

<p><code>IP_MULTICAST_TTL</code> ソケットオプションを設定します。
TTL は「生存期間」を表しますが、この文脈では特にマルチキャストのトラフィックにおいてパケットが通過できるIPホップの数を指定します。
それぞれのルーターまたはゲートウェイは、パケットを転送する際に TTL をデクリメントします。
TTL がルーターによって 0 までデクリメントされると、それは転送されません。
<code>setMulticastTTL()</code> の引数はホップを表す数値で、0 から 255 の間です。
ほとんどのシステムでデフォルトは 64 です。</p>

<h3 id="dgram.setMulticastLoopback">dgram.setMulticastLoopback(flag) <a href="#dgram.setMulticastLoopback">#</a></h3>

<p><code>IP_MULTICAST_LOOP</code> ソケットオプションを設定またはクリアします。
このオプションが設定されると、マルチキャストのパケットはローカルインタフェースでも受信できるようになります。</p>

<h3 id="dgram.addMembership">dgram.addMembership(multicastAddress, [multicastInterface]) <a href="#dgram.addMembership">#</a></h3>

<p><code>IP_ADD_MEMBERSHIP</code> ソケットオプションを設定し、マルチキャストグループに参加することをカーネルに伝えます。</p>

<p><code>multicastInterface</code> が指定されなかった場合は、全ての妥当なインタフェースをメンバーシップに加えようとします。</p>

<h3 id="dgram.dropMembership">dgram.dropMembership(multicastAddress, [multicastInterface]) <a href="#dgram.dropMembership">#</a></h3>

<p><code>addMembership</code> の反対です - <code>IP_DROP_MEMBERSHIP</code> ソケットオプションによって、マルチキャストグループから抜けることをカーネルに伝えます。
これはソケットのクローズ時やプロセスの終了時にカーネルによって自動的に呼び出されるため、ほとんどのアプリケーションはこれを呼び出す必要がありません。</p>

<p><code>multicastInterface</code> が指定されなかった場合は、全ての妥当なインタフェースをメンバーシップから削除しようとします。</p>
  </div>
  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>
