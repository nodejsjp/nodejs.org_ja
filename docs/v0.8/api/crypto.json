{
  "source": "doc/api/crypto.markdown",
  "modules": [
    {
      "textRaw": "Crypto",
      "name": "crypto",
      "desc": "<!--\n    Stability: 2 - Unstable; API changes are being discussed for\n    future versions.  Breaking changes will be minimized.  See below.\n-->\n\n<pre><code>Stability: 2 - Unstable; 将来のバージョンで API を変更することがが\n議論されています。互換性を損なう変更は最小限です。後述します。</code></pre>\n<!--\nUse `require('crypto')` to access this module.\n-->\n\n<p>このモジュールにアクセスするには <code>require(&#39;crypto&#39;)</code> を使用します。\n\n</p>\n<!--\nThe crypto module requires OpenSSL to be available on the underlying platform.\nIt offers a way of encapsulating secure credentials to be used as part\nof a secure HTTPS net or http connection.\n-->\n\n<p>暗号化モジュールは下層のプラットフォームで OpenSSL が有効であることを\n必要とします。\nそれは安全な HTTPS ネットワークや http コネクションの一部として使われる、\n安全な認証情報をカプセル化する方法を提供します。\n\n</p>\n<!--\nIt also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.\n-->\n\n<p>同時に OpenSSL のハッシュ、HMAC、暗号、復号、署名、そして検証へのラッパーを一式提供します。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "crypto.createCredentials(details)",
          "type": "method",
          "name": "createCredentials",
          "desc": "<!--\nCreates a credentials object, with the optional details being a dictionary with keys:\n-->\n\n<p>認証情報オブジェクトを作成します。オプションの <code>details</code> は以下のキーを持つ辞書です:\n\n</p>\n<!--\n* `pfx` : A string or buffer holding the PFX or PKCS12 encoded private key, certificate and CA certificates\n* `key` : A string holding the PEM encoded private key\n* `passphrase` : A string of passphrase for the private key or pfx\n* `cert` : A string holding the PEM encoded certificate\n* `ca` : Either a string or list of strings of PEM encoded CA certificates to trust.\n* `crl` : Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List)\n* `ciphers`: A string describing the ciphers to use or exclude. Consult\n  <http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT> for details\n  on the format.\n-->\n\n<ul>\n<li><code>pfx</code> : PFX または PKCS12 でエンコードされた秘密鍵、証明書、および CA の\n証明書を含む文字列またはバッファ。</li>\n<li><code>key</code> : PEM でエンコードされた秘密鍵を保持する文字列。</li>\n<li><code>passphrase</code>: 秘密鍵または pfx のパスフレーズ。</li>\n<li><code>cert</code> : PEM でエンコードされた証明書を保持する文字列。</li>\n<li><code>ca</code> : 信頼できる認証局の証明書が PEM でエンコードされた文字列または\n文字列の配列。</li>\n<li><code>crl</code> : PEM でエンコードされた CRL (Certificate Revocation List、\n失効した証明書の一覧) の文字列または文字列の配列。</li>\n<li><code>ciphers</code>: 使用または除外する暗号を記述した文字列。\n詳細は <a href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>\nを参照してください。</li>\n</ul>\n<!--\nIf no 'ca' details are given, then node.js will use the default publicly trusted list of CAs as given in\n<http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt>.\n-->\n\n<p>&#39;ca&#39; の詳細が与えられなかった場合、node.js はデフォルトとして\n</p>\n<p><a href=\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>\nで与えられる、信頼できる認証局の公開されたリストを使用します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "details"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHash(algorithm)",
          "type": "method",
          "name": "createHash",
          "desc": "<!--\nCreates and returns a hash object, a cryptographic hash with the given algorithm\nwhich can be used to generate hash digests.\n-->\n\n<p>ハッシュオブジェクトを生成して返します。\n与えられたアルゴリズムによる暗号ハッシュ関数はダイジェストの生成に使われます。\n\n</p>\n<!--\n`algorithm` is dependent on the available algorithms supported by the version\nof OpenSSL on the platform. Examples are `'sha1'`, `'md5'`, `'sha256'`, `'sha512'`, etc.\nOn recent releases, `openssl list-message-digest-algorithms` will display the available digest algorithms.\n-->\n\n<p><code>algorithm</code> は、プラットフォーム上の OpenSSL \nのバージョンでサポートされている利用可能なアルゴリズムに依存します。\n例えば <code>&#39;sha1&#39;</code>、<code>&#39;md5&#39;</code>、<code>&#39;sha256&#39;</code>、<code>&#39;sha512&#39;</code>、などです。\n最近のリリースでは、<code>openssl list-message-digest-algorithms</code>\nで利用可能なダイジェストアルゴリズムが表示されます。\n\n</p>\n<!--\nExample: this program that takes the sha1 sum of a file\n-->\n\n<p>例: このプログラムはファイルのsha1ハッシュ値を求めます。\n\n</p>\n<pre><code>var filename = process.argv[2];\nvar crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar shasum = crypto.createHash(&#39;sha1&#39;);\n\nvar s = fs.ReadStream(filename);\ns.on(&#39;data&#39;, function(d) {\n  shasum.update(d);\n});\n\ns.on(&#39;end&#39;, function() {\n  var d = shasum.digest(&#39;hex&#39;);\n  console.log(d + &#39;  &#39; + filename);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHmac(algorithm, key)",
          "type": "method",
          "name": "createHmac",
          "desc": "<!--\nCreates and returns a hmac object, a cryptographic hmac with the given algorithm and key.\n-->\n\n<p>与えられたアルゴリズムとキーで HMAC を計算する、HMAC オブジェクトを作成して返します。\n\n</p>\n<!--\n`algorithm` is dependent on the available algorithms supported by OpenSSL - see createHash above.\n`key` is the hmac key to be used.\n-->\n\n<p><code>algorithm</code> は OpenSSL でサポートされているアルゴリズムに依存します － \n前述の <code>createHash</code> を参照してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipher(algorithm, password)",
          "type": "method",
          "name": "createCipher",
          "desc": "<!--\nCreates and returns a cipher object, with the given algorithm and password.\n\n`algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc.\nOn recent releases, `openssl list-cipher-algorithms` will display the\navailable cipher algorithms.\n`password` is used to derive key and IV, which must be a `'binary'` encoded\nstring or a [buffer](buffer.html).\n-->\n\n<p>与えられたアルゴリズムとパスワードを使用する暗号オブジェクトを作成して返します。\n<code>algorithm</code> は、OpenSSL に依存します。例えば <code>&#39;aes192&#39;</code> などです。\n最近のリリースでは、<code>openssl list-cipher-algorithms</code>\nで利用可能な暗号アルゴリズムが表示されます。\n<code>password</code> はキーと IV の生成に使用されます。\nこれは <code>&#39;binary&#39;</code> でエンコードされた文字列または <a href=\"buffer.html\">buffer</a>\nでなければなりません\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createCipheriv",
          "desc": "<!--\nCreates and returns a cipher object, with the given algorithm, key and iv.\n\n`algorithm` is the same as the argument to `createCipher()`.\n`key` is the raw key used by the algorithm.\n`iv` is an [initialization\nvector](http://en.wikipedia.org/wiki/Initialization_vector).\n\n`key` and `iv` must be `'binary'` encoded strings or [buffers](buffer.html).\n-->\n\n<p>与えられたアルゴリズムとキーおよび IV を使用する暗号オブジェクトを作成して\n返します。\n\n</p>\n<p><code>algorithm</code> は <code>createCipher()</code> の引数と同じです。\n<code>key</code> はアルゴリズムで使用される生のキーです。\n<code>iv</code> は<a href=\"http://en.wikipedia.org/wiki/Initialization_vector\">initialization\nvector</a> です。\n\n</p>\n<p><code>key</code> と <code>iv</code> は <code>&#39;binary&#39;</code> でエンコードされた文字列または\n<a href=\"buffer.html\">buffers</a> でなければなりません\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipher(algorithm, password)",
          "type": "method",
          "name": "createDecipher",
          "desc": "<!--\nCreates and returns a decipher object, with the given algorithm and key.\nThis is the mirror of the [createCipher()][] above.\n-->\n\n<p>与えられたアルゴリズムとパスワードを使用する復号オブジェクトを作成して返します。\nこれは前述の [createCipher()][] の鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createDecipheriv",
          "desc": "<!--\nCreates and returns a decipher object, with the given algorithm, key and iv.\nThis is the mirror of the [createCipheriv()][] above.\n-->\n\n<p>与えられたアルゴリズムとキー、IV を使用する復号オブジェクトを作成して返します。\nこれは前述の [createCipheriv()][] の鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createSign(algorithm)",
          "type": "method",
          "name": "createSign",
          "desc": "<!--\nCreates and returns a signing object, with the given algorithm.\nOn recent OpenSSL releases, `openssl list-public-key-algorithms` will display\nthe available signing algorithms. Examples are `'RSA-SHA256'`.\n-->\n\n<p>与えられたアルゴリズムで署名オブジェクトを作成して返します。\n最近のOpenSSLのリリースでは、<code>openssl list-public-key-algorithms</code>\nで利用可能な署名アルゴリズムの一覧が表示されます。例えば &#39;RSA-SHA256&#39;。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createVerify(algorithm)",
          "type": "method",
          "name": "createVerify",
          "desc": "<!--\nCreates and returns a verification object, with the given algorithm.\nThis is the mirror of the signing object above.\n-->\n\n<p>与えられたアルゴリズムで検証オブジェクトを作成して返します。これは前述の署名オブジェクトと鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime_length)",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<!--\nCreates a Diffie-Hellman key exchange object and generates a prime of the\ngiven bit length. The generator used is `2`.\n-->\n\n<p>ディフィー・ヘルマン鍵共有オブジェクトを作成し、\n与えられた長さの素数を生成します。生成元は <code>2</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime_length"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime, [encoding])",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<!--\nCreates a Diffie-Hellman key exchange object using the supplied prime. The\ngenerator used is `2`. Encoding can be `'binary'`, `'hex'`, or `'base64'`.\nDefaults to `'binary'`.\n-->\n\n<p>与えられた素数からディフィー・ヘルマン鍵共有オブジェクトを作成します。\n生成元は <code>2</code> です。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.getDiffieHellman(group_name)",
          "type": "method",
          "name": "getDiffieHellman",
          "desc": "<!--\nCreates a predefined Diffie-Hellman key exchange object.\nThe supported groups are: `'modp1'`, `'modp2'`, `'modp5'`\n(defined in [RFC 2412][])\nand `'modp14'`, `'modp15'`, `'modp16'`, `'modp17'`, `'modp18'`\n(defined in [RFC 3526][]).\nThe returned object mimics the interface of objects created by\n[crypto.createDiffieHellman()][] above, but\nwill not allow to change the keys (with\n[diffieHellman.setPublicKey()][] for example).\nThe advantage of using this routine is that the parties don't have to\ngenerate nor exchange group modulus beforehand, saving both processor and\ncommunication time.\n-->\n\n<p>事前に定義された Diffie-Hellman 鍵交換オブジェクトを作成します。\nサポートされるグループは、<code>&#39;modp1&#39;</code>, <code>&#39;modp2&#39;</code>, <code>&#39;modp5&#39;</code>\n([RFC 2412][] で定義される)、\nおよび <code>&#39;modp14&#39;</code>, <code>&#39;modp15&#39;</code>, <code>&#39;modp16&#39;</code>, <code>&#39;modp17&#39;</code>, <code>&#39;modp18&#39;</code>\n([RFC 3526][] で定義される) です。\n返されるオブジェクトは、前述の\n[crypto.createDiffieHellman()][]\nによって作成されたオブジェクトのインタフェースを模倣します。\nしかし、\n(たとえば [diffieHellman.setPublicKey()][] で)\n鍵を交換することはできません。\nこのルーチンを使うことによるアドバンテージは、\n事前にグループ係数を生成することも交換する必要もないため、\n処理と通信の時間を共に節約できることです。\n\n</p>\n<!--\nExample (obtaining a shared secret):\n-->\n\n<p>例 (共有鍵を取得):\n\n</p>\n<pre><code>var crypto = require(&#39;crypto&#39;);\nvar alice = crypto.getDiffieHellman(&#39;modp5&#39;);\nvar bob = crypto.getDiffieHellman(&#39;modp5&#39;);\n\nalice.generateKeys();\nbob.generateKeys();\n\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), &#39;binary&#39;, &#39;hex&#39;);\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), &#39;binary&#39;, &#39;hex&#39;);\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "group_name"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2(password, salt, iterations, keylen, callback)",
          "type": "method",
          "name": "pbkdf2",
          "desc": "<!--\nAsynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive\na key of given length from the given password, salt and iterations.\nThe callback gets two arguments `(err, derivedKey)`.\n-->\n\n<p>疑似乱数を HMAC-SHA1 関数に適用して、与えられたパスワードと salt \n(ランダムなバイト値)、および繰り返しから、指定された長さの鍵を生成する、\n非同期の PBKDF2 です。\nコールバック関数は二つの引数を受け取る <code>(err, derivedKey)</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.randomBytes(size, [callback])",
          "type": "method",
          "name": "randomBytes",
          "desc": "<!--\nGenerates cryptographically strong pseudo-random data. Usage:\n-->\n\n<p>暗号学的に強い疑似乱数データを生成します。使用法:\n\n</p>\n<pre><code>// async\ncrypto.randomBytes(256, function(ex, buf) {\n  if (ex) throw ex;\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\n});\n\n// sync\ntry {\n  var buf = crypto.randomBytes(256);\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\n} catch (ex) {\n  // handle error\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Hash",
          "type": "class",
          "name": "Hash",
          "desc": "<!--\nThe class for creating hash digests of data.\n\nReturned by `crypto.createHash`.\n-->\n\n<p>データのハッシュダイジェストを作成するためのクラスです。\n\n</p>\n<p><code>crypto.createHash()</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hash.update(data, [input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the hash content with the given `data`, the encoding of which is given\nin `input_encoding` and can be `'utf8'`, `'ascii'` or `'binary'`.\nDefaults to `'binary'`.\nThis can be called many times with new data as it is streamed.\n-->\n\n<p>与えられた <code>data</code> でハッシュの内容を更新します。\nそのエンコーディングは <code>input_encoding</code> で与えられ、<code>&#39;utf8&#39;</code>、<code>&#39;ascii&#39;</code>、\nまたは <code>&#39;binary&#39;</code> を指定することができます。\nデフォルトは <code>&#39;binary&#39;</code> です。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hash.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<!--\nCalculates the digest of all of the passed data to be hashed.\nThe `encoding` can be `'hex'`, `'binary'` or `'base64'`.\nDefaults to `'binary'`.\n\nNote: `hash` object can not be used after `digest()` method been called.\n-->\n\n<p>渡された全てのデータがハッシュ化されたダイジェストを計算します。\n<code>encoding</code> は <code>&#39;hex&#39;</code>、<code>&#39;binary&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<p>注意: <code>digest()</code> メソッドを呼び出した後で <code>hash</code> \nオブジェクトを使うことはできません。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hmac",
          "type": "class",
          "name": "Hmac",
          "desc": "<!--\nClass for creating cryptographic hmac content.\n\nReturned by `crypto.createHmac`.\n-->\n\n<p>hmac を作成するためのクラスです。\n\n</p>\n<p><code>crypto.createHamc</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hmac.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdate the hmac content with the given `data`.\nThis can be called many times with new data as it is streamed.\n-->\n\n<p>与えられた <code>data</code> で HMAC の内容を更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hmac.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<!--\nCalculates the digest of all of the passed data to the hmac.\nThe `encoding` can be `'hex'`, `'binary'` or `'base64'`.\nDefaults to `'binary'`.\n\nNote: `hmac` object can not be used after `digest()` method been called.\n-->\n\n<p>渡された全てのデータが HMAC 化されたダイジェストを計算します。\n<code>encoding</code> は <code>&#39;hex&#39;</code>、<code>&#39;binary&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<p>注意: <code>digest()</code> メソッドを呼び出した後で <code>hmac</code> \nオブジェクトを使うことはできません。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Cipher",
          "type": "class",
          "name": "Cipher",
          "desc": "<!--\nClass for encrypting data.\n\nReturned by `crypto.createCipher` and `crypto.createCipheriv`.\n-->\n\n<p>データを暗号化するためのクラスです。\n\n</p>\n<p><code>crypto.createCipher</code> および <code>crypto.createCipheriv</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "cipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the cipher with `data`, the encoding of which is given in\n`input_encoding` and can be `'utf8'`, `'ascii'` or `'binary'`.\nDefaults to `'binary'`.\n\nThe `output_encoding` specifies the output format of the enciphered data,\nand can be `'binary'`, `'base64'` or `'hex'`. Defaults to `'binary'`.\n-->\n\n<p><code>data</code> で暗号を更新します。\n<code>input_encoding</code> で与えられるエンコーディングは <code>&#39;utf8&#39;</code>、<code>&#39;ascii&#39;</code>、<code>&#39;binary&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<p><code>output_encoding</code> は暗号化されたデータの出力フォーマットを指定するもので、\n<code>&#39;utf8&#39;</code>、<code>&#39;ascii&#39;</code> または <code>&#39;binary&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<!--\nReturns the enciphered contents, and can be called many times with new data as it is streamed.\n-->\n\n<p>暗号化されたコンテンツが返されます。これは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<!--\nReturns any remaining enciphered contents, with `output_encoding` being one of:\n`'binary'`, `'base64'` or `'hex'`. Defaults to `'binary'`.\n\nNote: `cipher` object can not be used after `final()` method been called.\n-->\n\n<p>暗号化されたコンテンツの残りを返します。\n<code>output_encoding</code> は次のいずれかです: <code>&#39;binary&#39;</code>、<code>&#39;base64&#39;</code> または <code>&#39;hex&#39;</code>。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<p>注意: <code>final()</code> メソッドを呼び出した後で <code>cipher</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<!--\nYou can disable automatic padding of the input data to block size. If `auto_padding` is false,\nthe length of the entire input data must be a multiple of the cipher's block size or `final` will fail.\nUseful for non-standard padding, e.g. using `0x0` instead of PKCS padding. You must call this before `cipher.final`.\n-->\n\n<p>入力データが自動的にブロックサイズにパディングされることを\n抑止することができます。\n<code>auto_padding</code> が <code>false</code> の場合、入力データ全体の長さは\n暗号ブロックサイズの倍数でなければなりません。\nでなければ、<code>final()</code> は失敗します。\nこれは非標準のパディング、たとえば PKCS パディングの代わりに\n<code>0x0</code> を使う場合に便利です。\n<code>cipher.final()</code> の前に呼び出す必要があります。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Decipher",
          "type": "class",
          "name": "Decipher",
          "desc": "<!--\nClass for decrypting data.\n\nReturned by `crypto.createDecipher` and `crypto.createDecipheriv`.\n-->\n\n<p>復号化のためのクラスです。\n\n</p>\n<p><code>crypto.createDecipher</code> および <code>crypto.createDecipheriv</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "decipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the decipher with `data`, which is encoded in `'binary'`, `'base64'`\nor `'hex'`. Defaults to `'binary'`.\n\nThe `output_decoding` specifies in what format to return the deciphered\nplaintext: `'binary'`, `'ascii'` or `'utf8'`. Defaults to `'binary'`.\n-->\n\n<p><code>&#39;binary&#39;</code>、<code>&#39;base64&#39;</code> または <code>&#39;hex&#39;</code> のいずれかでエンコードされた復号を\n<code>data</code> で更新します。デフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<p><code>output_decoding</code> は復号化されたプレーンテキストのフォーマットを指定するもので、\n<code>&#39;binary&#39;</code>、<code>&#39;ascii&#39;</code> あるいは <code>&#39;utf8&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<!--\nReturns any remaining plaintext which is deciphered,\nwith `output_encoding` being one of: `'binary'`, `'ascii'` or `'utf8'`.\nDefaults to `'binary'`.\n\nNote: `decipher` object can not be used after `final()` method been called.\n-->\n\n<p>復号化されたプレーンテキストの残りを返します。\n<code>output_decoding</code> は <code>&#39;binary&#39;</code>、<code>&#39;ascii&#39;</code> あるいは <code>&#39;utf8&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<p>注意: <code>final()</code> メソッドを呼び出した後で <code>decipher</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<!--\nYou can disable auto padding if the data has been encrypted without standard block padding to prevent\n`decipher.final` from checking and removing it. Can only work if the input data's length is a multiple of the\nciphers block size. You must call this before streaming data to `decipher.update`.\n-->\n\n<p>データブロックが非標準のパディングで暗号化されている場合、\n<code>decipher.final()</code> によるチェックを無効にすることができます。\n入力データの長さが暗号ブロックサイズの倍数の場合のみ動作します。\n<code>decipher.update()</code> の前に呼び出す必要があります。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Signer",
          "type": "class",
          "name": "Signer",
          "desc": "<!--\nClass for generating signatures.\n\nReturned by `crypto.createSign`.\n-->\n\n<p>署名を作成するためのクラスです。\n\n</p>\n<p><code>crypto.createSign</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "signer.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the signer object with data.\nThis can be called many times with new data as it is streamed.\n-->\n\n<p>署名オブジェクトをデータで更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "signer.sign(private_key, [output_format])",
              "type": "method",
              "name": "sign",
              "desc": "<!--\nCalculates the signature on all the updated data passed through the signer.\n`private_key` is a string containing the PEM encoded private key for signing.\n-->\n\n<p>署名オブジェクトに渡された全ての更新データで署名を計算します。\n<code>private_key</code> は PEM でエンコードされた秘密鍵を内容とする文字列です。\n\n</p>\n<!--\nReturns the signature in `output_format` which can be `'binary'`, `'hex'` or\n`'base64'`. Defaults to `'binary'`.\n\nNote: `signer` object can not be used after `sign()` method been called.\n-->\n\n<p><code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、あるいは <code>&#39;base64&#39;</code> のいずれかを指定した <code>output_format</code>\nによる署名を返します。デフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<p>注意: <code>sign()</code> メソッドを呼び出した後で <code>signer</code> \nオブジェクトを使うことはできません。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "output_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Verify",
          "type": "class",
          "name": "Verify",
          "desc": "<!--\nClass for verifying signatures.\n\nReturned by `crypto.createVerify`.\n-->\n\n<p>署名を検証するためのクラスです。\n\n</p>\n<p><code>crypto.createVerify</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "verifier.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the verifier object with data.\nThis can be called many times with new data as it is streamed.\n-->\n\n<p>検証オブジェクトをデータで更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "verifier.verify(object, signature, [signature_format])",
              "type": "method",
              "name": "verify",
              "desc": "<!--\nVerifies the signed data by using the `object` and `signature`. `object` is  a\nstring containing a PEM encoded object, which can be one of RSA public key,\nDSA public key, or X.509 certificate. `signature` is the previously calculated\nsignature for the data, in the `signature_format` which can be `'binary'`,\n`'hex'` or `'base64'`. Defaults to `'binary'`.\n-->\n\n<p>署名されたデータを <code>object</code> と <code>signature</code> で検証します。\n<code>object</code> は RSA 公開鍵、DSA 公開鍵、X.509証明書のいずれかを\nPEM でエンコードしたオブジェクトです。\n<code>signature</code> は先に計算したデータの署名で、\nその <code>signature_format</code> は <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code>\nのいずれかです。デフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n<!--\nReturns true or false depending on the validity of the signature for the data and public key.\n\nNote: `verifier` object can not be used after `verify()` method been called.\n-->\n\n<p>署名されたデータと公開鍵による検証の結果によって true または false を返します。\n\n</p>\n<p>注意: <code>verify()</code> メソッドを呼び出した後で <code>verifier</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "signature"
                    },
                    {
                      "name": "signature_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: DiffieHellman",
          "type": "class",
          "name": "DiffieHellman",
          "desc": "<!--\nThe class for creating Diffie-Hellman key exchanges.\n\nReturned by `crypto.createDiffieHellman`.\n-->\n\n<p>ディフィー・ヘルマン鍵共有のためのクラスです。\n\n</p>\n<p><code>crypto.creaateDiffieHellman</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "diffieHellman.generateKeys([encoding])",
              "type": "method",
              "name": "generateKeys",
              "desc": "<!--\nGenerates private and public Diffie-Hellman key values, and returns the\npublic key in the specified encoding. This key should be transferred to the\nother party. Encoding can be `'binary'`, `'hex'`, or `'base64'`.\nDefaults to `'binary'`.\n-->\n\n<p>ディフィー・ヘルマン法で秘密および公開鍵を作成し、\n指定の方法でエンコーディングされた公開鍵を返します。\nこの鍵は相手側に渡されるものです。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "desc": "<!--\nComputes the shared secret using `other_public_key` as the other party's\npublic key and returns the computed shared secret. Supplied key is\ninterpreted using specified `input_encoding`, and secret is encoded using\nspecified `output_encoding`. Encodings can be `'binary'`, `'hex'`, or\n`'base64'`. The input encoding defaults to `'binary'`.\nIf no output encoding is given, the input encoding is used as output encoding.\n-->\n\n<p><code>other_public_key</code> を相手側の公開鍵として共有の秘密鍵を計算して返します。\n与えられた公開鍵は指定の <code>input_encoding</code> を使って解釈され、\n秘密鍵は <code>output_encoding</code> で指定された方法でエンコードされます。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\n入力エンコーディングのデフォルトは <code>&#39;binary&#39;</code> です。\n出力のエンコーディングが与えられなかった場合は、入力のエンコーディングが\n出力エンコーディングとして使われます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrime([encoding])",
              "type": "method",
              "name": "getPrime",
              "desc": "<!--\nReturns the Diffie-Hellman prime in the specified encoding, which can be\n`'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.\n-->\n\n<p>ディフィー・ヘルマン法の素数を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getGenerator([encoding])",
              "type": "method",
              "name": "getGenerator",
              "desc": "<!--\nReturns the Diffie-Hellman prime in the specified encoding, which can be\n`'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.\n-->\n\n<p>ディフィー・ヘルマン法の生成元を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPublicKey([encoding])",
              "type": "method",
              "name": "getPublicKey",
              "desc": "<!--\nReturns the Diffie-Hellman public key in the specified encoding, which can\nbe `'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.\n-->\n\n<p>ディフィー・ヘルマン法による公開鍵を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "desc": "<!--\nReturns the Diffie-Hellman private key in the specified encoding, which can\nbe `'binary'`, `'hex'`, or `'base64'`. Defaults to `'binary'`.\n-->\n\n<p>ディフィー・ヘルマン法による秘密鍵を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPublicKey(public_key, [encoding])",
              "type": "method",
              "name": "setPublicKey",
              "desc": "<!--\nSets the Diffie-Hellman public key. Key encoding can be `'binary'`, `'hex'`,\nor `'base64'`. Defaults to `'binary'`.\n-->\n\n<p>ディフィー・ヘルマン法による公開鍵を設定します。\n鍵のエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPrivateKey(public_key, [encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "desc": "<!--\nSets the Diffie-Hellman private key. Key encoding can be `'binary'`, `'hex'`,\nor `'base64'`. Defaults to `'binary'`.\n-->\n\n<p>ディフィー・ヘルマン法による秘密鍵を設定します。\n鍵のエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nデフォルトは <code>&#39;binary&#39;</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "Proposed API Changes in Future Versions of Node",
          "name": "proposed_api_changes_in_future_versions_of_node",
          "desc": "<!--\nThe Crypto module was added to Node before there was the concept of a\nunified Stream API, and before there were Buffer objects for handling\nbinary data.\n-->\n\n<p>Crypto モジュールは、統合されたストリーム API やバイトデータを扱う Buffer\nオブジェクトよりも先に Node に追加されました。\n\n</p>\n<!--\nAs such, the streaming classes don't have the typical methods found on\nother Node classes, and many methods accept and return Binary-encoded\nstrings by default rather than Buffers.\n-->\n\n<p>そのため、このストリーミングなクラスは他の Node のクラスに見られる\n典型的なメソッドを持たず、多くのメソッドは引数や戻り値に\nBuffer ではなくバイナリエンコードされた文字列を使います。\n\n</p>\n<!--\nA future version of node will make Buffers the default data type.\nThis will be a breaking change for some use cases, but not all.\n-->\n\n<p>将来のバージョンの Node では、Buffer がデフォルトのデータ型になります。\nこれはあるユースケースにおいては互換性を損ないますが、\n全てのケースではありません。\n\n</p>\n<!--\nFor example, if you currently use the default arguments to the Sign\nclass, and then pass the results to the Verify class, without ever\ninspecting the data, then it will continue to work as before.  Where\nyou now get a binary string and then present the binary string to the\nVerify object, you'll get a Buffer, and present the Buffer to the\nVerify object.\n-->\n\n<p>たとえば、Sign クラスをデフォルト引数で使っていて、\nその結果を全く調べずに Verify クラスに渡している場合、\nそれは以前と同じように動くでしょう。\nそれは、現時点ではバイナリ文字列を受け取ってそのバイナリ文字列を\nVeriy オブジェクトに渡しますが、将来は Buffer を受け取ってその\nBuffer を Verify オブジェクトに渡すようになります。\n\n</p>\n<!--\nHowever, if you are doing things with the string data that will not\nwork properly on Buffers (such as, concatenating them, storing in\ndatabases, etc.), or you are passing binary strings to the crypto\nfunctions without an encoding arguemnt, then you will need to start\nproviding encoding arguments to specify which encoding you'd like to\nuse.\n-->\n\n<p>しかしながら、Buffer が文字列と正確に同じようには動かない何かをしている場合\n(連結やデータの並べ替えなど)、あるいはバイナリ文字列を Crypto の関数に\nエンコーディング引数無しで渡している場合、エンコーディング引数を与えて\nどのエンコーディングを使用しているかを指定する必要があります。\n\n</p>\n<!--\nAlso, a Streaming API will be provided, but this will be done in such\na way as to preserve the legacy API surface.\n-->\n\n<p>同時に、ストリーミング API も提供されますが、それはレガシーな API\nを維持する方法でなされます。\n\n\n</p>\n",
          "type": "module",
          "displayName": "Proposed API Changes in Future Versions of Node"
        }
      ],
      "type": "module",
      "displayName": "Crypto"
    }
  ]
}
